<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="keywords" content="online documentation, web online help, web help, chm2web" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="generator" content="chm2web Pro 2.85 (unicode)" />
<title>Using Buffers</title>
<meta http-equiv="X-UA-Compatible" content="IE=9">

<link rel="stylesheet" href="../../../../files/helpindex.css" type=
"text/css">
<link rel="stylesheet" href="../../../../default.css" type=
"text/css">

<script type="text/JavaScript" src="../../../../files/supply.js"></script>
<script type="text/JavaScript">
chmtop.c2wtopf.pageid = "_build/1_overview/3_additional_information/using_buffers.html";
</script>

</head>
<body><script type="text/JavaScript"> 
if (window.name != "content") 
  document.write(" <table width=\"100%\" bgcolor=\"#e1e1e1\"cellspacing=\"2\" cellpadding=\"0\" style=\"border-collapse: collapse; font-family: sans-serif; font-size: 14px; color: #000000; text-decoration: none;  \"> <tr> <td align=\"center\" style=\"border-bottom: 2px solid gray\" > <br>&nbsp;Click <a href=\"../../../../index.html?page=source%2F_build%2F1_overview%2F3_additional_information%2Fusing_buffers.html\">here</a> to show toolbars of the Web Online Help System: <a href=\"../../../../index.html?page=source%2F_build%2F1_overview%2F3_additional_information%2Fusing_buffers.html\">show toolbars</a><br>&nbsp;</td></tr></table><br> "); 
</script>
<!-- !chm2web! --><script type="text/JavaScript">
 if( typeof(chmtop.helpStyle) != 'undefined' ) { var linkNodes = document.getElementsByTagName("link");  for( var i=0; i < linkNodes.length; ++i ) { var link = linkNodes[i];    if( link.href.endsWith("default.css")) {    var style = link.href.replace("default.css", chmtop.helpStyle); document.write('<link id="newstyleLink" rel="stylesheet" href=' + style + ' type="text/css">');    break; } } } 
</script><h2> Utiliser des tampons </h2><div class="body-scroll"><p><br></p><p> <i><span class="notranslate">GameMaker Studio 2</span></i> dispose d&#39;une série de fonctions dans GML pour gérer les <b>buffers</b>. La plupart des gens devraient être familiers avec ce terme car il est utilisé tout le temps quand il s&#39;agit d&#39;ordinateurs et de programmation, mais connaître le mot ne signifie pas que vous savez réellement ce que cela signifie. Cette page a donc pour but d&#39;expliquer ce qu&#39;est un buffer et comment l&#39;utiliser dans le contexte de la <i><span class="notranslate">GameMaker Studio 2</span></i> de <i><span class="notranslate">GameMaker Studio 2</span></i>, bien que la manière générale de travailler soit la même quelle que soit la langue ou la technologie, ce qui explique tellement important. </p><blockquote><a name="buffers" id="buffers"></a> <label class=
"collapse" for="one">Qu&#39;est-ce qu&#39;un tampon?</label> <input id="one"
type="checkbox"><div class="index_list"> Un tampon (en programmation) est essentiellement un espace dans la mémoire système qui est utilisé pour stocker de petits <i>paquets</i> de données pour à peu près n&#39;importe quoi (par exemple, transfert de données, collisions, données de couleur, etc...). Comme il est stocké dans la mémoire système, il est très rapide d&#39;accès, et un tampon est généralement utilisé pour le stockage à très court terme, comme la réception d&#39;informations réseau avant de le traiter, ou pour stocker un point de contrôle dans votre jeu. exemple donné plus bas sur la page). <img class="center" src=
"images/buffer_memory.png" alt="Mémoire tampon"> Les tampons sont créés en allouant un espace dans la mémoire du système, calculé en <b>octets</b>, qui est alors réservé à votre jeu tant que votre jeu est en cours ou jusqu&#39;à ce que vous supprimiez le tampon en utilisant la fonction appropriée. Cela signifie que même lorsque votre jeu n&#39;est pas au point (par exemple, sur un appareil mobile lorsque vous prenez un appel, le jeu sera mis en arrière-plan), le tampon existera toujours, mais si le jeu est fermé ou redémarré, le tampon sera perdu. <br><br><div class="note"> <b>NOTE:</b> Redémarrer le jeu n&#39;effacera pas ou n&#39;effacera pas le tampon! Mais cela empêchera tout accès supplémentaire au tampon précédemment créé car le <b>handle</b> de l&#39;identifiant aura été perdu, provoquant une fuite de mémoire qui finira par bloquer votre jeu. Donc, lorsque vous redémarrez un jeu, n&#39;oubliez pas de supprimer le tampon en premier. </div></div><br><a name="buffer_types" id="buffer_types"></a> <label class=
"collapse" for="two">Types de tampons</label> <input id="two" type=
"checkbox"><div class="index_list"> <i><span class="notranslate">GameMaker Studio 2</span></i> permet la création de quatre types de tampons différents. La raison en est que les tampons sont conçus pour être un support de stockage temporaire hautement optimisé, et en tant que tel, vous devez créer un tampon adapté au type de données que vous souhaitez stocker, sinon vous risquez d&#39;obtenir des erreurs ou de provoquer un <i>goulot d&#39;étranglement.</i> dans votre code. Avant d&#39;expliquer cela plus en détail, regardons les quatre types de tampons disponibles (définis comme des <b>constantes</b> dans GML): <br><br><div class="compat"><table><tr><th> Constant </th><th> la description </th></tr><tr><td> <span class="notranslate">buffer_fixed</span> </td> <td><br> Un tampon d&#39;une taille fixe en octets. La taille est définie lorsque le tampon est créé et ne peut plus être modifié. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">buffer_grow</span> </td> <td><br> Un tampon qui va <i>croître</i> dynamiquement à mesure que les données sont ajoutées. Vous le créez avec une taille initiale (qui devrait être une approximation de la taille des données que vous souhaitez stocker), puis il sera étendu pour accepter d&#39;autres données qui dépassent cette taille initiale. <br><br></td></tr><tr><td> <span class="notranslate">buffer_wrap</span> </td> <td><br> Un tampon où les données seront <i>envelopper</i>. Lorsque les données ajoutées atteignent la limite de la taille du tampon, l&#39;écrasement sera replacé au début de la mémoire tampon et l&#39;écriture continuera à partir de ce point. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">buffer_fast</span> </td> <td><br> C&#39;est un tampon &quot;dépouillé&quot; spécial extrêmement rapide à lire / écrire. Cependant, il ne peut être utilisé qu&#39;avec <tt>buffer_u8</tt> types de données, et doit être aligné sur 1 octet. (Des informations sur <b>les types de données</b> et l&#39; <b>alignement des octets</b> peuvent être trouvées plus bas sur cette page). <br><br></td></tr></table></div><br><br> Ce sont les types de tampons disponibles lorsque vous utilisez <i><span class="notranslate">GameMaker</span> Studio 2</i>, et celui que vous choisirez dépendra grandement de l&#39;utilisation que vous souhaitez en faire. Par exemple, un tampon de <b>croissance</b> serait utilisé pour stocker un &quot;instantané&quot; de données pour créer un jeu de sauvegarde puisque vous ne connaissez pas la quantité réelle de données qui vont y être placées, ou un tampon <b>rapide</b> serait utilisé lorsque vous sachez que les valeurs avec lesquelles vous travaillez sont toutes comprises entre 0 et 255 ou -128 et 127, par exemple lors du traitement de données RVB à partir d&#39;une image. <img class="center" src="images/buffer_types.png" alt="Types de tampons"> Lors de la création d&#39;un tampon, vous devriez toujours essayer de le créer à une taille appropriée au type, la règle générale étant qu&#39;il doit être créé pour s&#39;adapter à la taille maximale des données qu&#39;il doit stocker, et en cas de doute, utilisez un tampon de <b>croissance</b> pour éviter les erreurs d&#39;écrasement. <br><br> Le code actuel pour créer un tampon ressemblerait à ceci: <br><br><p class="code">player_buffer = buffer_create(16384, buffer_fixed,
2);<span class="notranslate"></span></p><br> Cela créerait un tampon fixe de 16384 octets et <b>octets alignés</b> sur 2, avec la fonction retournant une valeur d&#39; <b>identifiant</b> unique qui est stockée dans une variable pour le référencement ultérieur de ce tampon. Maintenant, nous avons le concept de base d&#39;un tampon expliqué, vous devriez en apprendre davantage sur <b>les types de données</b> et l&#39; <b>alignement des octets</b> mentionné précédemment. </div><br><a name="buffer_data_types" id="buffer_data_types"></a> <label class="collapse" for="three">Types de données de tampon</label> <input id="three" type="checkbox"><div class="index_list"> Lorsque vous lisez et écrivez des données dans un tampon, vous le faites en &#39;&#39; morceaux &#39;&#39; de données définies par leur &#39;&#39; &#39;type de données&#39; &#39;&#39;. Le &#39;&#39; &#39;type de données&#39; &#39;&#39; définit le nombre d&#39;octets alloués dans la mémoire tampon pour la valeur en cours d&#39;écriture, et il est essentiel que vous obteniez ceci correctement sinon vous obtiendrez des résultats très étranges (ou même des erreurs) pour votre code. <br><br> Les tampons sont écrits (et lus à partir de) de <i>manière séquentielle</i>, en ce sens qu&#39;un élément de données est écrit après l&#39;autre, chaque élément de données étant d&#39;un type défini. Cela signifie que vous devriez idéalement être conscient des données que vous écrivez dans le tampon à tout moment. Ces <b>types de données</b> sont définis en GML par les <i>constantes</i> suivantes: <div class="compat"><table><tr><th> Type de données Constante </th><th> Octets </th><th> La description </th></tr><tr><td> buffer_u8 </td><td> 1 </td><td><br> Un entier non signé de 8 bits. C&#39;est une valeur positive de 0 à 255. <br><br></td></tr><tr class="alt"><td> buffer_s8 </td><td> 1 </td><td><br> Un entier signé 8 bits. Cela peut être une valeur positive ou négative de -128 à 127 (0 est considéré comme positif). <br><br></td></tr><tr><td> buffer_u16 </td><td> 2 </td><td><br> Un entier non signé de 16 bits. C&#39;est une valeur positive de 0 à 65 535. <br><br></td></tr><tr class="alt"><td> buffer_s16 </td><td> 2 </td><td><br> Un entier signé 16 bits. Cela peut être une valeur positive ou négative de -32.768 à 32.767 (0 est considéré comme positif). <br><br></td></tr><tr><td> buffer_u32 </td><td> 4 </td><td><br> Un entier non signé, 32 bits. C&#39;est une valeur positive de 0 à 4 294 967 295. <br><br></td></tr><tr class="alt"><td> buffer_s32 </td><td> 4 </td><td><br> Un entier signé 32 bits. Cela peut être une valeur positive ou négative de -2 147 483 648 à 2 147 483 647 (0 est considéré comme positif). <br><br></td></tr><tr><td> buffer_f16 </td><td> 2 </td><td><br> Un nombre à virgule flottante de 16 bits. Cela peut être une valeur positive ou négative dans la plage de +/- 65504. <b>(Pas actuellement supporté!)</b> <br><br></td></tr><tr class="alt"><td> buffer_f32 </td><td> 4 </td><td><br> Un nombre à virgule flottante de 32 bits. Cela peut être une valeur positive ou négative dans la plage de +/- 16777216. <br><br></td></tr><tr><td> buffer_f64 </td><td> 8 </td><td><br> Un nombre à virgule flottante de 64 bits. Cela peut être une valeur positive ou négative de - (2 <sup>52</sup> ) à 2 <sup>52</sup> - 1. <br><br></td></tr><tr class="alt"><td> buffer_bool </td><td> 1 </td><td><br> Une valeur booléenne. Peut seulement être 1 ou 0 ( <tt>true</tt> ou <tt>false</tt> ) <br><br></td></tr><tr><td> buffer_string </td><td> N / A </td><td><br> C&#39;est une chaîne UTF-8 terminée par un caractère nul (0x00). Fondamentalement, une chaîne <span class="notranslate">GameMaker</span> est déversée dans le tampon, et un 0 est placé à la fin. <br><br></td></tr></table></div><br><br> Donc, disons que vous avez créé un tampon et que vous voulez écrire des informations, alors vous utiliserez quelque chose comme le code suivant: <br><br><p class="code">buffer_write(buff, buffer_bool, global.Sound);<br>
buffer_write(buff, buffer_bool, global.Music);<br>
buffer_write(buff, buffer_s16, obj_Player.x);<br>
buffer_write(buff, buffer_s16, obj_Player.y);<br>
buffer_write(buff, buffer_string, global.Player_Name);<br><span class="notranslate"></span></p><br> en regardant l&#39;exemple ci-dessus, vous pouvez voir que vous pouvez écrire différents types de données dans un tampon (vous êtes limité à un type de données spécifique en utilisant le type de tampon <b>rapide</b> ), et ces données seront ajoutées consécutivement dans le buffer (bien que la position réelle dans le tampon dépendra de son <b>alignement d&#39;octets</b>, expliqué ci-dessous). C&#39;est la même chose pour lire les informations du tampon, et dans le cas de l&#39;exemple donné ci-dessus, vous lirez le tampon dans le même ordre que celui dans lequel vous avez écrit les données, en vérifiant le même type de données, par exemple: <br><br><p class="code">global.Sound = buffer_read(buff, buffer_bool);<br>
global.Music = buffer_read(buff, buffer_bool);<br>
obj_Player.x = buffer_read(buff, buffer_s16);<br>
obj_Player.y = buffer_read(buff, buffer_s16);<br>
global.Player_Name = buffer_read(buff, buffer_string);<br><span class="notranslate"></span></p><br> Comme vous pouvez le voir, vous lisez les informations dans le même ordre que vous l&#39;avez lu dans le tampon. Pour plus d&#39;informations sur la façon d&#39;ajouter et de supprimer des données du tampon, veuillez consulter la section <b>Exemples</b> ci-dessous. </div><br><a name="buffer_alignment" id="buffer_alignment"></a> <label class=
"collapse" for="four">Alignement du tampon</label> <input id="four"
type="checkbox"><div class="index_list"> Si vous avez lu cette page, vous aurez vu des références à l&#39; <b>alignement</b> des <b>octets</b> d&#39;un tampon. Cela fait essentiellement référence à la <i>position dans</i> laquelle les nouvelles données seront stockées dans un tampon donné. Comment cela marche-t-il? Eh bien, pour un tampon aligné sur un seul octet, chaque donnée est écrite dans le tampon de manière séquentielle, chaque nouvelle donnée étant ajoutée directement après la précédente. Cependant, un tampon aligné sur 2 octets écrira chaque partie de données à des intervalles de 2 octets, de sorte que même si votre écriture initiale est de 1 octet de données, l&#39;écriture <i>suivante</i> sera déplacée pour s&#39;aligner sur deux octets. <img class="center" src=
"images/buffer_byte_alignment.png" alt="Alignement des octets de tampon"> Donc, si votre alignement d&#39;octets est fixé à, disons, 4 octets et que vous écrivez une seule donnée de 1 octet, faites un <i>buffer dit</i> (un <b>tell</b> obtient la position actuelle pour la lecture / écriture du buffer), obtiendra un <i>décalage</i> de 1 (le décalage dans ce cas est le nombre d&#39;octets depuis le début du tampon vers la position de lecture / écriture actuelle). <br><br> Cependant, si vous écrivez un autre morceau de données, également d&#39;une taille de 1 octet, <i>alors</i> faites un tampon dit, vous obtiendrez un décalage de 5 octets (même si vous avez seulement écrit 2 octets de données) car l&#39;alignement a <i>complété</i> les données pour l&#39;aligner avec l&#39;alignement du tampon de 4 octets. <br><br> Fondamentalement, ce que cela signifie est que l&#39;alignement n&#39;affectera que l&#39; <i>endroit où les choses sont écrites</i>, donc si vous faites un buffer après avoir écrit quelque chose, il retournera la position d&#39;écriture actuelle qui suit immédiatement les données que vous avez écrites précédemment. Notez, cependant, que si vous écrivez ensuite un autre morceau de données, en interne le tampon déplacera la position d&#39;écriture le long du multiple suivant de la taille d&#39;alignement avant d&#39;écrire réellement l&#39;élément de données. </div><br><a name="buffer_examples" id="buffer_examples"></a> <label class=
"collapse" for="five">Exemples de tampons</label> <input id="five"
type="checkbox"><div class="index_list"> Vous trouverez ci-dessous quelques exemples d&#39;utilisations courantes des tampons. <br><br><a name="buffer_checkpoint" id="buffer_checkpoint"></a> <label class="collapse" for="six">Faire un point de contrôle</label> <input id="six" type="checkbox"><div class="index_list"> Un exemple simple de la façon dont un tampon peut être utilisé dans n&#39;importe <i><span class="notranslate">GameMaker Studio 2</span></i> jeu <i><span class="notranslate">GameMaker Studio 2</span></i> pour n&#39;importe quelle plate-forme est la fonction <a href=
"../../3_scripting/4_gml_reference/game/game_save_buffer.html"><tt>game_save_buffer</tt></a>. Cette fonction prendra un «instantané» de l&#39;état actuel du jeu et l&#39;enregistrera dans un tampon prédéfini, qui pourra ensuite être lu pour charger à nouveau le jeu à ce point. <br><br><div class="note"> <b>NOTE:</b> Cette fonction est très limitée et il est conçu pour que le débutant puisse rapidement mettre en place un système de point de contrôle, mais les utilisateurs plus avancés préfèreront coder leur propre système en utilisant les <a href=
"../../3_scripting/4_gml_reference/file%20handling/index.html">fonctions Fichier</a>, car le jeu ne sauvegarde pas l&#39;une des ressources dynamiques que vous pouvez créer au moment de l&#39;exécution, comme les structures de données, les surfaces, les arrière-plans et les sprites ajoutés, etc. </div><br> La première chose que nous devons faire est de créer un nouvel objet pour contrôler l&#39;enregistrement et le chargement, donc vous en feriez un et lui donneriez un <b>événement de création</b>. Dans cet événement, vous pouvez placer le code suivant: <br><br><p class="code">SaveBuffer = buffer_create(1024, buffer_grow,
1);<br>
StateSaved = false;<br><span class="notranslate"></span></p><br> La première ligne crée un tampon de <b>croissance</b> (puisque nous ne connaissons pas la taille finale des données enregistrées) de 1024 octets et aligné sur 1 octet. Une variable est ensuite créée pour vérifier et voir si le jeu a été enregistré ou non (ceci sera utilisé pour le chargement). <br><br> Ensuite, nous ajouterons un <b>événement Keypress</b> (par exemple) dans lequel nous enregistrerons l&#39;état actuel du jeu dans le tampon créé: <br><br><p class="code">StateSaved = true;<br>
buffer_seek(SaveBuffer, buffer_seek_start, 0);<br>
game_save_buffer(SaveBuffer);<br><span class="notranslate"></span></p><br> Ce qui précède va d&#39;abord définir la variable de contrôle sur true (afin que cela soit sauvegardé lorsque nous sauvegardons le jeu dans la mémoire tampon) et ensuite <i>chercher</i> au début de la mémoire tampon avant d&#39;écrire l&#39;état de sauvegarde en cours. Pourquoi utilisons-nous <a href=
"../../3_scripting/4_gml_reference/buffers/buffer_seek.html"><tt>buffer_seek</tt></a> ? Eh bien, comme mentionné dans la section <b>Buffer Data Types</b> ci-dessus, vous lisez et écrivez dans un tampon à partir de la dernière position où les données ont été ajoutées. Cela signifie que si vous ne réglez pas le tampon <i>dire</i> revenir au début puis lorsque vous vous enregistrez ajouterez les données dans la mémoire tampon à la mémoire tampon position actuelle de lecture / écriture, donc nous utilisons la fonction <tt>buffer_seek</tt> pour déplacer le <i>tell</i> au début du tampon. <br><br> Nous avons maintenant sauvegardé l&#39;état actuel du jeu dans un tampon. L&#39;étape suivante consisterait à coder comment le charger, probablement dans un autre <b>événement Keypress</b>: <br><br><p class="code">if StateSaved<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;buffer_seek(SaveBuffer, buffer_seek_start,
0);<br>
&nbsp;&nbsp;&nbsp;game_load_buffer(SaveBuffer);<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Le jeu sera ensuite chargé à la fin de l&#39;événement dans lequel vous placez le code ci-dessus. <br><br><div class="note"> <b>NOTE:</b> Ceci est seulement pour une utilisation dans la même pièce, et non pour générer des parties complètes sauvegardées après que votre jeu ait été fermé ou redémarré! </div><br> La dernière chose à ajouter à l&#39;objet contrôleur est un code de &quot;nettoyage&quot;. Les tampons sont stockés dans la mémoire et, en tant que tels, si vous ne nettoyez pas lorsque vous en avez fini avec eux, vous pouvez obtenir des fuites de mémoire qui finiront par arriver à la fin de votre partie. Ainsi, vous ajouteriez probablement un <b>événement de fin de pièce</b> (de la catégorie <b>Autre</b> ) avec: <br><br><p class="code">buffer_delete(SaveBuffer);<span class="notranslate"></span></p><br> Cet objet peut maintenant être placé dans une pièce et appuyer sur une touche pour sauvegarder et charger l&#39;état de la pièce à partir d&#39;un tampon. <br><br></div><br><a name="buffer_networking" id="buffer_networking"></a> <label class="collapse" for="seven">Tampons de réseau</label> <input id="seven" type="checkbox"><div class="index_list"> Lorsque vous utilisez les fonctions réseau de <i><span class="notranslate">GameMaker Studio</span> 2</i>, vous devez utiliser des tampons pour créer le <i>paquet de</i> données envoyé via la connexion réseau. Cet exemple vise à montrer comment cela est fait, mais en raison de l&#39;étendue des possibilités de mise en réseau, il est uniquement conçu pour montrer comment utiliser les tampons eux-mêmes, et non pas le système de mise en réseau complet. <br><br> La première chose que nous allons montrer est la création et l&#39;utilisation d&#39;un tampon pour le côté client de la connexion réseau. Ce tampon sera utilisé pour créer de petits paquets de données qui peuvent ensuite être envoyés au serveur, donc dans l&#39; <b>événement</b> de <b>création</b> d&#39;une instance, nous assignerons un tampon comme ceci: <br><br><p class="code">send_buff = buffer_create(256, buffer_grow, 1);<span class="notranslate"></span></p><br> Nous rendons le tampon petit (256 octets) car il n&#39;est pas destiné à contenir de grandes quantités de données, nous en faisons un tampon de <i>croissance</i> pour éviter toute erreur si nous devons ajouter plus de données à envoyer à tout moment, et l&#39;alignement est réglé sur un pour la commodité. <br><br> Maintenant, disons que nous voulons que notre client envoie des données au serveur. Pour cela, nous devons créer un &quot;paquet&quot; de tampon, et dans cet exemple nous allons envoyer un <b>événement de presse clé</b>, comme lorsque le joueur appuie sur la <b>flèche gauche</b> pour se déplacer dans la partie. Pour ce faire, nous écrivons d&#39;abord les données nécessaires dans le tampon, puis nous l&#39;envoyons: <br><br><p class="code">buffer_seek(buff, buffer_seek_start, 0);<br>
buffer_write(buff, buffer_u8, 1);<br>
buffer_write(buff, buffer_s16, vk_left);<br>
buffer_write(buff, buffer_bool, true);<br>
network_send_packet(client, buff, buffer_tell(buff));<br><span class="notranslate"></span></p><br> Avant d&#39;écrire dans le tampon, nous avons mis le &quot;tell&quot; au début de la mémoire tampon car la mise en réseau prend <i>toujours</i> les données depuis le <b>début</b> d&#39;un tampon. Nous écrivons ensuite la valeur de <i>vérification</i> (celle-ci sera utilisée par le serveur pour déterminer le type d&#39;événement à traiter), puis la clé utilisée, puis l&#39;état de la clé (dans ce cas) <tt>true</tt> pour pressé). Ce tampon est ensuite envoyé en tant que paquet de données par la fonction réseau. Notez que nous n&#39;envoyons <i>pas</i> le tampon entier! Nous envoyons seulement les données écrites, en utilisant <a href=
"../../3_scripting/4_gml_reference/buffers/buffer_tell.html"><tt>buffer_tell</tt></a> Fonction pour retourner la position en cours de lecture / écriture du tampon (rappelez-vous que l&#39;écriture dans le tampon déplace le &quot;tell&quot; à la fin de ce qui a été écrit). <br><br> Qu&#39;en est-il de recevoir les données sur le serveur? Le paquet de données reçu qui doit être écrit dans le tampon sur le serveur puis utilisé pour mettre à jour le jeu. Pour cela nous utiliserions l&#39; <a href=
"../../2_interface/1_editors/events/async_events.html">événement asynchrone de mise</a> en réseau dans l&#39;objet de contrôleur de réseau du serveur, comme ce code simplifié ci-dessous montre: <br><br><p class="code">var buff = ds_map_find_value(async_load,
"buffer");<br>
if cmd == buffer_read(buff, buffer_u8);<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;key = buffer_read(buff, buffer_s16 );<br>
&nbsp;&nbsp;&nbsp;key_state = buffer_read(buff, buffer_bool);<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> L&#39;événement asynchrone contiendra un temporaire spécial <tt>ds_map</tt> (il est supprimé à la fin de l&#39;événement automatiquement) qui contient des informations différentes en fonction du type de données entrantes provenant du réseau. Dans ce cas, nous supposons que la carte a été vérifiée et qu&#39;il s&#39;agit d&#39;un paquet de données tampon envoyé par un client. Nous vérifions maintenant la première donnée qui se trouve dans la mémoire tampon pour voir quel type d&#39;événement a été envoyé - dans ce cas, la valeur &quot;1&quot; représente un événement <i>clé</i>, cependant en codant ces choses, vous devez définir des <b>constantes</b> pour maintenir ces valeurs simplifier les choses - puis stocker la clé en cours de pressage et son état ( <tt>true</tt> = pressé, <tt>false</tt> = libéré). Cette information serait ensuite utilisée pour mettre à jour tous les clients avec le nouveau statut du joueur client expéditeur. <br><br><div class="note"> <b>Remarque:</b> le tampon créé à partir de la carte ds_map est automatiquement supprimé à la fin de l&#39;événement asynchrone réseau, il n&#39;est donc pas nécessaire d&#39;utiliser <a href=
"../../3_scripting/4_gml_reference/buffers/buffer_delete.html"><tt>buffer_delete</tt></a> ici. </div></div></div></blockquote><p><br></p></div><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> Retour: <a href="index.html">Informations supplémentaires Index</a> </div><div style="float:right"> Suivant: <a href="texture_pages.html">Pages de texture</a> </div></div></div><h5> © Copyright <span class="notranslate">YoYo Games Ltd.</span> 2017 Tous droits réservés </h5>
<script type="text/javascript">
   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');   ga('create', 'UA-2711665-14', 'auto');   ga('send', 'pageview'); 
</script>
</div>

<script type="text/JavaScript">
var fe = FindFrame("toc", top);
if ((fe != null) && (chmtop.c2wtopf.jstree != null)) {
  if (chmtop.c2wtopf.FITEMS[chmtop.c2wtopf.pagenum] != chmtop.c2wtopf.pageid)
    chmtop.c2wtopf.jstree.OpenTreeNode("source/" + chmtop.c2wtopf.pageid);
}
</script>
</body>
</html>
