<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="keywords" content="online documentation, web online help, web help, chm2web" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="generator" content="chm2web Pro 2.85 (unicode)" />
<title>Using Buffers</title>
<meta http-equiv="X-UA-Compatible" content="IE=9">

<link rel="stylesheet" href="../../../../files/helpindex.css" type=
"text/css">
<link rel="stylesheet" href="../../../../default.css" type=
"text/css">

<script type="text/JavaScript" src="../../../../files/supply.js"></script>
<script type="text/JavaScript">
chmtop.c2wtopf.pageid = "_build/1_overview/3_additional_information/using_buffers.html";
</script>

</head>
<body><script type="text/JavaScript"> 
if (window.name != "content") 
  document.write(" <table width=\"100%\" bgcolor=\"#e1e1e1\"cellspacing=\"2\" cellpadding=\"0\" style=\"border-collapse: collapse; font-family: sans-serif; font-size: 14px; color: #000000; text-decoration: none;  \"> <tr> <td align=\"center\" style=\"border-bottom: 2px solid gray\" > <br>&nbsp;Click <a href=\"../../../../index.html?page=source%2F_build%2F1_overview%2F3_additional_information%2Fusing_buffers.html\">here</a> to show toolbars of the Web Online Help System: <a href=\"../../../../index.html?page=source%2F_build%2F1_overview%2F3_additional_information%2Fusing_buffers.html\">show toolbars</a><br>&nbsp;</td></tr></table><br> "); 
</script>
<!-- !chm2web! --><script type="text/JavaScript">
 if( typeof(chmtop.helpStyle) != 'undefined' ) { var linkNodes = document.getElementsByTagName("link");  for( var i=0; i < linkNodes.length; ++i ) { var link = linkNodes[i];    if( link.href.endsWith("default.css")) {    var style = link.href.replace("default.css", chmtop.helpStyle); document.write('<link id="newstyleLink" rel="stylesheet" href=' + style + ' type="text/css">');    break; } } } 
</script><h2> Utiliser des tampons </h2><div class="body-scroll"><p><br></p><p> <i><span class="notranslate">GameMaker Studio 2</span></i> propose une série de fonctions en langage GML permettant de gérer les <b>tampons</b>. La plupart des gens devraient être familiarisés avec ce terme, car il est utilisé tout le temps dans le traitement de l&#39;informatique et de la programmation, mais connaître le mot ne signifie pas en réalité que vous savez ce qu&#39;il signifie. Cette page a donc pour but d’expliquer ce qu&#39;est un tampon et comment l’utiliser dans le contexte de la <i><span class="notranslate">GameMaker Studio 2</span></i> de <i><span class="notranslate">GameMaker Studio 2</span></i>, bien que leur fonctionnement général soit le même, peu importe le langage ou la technologie, ce qui est l’une des raisons pour lesquelles ils sont utilisés. tellement important. </p><blockquote><a name="buffers" id="buffers"></a> <label class=
"collapse" for="one">Qu&#39;est-ce qu&#39;un tampon?</label> <input id="one"
type="checkbox"><div class="index_list"> Un tampon (en programmation) est essentiellement un espace dans la mémoire système utilisé pour stocker de petits <i>paquets</i> de données pour à peu près n&#39;importe quoi (par exemple, transfert de données, collisions, données de couleur, etc.). Comme il est conservé dans la mémoire système, il est très rapide à accéder et un tampon serait généralement utilisé pour un stockage à très court terme, comme pour recevoir des informations réseau avant de les traiter, ou pour stocker un point de contrôle dans votre jeu (ceci est expliqué dans exemple donné plus bas dans la page). <img class="center" src=
"images/buffer_memory.png" alt="Mémoire tampon"> Les tampons sont créés en allouant un espace dans la mémoire système, calculé en <b>octets</b>, qui est ensuite réservé pour votre jeu tant que votre jeu est en cours d&#39;exécution ou jusqu&#39;à ce que vous le supprimiez à l&#39;aide de la fonction appropriée. Cela signifie que même si votre jeu n&#39;est pas net (par exemple, sur un appareil mobile lorsque vous prenez un appel, le jeu sera mis en arrière-plan), la mémoire tampon existera toujours. Toutefois, si le jeu est fermé ou redémarré, le tampon sera perdu. <br><br><div class="note"> <b>REMARQUE: le</b> redémarrage du jeu n&#39;effacera ni ne supprimera le tampon! Mais il empêchera tout accès au tampon précédemment créé comme la <b>poignée</b> id aura été perdue, ce qui provoque une fuite de mémoire qui va planter votre jeu par la suite. Ainsi, lorsque vous redémarrez une partie, n&#39;oubliez pas de supprimer d&#39;abord le tampon. </div></div><br><a name="buffer_types" id="buffer_types"></a> <label class=
"collapse" for="two">Types de tampons</label> <input id="two" type=
"checkbox"><div class="index_list"> <i><span class="notranslate">GameMaker Studio 2</span></i> permet la création de quatre types de tampons différents. La raison en est que les tampons sont conçus pour être un support de stockage temporaire hautement optimisé. Vous devez donc créer un tampon approprié au type de données que vous souhaitez stocker, sinon vous risquez d&#39;obtenir des erreurs ou de causer un <i>goulot d&#39;étranglement.</i> dans votre code. Avant d’expliquer plus en profondeur, examinons les quatre types de mémoire tampon disponibles (définis en tant que <b>constantes</b> dans GML): <br><br><div class="compat"><table><tr><th> Constant </th><th> la description </th></tr><tr><td> <span class="notranslate">buffer_fixed</span> </td> <td><br> Un tampon d&#39;une taille fixe en octets. La taille est définie lors de la création du tampon et ne peut plus être modifiée. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">buffer_grow</span> </td> <td><br> Un tampon qui <i>grandira</i> dynamiquement à mesure que des données sont ajoutées. Vous le créez avec une taille initiale (qui devrait être une approximation de la taille des données à stocker), puis il se développera pour accepter des données supplémentaires dépassant cette taille initiale. <br><br></td></tr><tr><td> <span class="notranslate">buffer_wrap</span> </td> <td><br> Un tampon où les données seront <i>bouclées</i>. Lorsque les données ajoutées atteignent la limite de la taille de la mémoire tampon, l&#39;écrasement est replacé au début de la mémoire tampon et l&#39;écriture se poursuit à partir de ce point. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">buffer_fast</span> </td> <td><br> C&#39;est un tampon spécial &quot;dépouillé&quot; extrêmement rapide en lecture / écriture. Cependant, il ne peut être utilisé qu&#39;avec <tt>buffer_u8</tt> types de données et doivent être alignés sur 1 octet. (Vous trouverez des informations sur <b>les types de données</b> et l&#39; <b>alignement des octets</b> plus bas dans cette page). <br><br></td></tr></table></div><br><br> Ce sont les types de tampons disponibles lorsque vous utilisez <i><span class="notranslate">GameMaker</span> Studio 2</i>, et celui que vous choisirez dépendra énormément de l&#39;utilisation que vous souhaitez en faire. Par exemple, un tampon de <b>croissance</b> serait utilisé pour stocker un &quot;instantané&quot; de données afin de créer une sauvegarde car vous ne connaissez pas la quantité réelle de données qui y sera placée, ou un tampon <b>rapide</b> serait utilisé lors de la sauvegarde. Sachez que les valeurs que vous utilisez sont toutes comprises entre 0 et 255 ou -128 et 127, par exemple lors du traitement de données RVB à partir d’une image. <img class="center" src="images/buffer_types.png" alt="Types de tampons"> Lors de la création d&#39;un tampon, vous devez toujours essayer de le créer à une taille appropriée au type, la règle générale étant qu&#39;il doit être créé pour s&#39;adapter à la taille maximale des données qu&#39;il doit stocker et, en cas de doute, utilisez un tampon de <b>croissance</b> pour éviter les erreurs de remplacement. <br><br> Le code utilisé pour créer un tampon devrait ressembler à ceci: <br><br><p class="code">player_buffer = buffer_create(16384, buffer_fixed,
2);<span class="notranslate"></span></p><br> Cela créerait un tampon fixe de 16 384 octets et un <b>octet aligné</b> sur 2, la fonction renvoyant une valeur <b>id</b> unique qui est stockée dans une variable pour un référencement ultérieur de ce tampon. Nous avons maintenant expliqué le concept de base d&#39;un tampon, vous devriez en apprendre davantage sur <b>les types de données</b> et l&#39; <b>alignement d&#39;octets</b> mentionné précédemment. </div><br><a name="buffer_data_types" id="buffer_data_types"></a> <label class="collapse" for="three">Types de données tampons</label> <input id="three" type="checkbox"><div class="index_list"> Lorsque vous lisez et écrivez des données dans une mémoire tampon, vous le faites en &quot;morceaux&quot; de données définis par leur &quot;type de données&quot;. Le &#39;&#39; &#39;type de données&#39; &#39;&#39; définit le nombre d&#39;octets alloués dans la mémoire tampon pour la valeur en cours d&#39;écriture. Il est essentiel que vous obteniez cette information correcte sinon vous obtiendrez des résultats très étranges (voire des erreurs) pour votre code. <br><br> Les mémoires tampons sont écrites (et lues dans) <i>séquentiellement</i>, en ce sens que les données sont écrites les unes après les autres, chaque donnée étant d&#39;un type défini. Cela signifie que vous devriez idéalement savoir quelles données vous écrivez dans le tampon à tout moment. Ces <b>types de données</b> sont définis dans GML par les <i>constantes</i> suivantes: <div class="compat"><table><tr><th> Constante de type de données </th><th> Octets </th><th> La description </th></tr><tr><td> buffer_u8 </td><td> 1 </td><td><br> Un entier non signé de 8 bits. C&#39;est une valeur positive de 0 à 255. <br><br></td></tr><tr class="alt"><td> buffer_s8 </td><td> 1 </td><td><br> Un entier signé de 8 bits. Cela peut être une valeur positive ou négative de -128 à 127 (0 est considéré comme positif). <br><br></td></tr><tr><td> buffer_u16 </td><td> 2 </td><td><br> Un entier non signé de 16 bits. C&#39;est une valeur positive de 0 à 65 535. <br><br></td></tr><tr class="alt"><td> buffer_s16 </td><td> 2 </td><td><br> Un entier signé, 16 bits. Cela peut être une valeur positive ou négative de -32 768 à 32 767 (0 est considéré comme positif). <br><br></td></tr><tr><td> buffer_f16 </td><td> 2 </td><td><br> Un nombre à virgule flottante de 16 bits. Cela peut être une valeur positive ou négative dans la plage de +/- 65504. <b>(Non pris en charge actuellement!)</b> <br><br></td></tr><tr><td> buffer_u32 </td><td> 4 </td><td><br> Un entier non signé de 32 bits. C&#39;est une valeur positive de 0 à 4 294 967 295. <br><br></td></tr><tr class="alt"><td> buffer_s32 </td><td> 4 </td><td><br> Un entier signé 32 bits. Il peut s’agir d’une valeur positive ou négative comprise entre -2 147 483 648 et 2 147 483 647 (0 étant considéré comme positif). <br><br></td></tr><tr><td> buffer_f32 </td><td> 4 </td><td><br> Un nombre à virgule flottante de 32 bits. Cela peut être une valeur positive ou négative dans la plage de +/- 16777216. <br><br></td></tr><tr class="alt"><td> buffer_u64 </td><td> 8 </td><td><br> Une valeur entière non signée de 64 bits. <b>(Pas actuellement supporté par toutes les fonctions de tampon!)</b> <br><br></td></tr><tr><td> buffer_f64 </td><td> 8 </td><td><br> Un nombre à virgule flottante de 64 bits. <br><br></td></tr><tr class="alt"><td> buffer_bool </td><td> 1 </td><td><br> Une valeur booléenne. Ne peut être que 1 ou 0 ( <tt>true</tt> ou <tt>false</tt> ) <br><br></td></tr><tr><td> chaîne tampon </td><td> N / A </td><td><br> Il s&#39;agit d&#39;une chaîne UTF-8 à terminaison nulle (0x00). En gros, une chaîne <span class="notranslate">GameMaker</span> est <span class="notranslate">GameMaker</span> dans la mémoire tampon et un 0 à la fin. <br><br></td></tr></table></div><br><br> Donc, disons que vous avez créé un tampon et que vous voulez écrire des informations dessus, vous utiliseriez quelque chose comme le code suivant: <br><br><p class="code">buffer_write(buff, buffer_bool, global.Sound);<br>
buffer_write(buff, buffer_bool, global.Music);<br>
buffer_write(buff, buffer_s16, obj_Player.x);<br>
buffer_write(buff, buffer_s16, obj_Player.y);<br>
buffer_write(buff, buffer_string, global.Player_Name);<br><span class="notranslate"></span></p><br> En regardant l&#39;exemple ci-dessus, vous pouvez écrire différents types de données dans une mémoire tampon (vous n&#39;êtes limité qu&#39;à un type de données spécifique lorsque vous utilisez le type de mémoire tampon <b>rapide</b> ). Ces données seront ajoutées de manière consécutive dans la mémoire tampon (bien que sa la position réelle dans le tampon dépendra de son <b>alignement d&#39;octet</b>, expliqué ci-dessous). Il en va de même pour la lecture d&#39;informations à partir de la mémoire tampon. Dans l&#39;exemple ci-dessus, vous lirez dans la mémoire tampon dans le même ordre que celui dans lequel vous avez écrit les données, en recherchant le même type de données, par exemple: <br><br><p class="code">global.Sound = buffer_read(buff, buffer_bool);<br>
global.Music = buffer_read(buff, buffer_bool);<br>
obj_Player.x = buffer_read(buff, buffer_s16);<br>
obj_Player.y = buffer_read(buff, buffer_s16);<br>
global.Player_Name = buffer_read(buff, buffer_string);<br><span class="notranslate"></span></p><br> Comme vous pouvez le constater, vous lisez les informations dans le même ordre que dans le tampon. Pour plus d&#39;informations sur l&#39;ajout et la suppression de données de la mémoire tampon, veuillez consulter la section <b>Exemples</b> ci-dessous. </div><br><a name="buffer_alignment" id="buffer_alignment"></a> <label class=
"collapse" for="four">Alignement du tampon</label> <input id="four"
type="checkbox"><div class="index_list"> Si vous avez lu cette page, vous aurez vu des références à l’ <b>alignement d’octets</b> d’un tampon. Cela fait essentiellement référence à la <i>position dans</i> laquelle les nouvelles données seront stockées dans une mémoire tampon donnée. Comment cela marche-t-il? Eh bien, pour une mémoire tampon alignée sur un seul octet, chaque donnée est écrite dans la mémoire tampon de manière séquentielle, chaque nouvelle donnée étant ajoutée directement après la précédente. Toutefois, un tampon aligné sur 2 octets écrit chaque élément de données dans des intervalles de 2 octets. Ainsi, même si votre écriture initiale est d&#39;un octet de données, l&#39;écriture <i>suivante</i> sera déplacée pour s&#39;aligner sur deux octets. <img class="center" src=
"images/buffer_byte_alignment.png" alt="Alignement octet tampon"> Donc, si votre alignement d’octets est défini sur, par exemple, 4 octets et que vous écrivez une seule donnée de 1 octet, faites un <i>buffer tell</i> (un <b>tell</b> obtient la position actuelle de lecture / écriture pour le tampon), vous Vous obtiendrez un <i>décalage</i> de 1 (le décalage dans ce cas est le nombre d&#39;octets à partir du début du tampon jusqu&#39;à la position de lecture / écriture actuelle). <br><br> Cependant, si vous écrivez un autre morceau de données, également 1 octet en taille, <i>puis</i> faites un tampon dire, vous aurez un décalage de 5 octets (même si vous avez seulement écrit 2 octets de données) que l&#39;alignement a <i>capitonné</i> les données pour l&#39;aligner sur l&#39;alignement du tampon sur 4 octets. <br><br> En gros, cela signifie que l&#39;alignement n&#39;affectera que l&#39; <i>emplacement où les choses sont écrites</i>. Ainsi, si un tampon dit après avoir écrit quelque chose, il renverra la position d&#39;écriture actuelle qui suit immédiatement les données que vous avez écrites auparavant. Notez, toutefois, que si vous écrivez ensuite un autre élément de données, le tampon déplace en interne la position d&#39;écriture le long du multiple suivant de la taille d&#39;alignement avant d&#39;écrire réellement l&#39;élément de données. </div><br><a name="buffer_examples" id="buffer_examples"></a> <label class=
"collapse" for="five">Exemples de tampons</label> <input id="five"
type="checkbox"><div class="index_list"> Vous trouverez ci-dessous quelques exemples d&#39;utilisations courantes des mémoires tampons. <br><br><a name="buffer_checkpoint" id="buffer_checkpoint"></a> <label class="collapse" for="six">Faire un point de contrôle</label> <input id="six" type="checkbox"><div class="index_list"> Un exemple simple de la façon dont un tampon peut être utilisé dans tout jeu <i><span class="notranslate">GameMaker Studio 2</span></i> pour n’importe quelle plate-forme est la fonction <a href=
"../../3_scripting/4_gml_reference/game/game_save_buffer.html"><tt>game_save_buffer</tt></a>. Cette fonction prend un &quot;instantané&quot; de l’état actuel du jeu et l’enregistre dans un tampon prédéfini, qui peut ensuite être lu pour charger le jeu à nouveau. <br><br><div class="note"> <b>REMARQUE:</b> cette fonction est très limitée et conçue pour permettre aux débutants d’obtenir rapidement un système de point de contrôle opérationnel, mais les utilisateurs plus avancés préféreront peut-être coder leur propre système à l’aide des <a href=
"../../3_scripting/4_gml_reference/file%20handling/index.html">fonctions Fichier</a>, car le jeu ne sera pas sauvegardé. toutes les ressources dynamiques que vous pouvez créer au moment de l&#39;exécution, telles que les structures de données, les surfaces, les arrière-plans et les sprites ajoutés, etc. </div><br> La première chose à faire est de créer un nouvel objet pour contrôler la sauvegarde et le chargement. Vous devrez donc en créer un et lui donner un <b>événement Create</b>. Dans ce cas, vous pouvez placer le code suivant: <br><br><p class="code">SaveBuffer = buffer_create(1024, buffer_grow,
1);<br>
StateSaved = false;<br><span class="notranslate"></span></p><br> La première ligne crée un tampon de <b>croissance</b> (puisque nous ne connaissons pas la taille finale des données sauvegardées) de 1024 octets et aligné sur 1 octet. Une variable est ensuite créée pour vérifier et voir si le jeu a été sauvegardé ou non (cela sera utilisé pour le chargement). <br><br> Ensuite, nous ajouterons un <b>événement Keypress</b> (par exemple) dans lequel nous enregistrerons l’état actuel du jeu dans le tampon créé: <br><br><p class="code">StateSaved = true;<br>
buffer_seek(SaveBuffer, buffer_seek_start, 0);<br>
game_save_buffer(SaveBuffer);<br><span class="notranslate"></span></p><br> Ce qui précède va d&#39;abord définir la variable de contrôle sur true (pour que cela soit sauvegardé lorsque nous sauvegardons le jeu dans le tampon), puis <i>rechercher</i> le début du tampon avant d&#39;écrire l&#39;état de sauvegarde actuel. Pourquoi utilisons-nous <a href=
"../../3_scripting/4_gml_reference/buffers/buffer_seek.html"><tt>buffer_seek</tt></a> ? Comme mentionné dans la section <b>Types de données de mémoire tampon</b> ci-dessus, vous lisez et écrivez dans une mémoire tampon à partir de la dernière position à laquelle les données ont été ajoutées. Cela signifie que si vous ne réglez pas le tampon <i>dire</i> revenir au début puis lorsque vous vous enregistrez ajouterez les données dans la mémoire tampon à la mémoire tampon position actuelle de lecture / écriture, donc nous utilisons la fonction <tt>buffer_seek</tt> pour déplacer le <i>tell</i> au début de la mémoire tampon. <br><br> Nous avons maintenant enregistré l&#39;état actuel du jeu dans un tampon. La prochaine étape consisterait à indiquer comment le charger, probablement dans un autre <b>événement Keypress</b>: <br><br><p class="code">if StateSaved<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;buffer_seek(SaveBuffer, buffer_seek_start,
0);<br>
&nbsp;&nbsp;&nbsp;game_load_buffer(SaveBuffer);<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Le jeu sera alors chargé à la fin de l&#39;événement dans lequel vous placez le code ci-dessus. <br><br><div class="note"> <b>REMARQUE:</b> Ceci est uniquement destiné à être utilisé dans la même pièce et non pour générer des jeux sauvegardés complets après la fermeture ou le redémarrage de votre jeu! </div><br> La dernière chose à ajouter à l&#39;objet contrôleur est un code de &quot;nettoyage&quot;. Les mémoires tampons sont stockées dans la mémoire. Par conséquent, si vous ne nettoyez pas lorsque vous en avez terminé, vous risquez d’obtenir des fuites de mémoire qui risquent de retarder et de bloquer votre partie. Vous ajouterez donc probablement un <b>événement de fin de salle</b> (de la catégorie <b>Autre</b> événement) avec: <br><br><p class="code">buffer_delete(SaveBuffer);<span class="notranslate"></span></p><br> Cet objet peut maintenant être placé dans une pièce et sur une touche, enregistrer et charger l’état de la pièce à partir d’un tampon. <br><br></div><br><a name="buffer_networking" id="buffer_networking"></a> <label class="collapse" for="seven">Tampons réseau</label> <input id="seven" type="checkbox"><div class="index_list"> Lorsque vous utilisez les fonctions réseau de <i><span class="notranslate">GameMaker Studio</span> 2</i>, vous devez utiliser des tampons pour créer le <i>paquet de</i> données envoyé via la connexion réseau. Cet exemple vise à montrer comment cela est réalisé, mais en raison de l&#39;étendue des possibilités de mise en réseau, il est uniquement conçu pour montrer comment utiliser les tampons eux-mêmes, et non le système de réseau complet. <br><br> La première chose que nous montrerons est la création et l’utilisation d’un tampon pour le côté client de la connexion réseau. Ce tampon sera utilisé pour créer de petits paquets de données qui peuvent ensuite être envoyés au serveur. Ainsi, lors de la <b>création</b> d&#39;un <b>événement</b> d&#39;une instance, nous assignerions un tampon comme celui-ci: <br><br><p class="code">send_buff = buffer_create(256, buffer_grow, 1);<span class="notranslate"></span></p><br> Nous réduisons la taille de la mémoire tampon (256 octets), car elle n’est pas destinée à contenir de grandes quantités de données. Nous en faisons un tampon de <i>croissance qui</i> évite les erreurs si nous devons ajouter plus de données à envoyer à tout moment, et l’alignement est défini sur un pour la commodité. <br><br> Supposons maintenant que nous souhaitons que notre client envoie des données au serveur. Pour cela, nous devons créer un &quot;paquet&quot; de mémoire tampon. Dans cet exemple, nous allons envoyer un <b>événement Key Press</b>, comme lorsque le joueur appuie sur la <b>flèche gauche</b> pour se déplacer dans le jeu. Pour ce faire, nous écrivons d’abord les données nécessaires dans le tampon, puis nous les envoyons: <br><br><p class="code">buffer_seek(buff, buffer_seek_start, 0);<br>
buffer_write(buff, buffer_u8, 1);<br>
buffer_write(buff, buffer_s16, vk_left);<br>
buffer_write(buff, buffer_bool, true);<br>
network_send_packet(client, buff, buffer_tell(buff));<br><span class="notranslate"></span></p><br> Avant d&#39;écrire dans la mémoire tampon, nous avons paramétré &quot;tell&quot; au début de la mémoire tampon, car la mise en réseau prend <i>toujours</i> les données à partir du <b>début</b> de la mémoire tampon. Nous écrivons ensuite la valeur de <i>contrôle</i> (celle-ci sera utilisée par le serveur pour déterminer le type d’événement à traiter), puis la clé utilisée, puis son état (dans ce cas, <tt>true</tt> pour pressé). Ce tampon est ensuite envoyé sous forme de paquet de données par la fonction réseau. Notez que nous n&#39;envoyons <i>pas</i> tout le tampon! Nous n’envoyons que les données écrites, en utilisant le <a href=
"../../3_scripting/4_gml_reference/buffers/buffer_tell.html"><tt>buffer_tell</tt></a> fonction pour renvoyer la position courante de lecture / écriture du tampon (rappelez-vous que l&#39;écriture dans le tampon déplace le &quot;dire&quot; à la fin de ce qui a été écrit). <br><br> Qu&#39;en est-il de la réception des données sur le serveur? Le paquet de données reçu doit être écrit dans la mémoire tampon du serveur, puis utilisé pour mettre à jour le jeu. Pour cela, nous utiliserions l&#39; <a href=
"../../2_interface/1_editors/events/async_events.html">événement asynchrone de mise</a> en réseau dans l&#39;objet contrôleur de réseau du serveur, comme l&#39;indique le code simplifié ci-dessous: <br><br><p class="code">var buff = ds_map_find_value(async_load,
"buffer");<br>
if cmd == buffer_read(buff, buffer_u8);<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;key = buffer_read(buff, buffer_s16 );<br>
&nbsp;&nbsp;&nbsp;key_state = buffer_read(buff, buffer_bool);<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> L&#39;événement asynchrone contiendra un temporaire spécial <tt>ds_map</tt> (il est automatiquement supprimé à la fin de l&#39;événement) qui contient différentes informations en fonction du type de données entrantes provenant du réseau. Dans ce cas, nous supposons que la carte a été vérifiée et qu’il s’agit d’un paquet de données en mémoire tampon envoyé par un client. Nous vérifions maintenant le premier élément de données qui se trouve dans la mémoire tampon pour voir quel type d’événement a été envoyé. Dans ce cas, la valeur &quot;1&quot; représente un événement <i>clé</i>. Toutefois, lors du codage de ces éléments, vous devez définir des <b>constantes</b> pour conserver ces valeurs. simplifiez les choses - puis enregistrez la touche sur laquelle vous appuyez et son état ( <tt>true</tt> = pressé, <tt>false</tt> = libéré). Ces informations seraient ensuite utilisées pour mettre à jour tous les clients avec le nouveau statut du lecteur client émetteur. <br><br><div class="note"> <b>REMARQUE:</b> le tampon créé à partir de ds_map est automatiquement supprimé à la fin de l&#39;événement réseau asynchrone. Il n&#39;est donc pas nécessaire d&#39;utiliser <a href=
"../../3_scripting/4_gml_reference/buffers/buffer_delete.html"><tt>buffer_delete</tt></a> ici. </div></div></div></blockquote><p><br></p></div><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> Retour: <a href="index.html">Informations complémentaires Index</a> </div><div style="float:right"> Suivant: <a href="texture_pages.html">Pages de texture</a> </div></div></div><h5>© Copyright YoYo Games Ltd. 2018 All Rights Reserved</h5>
<script type="text/javascript">
   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');   ga('create', 'UA-2711665-14', 'auto');   ga('send', 'pageview'); 
</script>
</div>

<script type="text/JavaScript">
var fe = FindFrame("toc", top);
if ((fe != null) && (chmtop.c2wtopf.jstree != null)) {
  if (chmtop.c2wtopf.FITEMS[chmtop.c2wtopf.pagenum] != chmtop.c2wtopf.pageid)
    chmtop.c2wtopf.jstree.OpenTreeNode("source/" + chmtop.c2wtopf.pageid);
}
</script>
</body>
</html>
