<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="keywords" content="online documentation, web online help, web help, chm2web" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="generator" content="chm2web Pro 2.85 (unicode)" />
<title>Bitwise Operators And Binary</title>
<meta http-equiv="X-UA-Compatible" content="IE=9">

<link rel="stylesheet" href="../../../../files/helpindex.css" type=
"text/css">
<link rel="stylesheet" href="../../../../default.css" type=
"text/css">

<script type="text/JavaScript" src="../../../../files/supply.js"></script>
<script type="text/JavaScript">
chmtop.c2wtopf.pageid = "_build/1_overview/3_additional_information/bitwise_operators.html";
</script>

</head>
<body><script type="text/JavaScript"> 
if (window.name != "content") 
  document.write(" <table width=\"100%\" bgcolor=\"#e1e1e1\"cellspacing=\"2\" cellpadding=\"0\" style=\"border-collapse: collapse; font-family: sans-serif; font-size: 14px; color: #000000; text-decoration: none;  \"> <tr> <td align=\"center\" style=\"border-bottom: 2px solid gray\" > <br>&nbsp;Click <a href=\"../../../../index.html?page=source%2F_build%2F1_overview%2F3_additional_information%2Fbitwise_operators.html\">here</a> to show toolbars of the Web Online Help System: <a href=\"../../../../index.html?page=source%2F_build%2F1_overview%2F3_additional_information%2Fbitwise_operators.html\">show toolbars</a><br>&nbsp;</td></tr></table><br> "); 
</script>
<!-- !chm2web! --><script type="text/JavaScript">
 if( typeof(chmtop.helpStyle) != 'undefined' ) { var linkNodes = document.getElementsByTagName("link");  for( var i=0; i < linkNodes.length; ++i ) { var link = linkNodes[i];    if( link.href.endsWith("default.css")) {    var style = link.href.replace("default.css", chmtop.helpStyle); document.write('<link id="newstyleLink" rel="stylesheet" href=' + style + ' type="text/css">');    break; } } } 
</script><h2> Opérateurs binaires et binaires </h2><div class="body-scroll"><p><br></p><p> Au début de l&#39;ère informatique, binaire et hexadécimal (hexadécimal) constituaient un mode de vie, probablement parce que les langages de haut niveau (tels que BASIC) étaient tout simplement trop lents. Cependant, de nos jours, même avec la puissance du PC le plus moyen, vous n’avez plus besoin de savoir cela et vous pouvez faire les choses dans le temps, car la vitesse de la machine et la construction plus complexe de son processeur compenseront toute à venir cette approche a. </p><p> Comme exemple très simple, auparavant, multiplier par 32 aurait pu prendre plusieurs cycles de CPU, alors qu’une simple opération binaire pour faire la même chose n’aurait pris que 1. Comme les machines sont devenues plus complexes, elles ont également réduit le temps beaucoup d’instructions complexes prennent à exécuter de sorte que maintenant, une multiplication de 32x32 bits pourrait ne prendre que 1 cycle - identique à l’opérateur binaire. C’est une bonne nouvelle bien sûr, car cela signifie que vous n’aurez plus à optimiser chaque ligne de code que vous écrivez, mais si tel est le cas, devez-vous vraiment vous soucier du binaire? </p><p> La réponse est définitivement &quot;oui, vous devriez&quot;. Même s’il est vrai que vous pouvez toujours accélérer un peu - et parfois cela peut être important - utiliser binaire et hexadécimal vous permet de mieux connaître le processeur et peut également conduire à un meilleur code, à une meilleure compression des données et à la réalisation de certaines tâches. beaucoup plus simple. Cette page va expliquer un peu ce qu&#39;est le binaire et comment l&#39;utiliser pour créer vos jeux. </p><blockquote> <label class="collapse" for="one">La théorie du nombre</label> <input id="one" type="checkbox"><div class="index_list"> Examinons d’abord la théorie binaire la plus élémentaire - la manière dont les nombres sont créés. Regardez ce tableau: <br><br><p class="code">000 = 0<br>
001 = 1<br>
010 = 2<br>
100 = 4<br><span class="notranslate"></span></p><br> Chaque 1 ou 0 représente un seul <i>bit</i> de données, et comme vous pouvez le constater, cela signifie qu&#39;en binaire, 10 est égal à 2! Chaque bit correspond à <i>2 fois la valeur précédente,</i> le premier bit étant égal à 1. Ainsi, le bit 2 = 2, le bit 3 = 4, le bit 4 = 8 et ainsi de suite (comme indiqué ci-dessous dans ce tableau d&#39; <i>octets</i> - un octet étant une collection de 8 bits): <br><br><p class="code">00000001 = 1<br>
00000010 = 2<br>
00000100 = 4<br>
00001000 = 8<br>
00010000 = 16<br>
00100000 = 32<br>
01000000 = 64<br>
10000000 = 128<br><span class="notranslate"></span></p><br> C&#39;est bien si vous voulez des nombres d&#39;une puissance de 2, mais comment créer des nombres plus complexes? Un seul nombre binaire ne peut stocker qu&#39;un 0 ou un 1, et c&#39;est tout. Par conséquent, pour les nombres plus complexes, nous devons ajouter des bits. Si par exemple nous voulions faire 6, nous ajouterions 4 et 2 ensemble comme ça. <br><br><p class="code">00000010 = 2<br>
00000100 = 4<br>
00000110 = 6<br><span class="notranslate"></span></p><br> Cela est vrai de <i>tous</i> les nombres binaires et de la manière dont l&#39;ordinateur compose n&#39;importe quel nombre en interne. Prenons un autre nombre légèrement plus compliqué: 23. Le nombre 23 est en fait composé de 1 + 2 + 4 + 16 ou 00010111. Pourquoi pas un exemple beaucoup plus complexe: 196? Eh bien, il s&#39;agit de 128 + 64 + 4 ou 11000100. Donc, en réalité, ce n&#39;est pas si complexe. Si nous commençons à faire des valeurs en dehors de la plage d&#39;un octet (qui peut stocker des nombres de 0 à 255), cela commence à être un peu plus difficile à suivre. Par exemple, 217 361 correspond à 110101000100010001 en binaire. Ou, 1 + 16 + 256 + etc... Les règles sont les mêmes quelle que soit la valeur exprimée - chaque nombre est créé en additionnant plusieurs bits. </div><br> <label class="collapse" for="two">Opérateurs binaires</label> <input id="two" type="checkbox"><div class="index_list"> Maintenant qu&#39;est-ce que cela signifie en binaire? Eh bien, disons que vous voulez stocker un <tt>true</tt> ou <tt>false</tt> comme une valeur. Habituellement, les compilateurs utilisent un INT (un INT est généralement défini comme un numéro 32 bits signé), puis l&#39;attribuent simplement à 0 ou 1. Cependant, n&#39;ayant que 2 états, <tt>true</tt> / <tt>false</tt> la valeur est idéale pour stocker dans un peu, et si nous faisions cela, nous pourrions stocker 32 <tt>true</tt> / <tt>false</tt> bits pour chaque INT plutôt qu&#39;un seul. <br><br> Comment ferions-nous cela? Eh bien assez facilement, il s&#39;avère: <br><br><p class="code">flags = flags | 1;<br><span class="notranslate"></span></p><br> Le &quot;|&quot; L&#39;opérateur est un <b>OU au niveau des bits</b>, ce qui signifie que l&#39;instruction OU ci-dessus 1 est transformée en drapeaux. Si vous vous en souvenez, utiliser un 1 définira le premier bit. Si nous voulions définir le second bit, nous ferions ceci: <br><br><p class="code">flags = flags | 2;<br><span class="notranslate"></span></p><br> Nous OU en 2, car le motif binaire 00000010 est égal à 2. Alors, que fait exactement l&#39;opérateur OU binaire? Eh bien, il fusionne tous les bits en une seule valeur, comme ceci: <br><br><p class="code">010110100<br>
110011001<br>
110111101<br><span class="notranslate"></span></p><p><br> Voici ce qu&#39;on appelle une <i>table de vérité</i> pour l&#39;opérateur OR: <br><br></p><p class="code">00 | 00 = 00<br>
00 | 01 = 01<br>
01 | 01 = 01<br>
01 | 00 = 01<br><span class="notranslate"></span></p><br> Donc, là où il y a une valeur avec 2 zéros, ça restera zéro. L&#39;utilisation de BITS en tant qu&#39;état vrai / faux présente l&#39;avantage de pouvoir définir plusieurs indicateurs en une seule opération, ce que vous ne pouvez tout simplement pas faire avec une valeur booléenne normale. Par exemple, supposons que le bit 1 soit un indicateur &quot;actif&quot; et le bit 3, un indicateur &quot;visible&quot;. Nous pourrions définir les <i>deux</i> en faisant ceci: <br><br><p class="code">flags = flags | 5;<br><span class="notranslate"></span></p><br> En effet, 5 correspond à 00000101 en binaire et, conformément à la règle ci-dessus, la variable &quot;flags&quot; obtiendra ces deux bits fusionnés avec le sien. Ainsi, même si le bit 1 était déjà défini, l&#39;opération fonctionne toujours et le bit 3 sera également activé. <br><br> Qu&#39;en est-il de l&#39;élimination des drapeaux? Eh bien, c’est là que l’opération AND entre en jeu. Lorsque vous ET quelque chose, les bits définis dans le masque sont conservés, tandis que les bits supprimés dans le masque sont supprimés - comme ceci: <br><br><p class="code">01110010101<br>
00110000100<br>
00110000100<br><span class="notranslate"></span></p><br> Comme vous pouvez le constater, chaque valeur contient un bit, le bit est conservé et les combinaisons ou 0 et 1 sont réinitialisées à 0. Voici la table de vérité pour AND: <br><br><p class="code">00 &amp; 00 = 00<br>
01 &amp; 00 = 00<br>
00 &amp; 01 = 00<br>
01 &amp; 01 = 01<br><span class="notranslate"></span></p><p><br> Donc, ce n’est qu’un peu à la place qu’il sera conservé. Cela signifie que, tout comme vous pouvez <i>définir</i> plusieurs indicateurs à la fois, vous pouvez également <i>supprimer</i> plusieurs indicateurs à la fois. Par exemple, prenons le cas ci-dessus, mais cette fois, effacez-les. Nous voulons effacer les bits 1 et 3 (en nous donnant la valeur 5), mais en nous souvenant de la table de vérité ci-dessus, nous voulons conserver tous les autres bits et effacer les bits 1 et 3. Ce serait un masque &quot;binaire&quot;. &quot;de 1111111111111111111111111111111010 (32bits). Ce masque conserve tous les bits actuellement définis, mais efface les deux bits que nous voulons réellement effacer. Donc, si j&#39;avais une valeur de 1000111011 et que je voulais effacer les bits 1 et 3 en utilisant le masque ci-dessus, je me retrouverais avec ceci... <br><br></p><p class="code">00000000000000000000001000111011<br>
11111111111111111111111111111010<br>
00000000000000000000001000111010<br><span class="notranslate"></span></p><br> C’est formidable, mais si nous devions régler cela à chaque fois que nous devions effacer des drapeaux, cela deviendrait fastidieux. Ce qu&#39;il nous faut, c&#39;est un moyen de retourner facilement les bits (et de préférence sans coût de processeur). Heureusement, il existe un moyen simple de le faire en utilisant l&#39;opérateur NOT. <br><br> L&#39;opérateur NOT est exactement ce qu&#39;il dit - PAS ces bits. Voici une table de vérité pour NOT. <br><br><p class="code">~00 = 11<br>
~01 = 10<br>
~10 = 01<br>
~11 = 00<br><span class="notranslate"></span></p><br> Cet opérateur rend la suppression des indicateurs très simple. Mieux encore, il s&#39;agit généralement d&#39;une optimisation du temps de compilation, ce qui signifie que si vous utilisez un nombre constant (c&#39;est-à-dire pas une variable), le compilateur inversera automatiquement les bits pour vous. Prenez cette déclaration où nous voulons effacer les bits 1 et 3 à nouveau: <br><br><p class="code">a = a &amp; ~5;<br><span class="notranslate"></span></p><br> Cela compilera en fait juste &quot;a &amp; 1111111111111111111111111111111010&quot;. Cela rend la vie assez simple en termes de nettoyage des drapeaux. <br><br> Le dernier opérateur que nous voulons examiner est EOR (OR exclusif, parfois appelé XOR). Cet opérateur retourne les bits définis dans les <i>deux</i> valeurs. Voici la table de vérité EOR: <br><br><p class="code">0 ^ 0 = 0<br>
0 ^ 1 = 1<br>
1 ^ 0 = 1<br>
1 ^ 1 = 0<br><span class="notranslate"></span></p><br> C&#39;est curieux, mais incroyablement utile. Par exemple, supposons que nous voulions un compteur qui compte simplement de 0 à 1 et revient à 0 (basculement entre 0 et 1), nous pourrions en ajouter un et faire un IF pour voir si il est passé à 2, puis le remettre à zéro. 1. Ou... nous pourrions ajouter 1, puis ET avec 1 (puisque 01 + 01 = 10, et 10 &amp; 01 = 0) ou alors: <br><br><p class="code">a = a ^ 1;<br><span class="notranslate"></span></p><br> Ce que cela fait est que la première fois est 0 ^ 1 = 1, puis la deuxième fois 1 ^ 1 = 0, faisant ainsi basculer les choses de 0 à 1. <br><br> So - OR (|), AND (&amp;), NOT (~) et EOR (^) nous permettent de manipuler les bits avec une relative facilité, nous permettant ainsi, au niveau le plus simple, de contrôler plusieurs bits à la fois. Nous pouvons évidemment utiliser ces opérations pour d&#39;autres tâches lors du développement de nos jeux, comme le masquage des sprites, la réalisation d&#39;opérations MOD entières (avec AND) ou la création de jolis compteurs de boucles. </div><br> <label class="collapse" for="three">Arithmétique binaire simple</label> <input id="three" type="checkbox"><div class="index_list"> Comment un ordinateur ajoute-t-il? Eh bien, regardons un exemple très simple 1 + 1. <br><br><p class="code">00000001<br>
00000001<br>
00000010<br><span class="notranslate"></span></p><br> Comme pour les ajouts normaux, nous additionnons des nombres, puis nous débordons dans la colonne suivante, mais contrairement à un ajout décimal normal, nous ne pouvons aller qu&#39;à 1, pas à 9. Donc ajouter un 1 + 1 signifie que nous débordons dans 10. Alors regardons à un exemple plus complexe. <br><br><p class="code">01011011 = 91<br>
00101101 = 45<br>
10001000 = 136<br><span class="notranslate"></span></p><br> C&#39;est évidemment plus difficile à voir ici, mais les débordements se répercutent jusqu&#39;à ce qu&#39;il n&#39;y en ait plus dans une colonne - ou 2, moment auquel un bit de débordement fait 3 et il y reste. Heureusement, vous ne devez jamais vous inquiéter à ce sujet, sauf si vous souhaitez additionner de très grands nombres (comme des nombres 2x128 bits). Il est également intéressant de noter que les ordinateurs ne peuvent qu&#39;ajouter (ou soustraire, multiplier ou diviser) 2 nombres à la fois, même le SIMD est basé sur 2 calculs à la fois, mais en effectuant plusieurs calculs en parallèle. Prenez 19 + 19 + 19. Étant humains, nous pouvons additionner tous les 9, porter les 2 et ensuite nous y allons! Mais les ordinateurs ne peuvent pas faire cela - ce qu&#39;ils <i>peuvent</i> faire, c&#39;est ceci: (19 + 19) + 19. Donc, ils feront chaque calcul par blocs de 2. <br><br> Les calculs binaires qui nous intéressent et qui sont d’une grande utilité sont la multiplication et la division. Les ordinateurs ne se multiplient que par 2 et, pour en faire plus, ils décomposeront un nombre, puis additionneront tous les résultats. Prenons d’abord des exemples très simples. 4 * 2 = 8. Maintenant, pour multiplier par 2 en binaire, nous décalons tous les bits vers la gauche de un. Comme ça: <br><br><p class="code">00000100 * 2 = 00001000 = 8<span class="notranslate"></span></p><br> Tous les bits dans ce cas ont été déplacés vers la gauche par un, le faisant passer du troisième au quatrième, et modifiant la valeur de 4 à 8. Qu&#39;en est-il d&#39;un nombre plus grand? <br><br><p class="code">101 = 01100101 * 2 = 11001010 = 202<span class="notranslate"></span></p><br> Encore une fois, tous les bits se déplacent sur un, et cela multiple de 2. Alors, qu&#39;en est-il d&#39;un multiple de 4? Facile, nous décalons tout ce qui reste de 2, plutôt que d&#39;un. Alors que diriez-vous de 16 ou 128? Cela nécessiterait un décalage à gauche de 4 bits, ou 7 bits respectivement. C&#39;est incroyablement utile. cela signifie que nous pouvons faire de simples multiplications en déplaçant simplement des bits. Pour ce faire, nous utilisons l&#39;opérateur SHIFT &lt;&lt;. Voici quelques exemples: <br><br><p class="code">00000001 &lt;&lt; 1 = 000000010 = 2<br>
00000001 &lt;&lt; 2 = 000000100 = 4<br>
00000001 &lt;&lt; 3 = 000001000 = 8<br>
00000001 &lt;&lt; 4 = 000010000 = 16<br>
00000001 &lt;&lt; 5 = 000100000 = 32<br>
00000001 &lt;&lt; 6 = 001000000 = 64<br>
00000001 &lt;&lt; 7 = 010000000 = 128<br>
00000001 &lt;&lt; 8 = 100000000 = 256<br><span class="notranslate"></span></p><br> Maintenant, en plus d&#39;être très utile pour les multiplications rapides / simples, il est également très utile pour définir des bits spécifiques, sans avoir à calculer la valeur du bit. Disons que nous voulions définir le bit 27, de quel numéro s&#39;agit-il? (67108864 en passant!), Nous pouvons utiliser la syntaxe ci-dessus pour définir facilement des drapeaux comme celui-ci: <br><br><p class="code">A = A | (1&lt;&lt;27)<br><span class="notranslate"></span></p><br> D&#39;accord... donc, en fait, ce serait le bit 26 tel que je l&#39;ai décrit jusqu&#39;à présent (les bits commençant à un), mais en réalité... les bits commencent au bit 0 et vont vers le haut, pas vers le bit 1 Ainsi, alors qu’il existe 32 bits dans un INTEGER, les bits sont compris entre 0 et 31 et non entre 1 et 32. C’est en fait très utile, car nous pouvons maintenant configurer CONSTANTS pour les nombres de bits. <br><br> Donc, disons que le bit 27 est un drapeau actif et le bit 0, un drapeau qui explose. Comment pouvons-nous définir les deux? <br><br><p class="code">ACTIVE= 27;<br>
BOOM = 0;<br>
A = A | (1&lt;&lt;ACTIVE) | (1&lt;&lt;BOOM);<br><span class="notranslate"></span></p><br> Cela peut ressembler à beaucoup de code, mais si ces nombres sont des constantes, le compilateur précompilera ces opérations en une valeur unique de sorte que nous nous retrouverons avec cela comme du code réel. <br><br><p class="code">A = A | 13421772;<br><span class="notranslate"></span></p><br> Effacer ces bits (comme nous l’avons vu plus haut) consiste simplement à utiliser le modificateur NOT, comme ceci: <br><br><p class="code">A = A &amp; ~((1&lt;&lt;ACTIVE) |
(1&lt;&lt;BOOM));<br><span class="notranslate"></span></p><br> Cela nous permet donc de définir et de supprimer les bits de votre choix et de compresser massivement les structures de données. La compression des structures de données est une bonne chose, car si vous utilisez moins de mémoire, vous obtenez moins de données manquantes dans le cache et votre code est simplement exécuté plus rapidement. En d&#39;autres termes, quoi de plus rapide, copier 32 Mo ou 4 Mo de données? Eh bien, très clairement 4 est. Donc, si vous pouvez regrouper tous vos drapeaux dans un seul accès mémoire, c&#39;est bien! </div><br> <label class="collapse" for="four">Division binaire</label> <input id="four" type="checkbox"><div class="index_list"> Examinons rapidement comment vous divisez et pourquoi cela sera si utile. Prenons un nombre simple - 64 - et divisons par 32: <br><br><p class="code">64 / 32 = 01000000 &gt;&gt; 5 = 00000010<br><span class="notranslate"></span></p><br> Donc, il vous passez le seul bit par 5 ( ce qui est le nombre de quarts de travail requis pour 32 - regardez ci - dessus), ce qui nous donne 2. Mais ce qui se passe si ici sont autres bits là - dedans? Eh bien, jetons un coup d&#39;oeil: <br><br><p class="code">68 / 32 = 01000100 &gt;&gt; 5 = 00000010<br><span class="notranslate"></span></p><br> Alors voilà…. C&#39;est exactement pareil. Les bits que nous décalons sont simplement perdus. C’est vraiment très utile, car si nous avons besoin du reste du temps, il ya un moyen encore plus facile de le trouver, auquel nous reviendrons dans un instant. Mais prenons d’abord un exemple pratique. J&#39;ai une position X et Y, et je veux obtenir la cellule de grille dans laquelle elle se trouve, où la grille a une taille de 32x32. Cette méthode permet de stocker des objets, des collisions, des drapeaux - toutes sortes de choses et d’y accéder très rapidement. Alors on y va: <br><br><p class="code">var X_index = x&gt;&gt;5;<br>
var Y_index = y&gt;&gt;5;<br>
cell_data = mygrid[# X_index,Y_index];<br><span class="notranslate"></span></p><br> C&#39;est rapide, très rapide. Cela évite de recourir à une division en virgule flottante, puis à un calcul de floor (), qui s’ajoute. <br><br> Alors, si on voulait le reste? Peut-être que ce reste est utilisé comme une sorte d&#39;ordre ou quelque chose, peu importe la raison, obtenir un reste est aussi simple que de faire un AND: <br><br><p class="code">var r = x &amp; 31<br>
var X_Index = x&gt;&gt;5;<br><span class="notranslate"></span></p><br> Maintenant, les plus malins d&#39;entre vous ont peut-être remarqué que nous utilisions les deux méthodes (comme c&#39;est souvent le cas), mais il ne s&#39;agit toujours que de quelques instructions. Mais pourquoi le 31? Eh bien, comme le bit 5 est 32, tous les bits ci-dessous seraient 31, et c’est le reste maximum, c’est ce que nous ET avec (nous pourrions aussi utiliser ((1 &lt;&lt; 5) -1) qui ferait 32-1 = 31. Maintenant, si je devais faire cela sans comprendre le binaire, cela ressemblerait à ceci: <br><br><p class="code">var r = x mod 32;<br>
var X_Index = floor(x/32);<br><span class="notranslate"></span></p><br> Alors pourquoi est-ce pire? Eh bien, pour diviser par 32, nous devons exécuter une division à virgule flottante - ce qui prend évidemment du temps, mais pour faire le mod 32, vous devez en faire un autre! Si nous faisions cela en assembleur, nous obtenons les deux valeurs dans une division, mais pas dans les langages de haut niveau (enfin… pas très souvent), et vous devez donc faire tout le travail deux fois. Cela ajoute, surtout si vous faites une boucle serrée avec beaucoup de calculs comme celui-ci. Les divisions entières, comme indiqué ci-dessus, aident vraiment à optimiser votre jeu. </div></blockquote><p><br></p><h2> Exemples </h2><p><br></p><p> Étant donné que ce concept peut être assez complexe à comprendre et à appliquer à des situations de programmation réelles, vous trouverez ci-dessous une série de courts exemples pouvant être appliqués à tout jeu créé avec <i><span class="notranslate">GameMaker Studio 2</span></i>. </p><blockquote> <label class="collapse" for="five">Alignement des carreaux</label> <input id="five" type="checkbox"><div class="index_list"> <i><span class="notranslate">GameMaker Studio 2</span></i> utilisent souvent la fonction <tt>place_free()</tt>, puis quand une collision est détectée, essayez de déplacer lentement l’objet vers l’extérieur en faisant une boucle autour d’une position x ou y (ou de quelque chose) tout en continuant d’exécuter cette fonction, ou en utilisant la commande <tt>move_outside_all()</tt> une fonction. <br><br> Alors, quel est le moyen le plus rapide de faire cela? Eh bien, si nous utilisons une mosaïque de puissance de 2, nous avons une méthode très simple, rapide et rapide. Si nous nous déplaçons à droite et si nous entrons dans un bloc de collision, alors que nous savons que tout est aligné sur 32, nous devons également aligner l&#39;image-objet sur une limite de 32 pixels - de préférence celle située à gauche - de sorte que l&#39;image-objet est déplacé hors de la collision. C&#39;est très facile, connaissant les règles que nous avons utilisées ci-dessus pour obtenir le reste, et sachant obtenir l&#39;inverse des bits, nous pouvons simplement faire ceci: <br><br><p class="code">x = x&amp;~31;<br><span class="notranslate"></span></p><br> C&#39;est vrai, c&#39;est tout ce qu&#39;il faut pour s&#39;aligner sur une limite de 32 pixels. En modifiant le chiffre 31, nous pouvons aligner nos choix sur tout ce qui nous plait - à condition que la puissance soit égale à 2. (Cela équivaut à diviser par 32, puis multiplier par 32, supprimant ainsi les bits inférieurs.) <br><br> Si nous voulions nous aligner à droite, nous ferions ce qui précède, mais ajoutons ensuite 32 pour le déplacer dans la prochaine tuile. Simple. Tout cela accélère considérablement le code de collision et vous permet de passer du temps CPU où vous en avez vraiment besoin. </div><br> <label class="collapse" for="six">Clés et portes</label> <input id=
"six" type="checkbox"><div class="index_list"> Supposons que vous ayez un niveau avec quelques portes et une clé pour chacune. Comment pouvez-vous facilement marquer une clé pour une clé? Eh bien, normalement, vous devez simplement attribuer un identifiant à la clé et à la porte. Et si vous vouliez une clé pour ouvrir 2 ou 3 portes? Facile. Vous utilisez un masque. La porte se verrait attribuer un seul &quot;bit&quot; comme suit: door_id = 1 (0001), un autre avec door_id = 2 (0010), door_id = 4 (0100), door_id = 8 (1000), etc. Si nous voulions que la clé ouvre les portes 1 et 3, alors la clé aurait le MASK de 5 (qui est 101 en binaire). Si nous effectuons un ET de cela et que cela sort &quot;pas zéro&quot;, nous savons alors si la clé peut ouvrir la porte. Vous pouvez également avoir des clés qui n&#39;ouvrent rien en ayant un MASQUE de 0. Voir le code ci-dessous pour le contrôle réel: <br><br><p class="code">if( (key_id &amp; door_id) !=0 ) { opendoor();
}<br><span class="notranslate"></span></p></div><br> <label class="collapse" for="seven">Compteurs en boucle</label> <input id="seven" type="checkbox"><div class="index_list"> Supposons que nous voulions un compteur d&#39;animation simple, comptant de 0 à 15 (comme nous avons 16 images d&#39;animation), nous pouvons maintenant faire un incrément, puis un IF, ou bien utiliser notre connaissance du binaire et supprimer le SI complètement. Les FI sont lents et si nous n&#39;en avons pas besoin, nous devrions les supprimer. <br><br><p class="code">counter = (counter+1)&amp;15;<br><span class="notranslate"></span></p><br> Étant donné que 16 images correspond à une puissance de 2, et que 0 est inclus dans le compteur, nous pouvons réduire le nombre POW2 de 1 et l’utiliser en tant que MASK, ce qui nous permet de l’envelopper dans notre compteur. Si le compteur passe de 15 à 16, nous obtenons le motif de bits 10000, et si nous avons ensuite AND avec 15 (motif de bits 01111), nous nous retrouvons avec 0. Cela signifie que le code ci-dessus est incroyablement utile pour le wrapping des compteurs - tant que vous utilisez des numéros d&#39;image POW2. </div><br> <label class="collapse" for="eight">Puissance de 2 chèque</label> <input id="eight" type="checkbox"><div class="index_list"> Et si vous vouliez vérifier si quelque chose était une puissance de 2? Eh bien, voici un petit tour astucieux.. Cela retournera TRUE si argument0 est une puissance de 2. <br><br><p class="code">return (argument0&amp;(argument0-1))==0;<br><span class="notranslate"></span></p><br> Donc, si nous avions le numéro 51 (110011), qu&#39;est-ce que cela fait? Eh bien, nous avons ceci... 110011 &amp; 110010, ce qui nous laisse évidemment avec FALSE, car il reste beaucoup de &quot;bits&quot; après AND. Si nous avions 64 1000000, alors cela devient ceci... 1000000 &amp; 0111111 qui nous laisse 0, donc c&#39;est VRAI. </div><br> <label class="collapse" for="nine">Index Index</label> <input id="nine" type="checkbox"><div class="index_list"> Voici un petit morceau de code à aligner sur une puissance de 2 chiffres. (1,2,4,8,16 et ainsi de suite). Cela peut être très utile pour l&#39;allocation de mémoire ou pour vous assurer d&#39;écrire des données dans des limites appropriées. Dans cet exemple, argument0 doit être aligné sur octets argument1, où argument1 est une puissance de 2. Ce petit script arrondit à la limite suivante du nombre souhaité. <br><br><p class="code">return (argument0 + (argument1-1)) &amp;
~(argument1-1);<br><span class="notranslate"></span></p><br></div></blockquote><p><br></p></div><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> Retour: <a href="index.html">Informations complémentaires Index</a> </div><div style="float:right"> Next: <a href="errors.html">Erreurs du compilateur</a> </div></div></div><h5>© Copyright YoYo Games Ltd. 2018 All Rights Reserved</h5>
<script type="text/javascript">
   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');   ga('create', 'UA-2711665-14', 'auto');   ga('send', 'pageview'); 
</script>
</div>

<script type="text/JavaScript">
var fe = FindFrame("toc", top);
if ((fe != null) && (chmtop.c2wtopf.jstree != null)) {
  if (chmtop.c2wtopf.FITEMS[chmtop.c2wtopf.pagenum] != chmtop.c2wtopf.pageid)
    chmtop.c2wtopf.jstree.OpenTreeNode("source/" + chmtop.c2wtopf.pageid);
}
</script>
</body>
</html>
