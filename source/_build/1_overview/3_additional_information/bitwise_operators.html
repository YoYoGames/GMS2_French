<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="keywords" content="online documentation, web online help, web help, chm2web" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="generator" content="chm2web Pro 2.85 (unicode)" />
<title>Bitwise Operators And Binary</title>
<meta http-equiv="X-UA-Compatible" content="IE=9">

<link rel="stylesheet" href="../../../../files/helpindex.css" type=
"text/css">
<link rel="stylesheet" href="../../../../default.css" type=
"text/css">

<script type="text/JavaScript" src="../../../../files/supply.js"></script>
<script type="text/JavaScript">
chmtop.c2wtopf.pageid = "_build/1_overview/3_additional_information/bitwise_operators.html";
</script>

</head>
<body><script type="text/JavaScript"> 
if (window.name != "content") 
  document.write(" <table width=\"100%\" bgcolor=\"#e1e1e1\"cellspacing=\"2\" cellpadding=\"0\" style=\"border-collapse: collapse; font-family: sans-serif; font-size: 14px; color: #000000; text-decoration: none;  \"> <tr> <td align=\"center\" style=\"border-bottom: 2px solid gray\" > <br>&nbsp;Click <a href=\"../../../../index.html?page=source%2F_build%2F1_overview%2F3_additional_information%2Fbitwise_operators.html\">here</a> to show toolbars of the Web Online Help System: <a href=\"../../../../index.html?page=source%2F_build%2F1_overview%2F3_additional_information%2Fbitwise_operators.html\">show toolbars</a><br>&nbsp;</td></tr></table><br> "); 
</script>
<!-- !chm2web! --><script type="text/JavaScript">
 if( typeof(chmtop.helpStyle) != 'undefined' ) { var linkNodes = document.getElementsByTagName("link");  for( var i=0; i < linkNodes.length; ++i ) { var link = linkNodes[i];    if( link.href.endsWith("default.css")) {    var style = link.href.replace("default.css", chmtop.helpStyle); document.write('<link id="newstyleLink" rel="stylesheet" href=' + style + ' type="text/css">');    break; } } } 
</script><h2> Opérateurs bit à bit et binaires </h2><div class="body-scroll"><p><br></p><p> Au début de l&#39;ère de l&#39;informatique, binaire et hexadécimal étaient un mode de vie, probablement parce que les langages de haut niveau (comme BASIC) étaient simplement trop lents. Ces jours-ci, avec la puissance du PC le plus moyen, vous n&#39;avez plus besoin de savoir quoi que ce soit et vous pouvez faire beaucoup de choses, car la vitesse de la machine et sa construction CPU plus complexe compenseront tout vient cette approche a. </p><p> Comme un exemple très simple, dans le passé, multiplier par 32 aurait pu prendre plusieurs cycles CPU à exécuter, alors qu&#39;une simple opération binaire pour faire la même chose aurait pris seulement 1. Comme les machines sont devenues plus complexes, elles ont aussi réduit le temps de nombreuses instructions complexes sont exécutées de telle sorte que, maintenant, une multiplication de 32x32 bits peut bien prendre seulement un cycle - même chose que l&#39;opérateur binaire. C&#39;est une bonne nouvelle, bien sûr, car cela signifie que vous n&#39;avez plus besoin d&#39;optimiser chaque ligne de code que vous écrivez, mais si c&#39;est le cas, devriez-vous vraiment vous préoccuper de binaire? </p><p> La réponse est définitivement &quot;oui, vous devriez&quot;. Tandis que c&#39;est vrai, vous pouvez toujours obtenir des accélérations - et parfois elles peuvent être significatives - en utilisant binaire et hexadécimal pour mieux connaître le CPU et aussi améliorer l&#39;écriture de code, être capable de mieux emballer les données et de faire certaines tâches beaucoup plus simple. Cette page va expliquer un peu ce qu&#39;est le binaire ainsi que comment il peut être utilisé lors de vos jeux. </p><blockquote> <label class="collapse" for="one">La théorie du nombre</label> <input id="one" type="checkbox"><div class="index_list"> Regardons d&#39;abord la théorie binaire la plus fondamentale - comment les nombres sont créés. Jetez un oeil à cette table: <br><br><p class="code">000 = 0<br>
001 = 1<br>
010 = 2<br>
100 = 4<br><span class="notranslate"></span></p><br> Chaque 1 ou 0 représente un seul <i>bit</i> de données, et comme vous pouvez le voir, cela signifie qu&#39;en binaire, 10 équivaut à 2! Chaque bit est <i>2 fois la valeur précédente</i> avec le premier bit étant égal à 1. Donc bit 2 = 2, bit 3 = 4, bit 4 = 8 et ainsi de suite (comme indiqué ci-dessous dans ce tableau <i>octet</i> - un octet est une collection de 8 bits): <br><br><p class="code">00000001 = 1<br>
00000010 = 2<br>
00000100 = 4<br>
00001000 = 8<br>
00010000 = 16<br>
00100000 = 32<br>
01000000 = 64<br>
10000000 = 128<br><span class="notranslate"></span></p><br> C&#39;est bien si vous voulez des nombres qui sont une puissance de 2, mais comment créons-nous des nombres plus complexes? Eh bien, un seul nombre binaire ne peut stocker qu&#39;un 0 ou un 1, et c&#39;est tout, alors pour les nombres plus complexes, nous devons ajouter des bits ensemble. Si par exemple nous voulions faire 6, nous ajouterions 4 et 2 ensemble comme ça. <br><br><p class="code">00000010 = 2<br>
00000100 = 4<br>
00000110 = 6<br><span class="notranslate"></span></p><br> Ceci est vrai pour <i>tous</i> les nombres binaires, et comment l&#39;ordinateur compose un nombre interne. Prenons un exemple un peu plus compliqué: 23. Le nombre 23 est composé de 1 + 2 + 4 + 16 ou 00010111. Que diriez-vous d&#39;un exemple beaucoup plus complexe: 196? Eh bien, c&#39;est fait à partir de 128 + 64 + 4 ou 11000100. Donc en fait pas vraiment complexe. Si nous commençons à faire des valeurs en dehors de la plage d&#39;un octet (qui peut stocker des nombres de 0 à 255), il commence à être un peu plus difficile à suivre. Par exemple, 217 361 est 110101000100010001 en binaire. Ou, 1 + 16 + 256 + etc... Les règles sont les mêmes quelle que soit la valeur exprimée - chaque nombre est créé en ajoutant plusieurs bits ensemble. </div><br> <label class="collapse" for="two">Opérateurs binaires</label> <input id="two" type="checkbox"><div class="index_list"> Qu&#39;est-ce que cela signifie en binaire? Eh bien, disons que vous voulez stocker un <tt>true</tt> ou <tt>false</tt> comme une valeur. Habituellement, les compilateurs utiliseront un INT (un INT est généralement défini comme un nombre 32 bits signé), puis l&#39;assignent simplement à 0 ou 1. Cependant, ayant seulement 2 états, un <tt>true</tt> / <tt>false</tt> la valeur est idéale pour stocker dans un peu, et si nous avons fait cela, nous pourrions stocker 32 <tt>true</tt> / <tt>false</tt> bits pour chaque INT plutôt qu&#39;un seul. <br><br> Comment ferions-nous cela? Eh bien assez facilement, il s&#39;avère: <br><br><p class="code">flags = flags | 1;<br><span class="notranslate"></span></p><br> Le &quot;|&quot; L&#39;opérateur est un <b>OR bit à bit</b>, ce qui signifie que l&#39;instruction ORs 1 ci-dessus est en drapeau. Si vous vous souvenez de plus tôt, l&#39;utilisation d&#39;un 1 définira le premier bit. Si nous voulions définir le second bit, nous ferions ceci: <br><br><p class="code">flags = flags | 2;<br><span class="notranslate"></span></p><br> Nous OU dans 2, parce que le modèle de bits 00000010 est égal à 2. Alors, que fait exactement l&#39;opérateur OU binaire? Eh bien, il fusionne tous les bits en une seule valeur, comme ceci: <br><br><p class="code">010110100<br>
110011001<br>
110111101<br><span class="notranslate"></span></p><p><br> Voici ce qu&#39;on appelle une <i>table de vérité</i> pour l&#39;opérateur OR: <br><br></p><p class="code">00 | 00 = 00<br>
00 | 01 = 01<br>
01 | 01 = 01<br>
01 | 00 = 01<br><span class="notranslate"></span></p><br> Donc, là où il y a une valeur avec 2 zéros, ça restera nul. L&#39;avantage d&#39;utiliser BITS comme état vrai / faux, c&#39;est qu&#39;ils vous permettent de définir plusieurs indicateurs en une seule opération, ce que vous ne pouvez pas faire avec une valeur booléenne normale. Par exemple, disons que le bit 1 est un indicateur &quot;actif&quot; et le bit 3 est un indicateur &quot;visible&quot;. Nous pourrions définir les <i>deux</i> en faisant ceci: <br><br><p class="code">flags = flags | 5;<br><span class="notranslate"></span></p><br> C&#39;est parce que 5 est 00000101 en binaire, et suivant la règle ci-dessus, la variable &quot;flags&quot; obtiendra ces deux bits fusionnés avec les siens. Donc, même si le bit 1 était déjà défini, l&#39;opération fonctionne toujours et le bit 3 sera également défini. <br><br> Qu&#39;en est-il de la compensation des drapeaux? Eh bien, c&#39;est là que l&#39;opération binaire ET entre en jeu. Lorsque vous ET quelque chose vous les bits qui sont définis dans le masque sont conservés, tandis que les bits qui sont claires dans le masque, sont supprimés - comme ceci: <br><br><p class="code">01110010101<br>
00110000100<br>
00110000100<br><span class="notranslate"></span></p><br> Comme vous pouvez le voir, où il y a un bit dans chaque valeur, le bit est conservé, et où il y a un mélange ou 0 et 1, ceux-ci sont réinitialisés à 0. Voici la table de vérité pour AND: <br><br><p class="code">00 &amp; 00 = 00<br>
01 &amp; 00 = 00<br>
00 &amp; 01 = 00<br>
01 &amp; 01 = 01<br><span class="notranslate"></span></p><p><br> Donc, seulement quand il y a un peu à chaque endroit, il sera conservé. Cela signifie que, tout comme vous pouvez <i>définir</i> plusieurs indicateurs à la fois, vous pouvez également <i>effacer</i> plusieurs indicateurs à la fois. Par exemple, prenons le cas ci-dessus, mais cette fois les effacer. Nous voulons effacer les bits 1 et 3 (en nous donnant la valeur 5), mais en rappelant le tableau de vérité ci-dessus, nous voulons garder tous les autres bits, et effacer les bits 1 et 3. Ce serait un masque binaire &quot;de 11111111111111111111111111111010 (32bits). Ce masque conserve tous les bits actuellement définis, mais efface les deux bits que nous voulons réellement effacer. Donc si j&#39;avais une valeur de 1000111011 et que je voulais effacer les bits 1 et 3 en utilisant le masque ci-dessus, je finirais par ça... <br><br></p><p class="code">00000000000000000000001000111011<br>
11111111111111111111111111111010<br>
00000000000000000000001000111010<br><span class="notranslate"></span></p><br> C&#39;est très bien, mais si nous devions régler ce problème chaque fois que nous devions enlever des drapeaux, cela deviendrait fastidieux. Ce dont nous avons besoin, c&#39;est d&#39;un moyen de retourner les bits facilement (et de préférence sans coût CPU). Heureusement, il existe un moyen facile de le faire en utilisant l&#39;opérateur NOT. <br><br> L&#39;opérateur NOT est juste ce qu&#39;il dit - PAS ces bits. Voici une table de vérité pour NOT. <br><br><p class="code">~00 = 11<br>
~01 = 10<br>
~10 = 01<br>
~11 = 00<br><span class="notranslate"></span></p><br> Cet opérateur rend la suppression des drapeaux très simple, et mieux encore, c&#39;est généralement une optimisation du temps de compilation si vous utilisez un nombre constant (c&#39;est-à-dire pas une variable) alors le compilateur retournera les bits automatiquement pour vous. Prenez cette déclaration où nous voulons effacer les bits 1 et 3 à nouveau: <br><br><p class="code">a = a &amp; ~5;<br><span class="notranslate"></span></p><br> Cela se résumera à &quot;a &amp; 11111111111111111111111111111010&quot;. Cela rend la vie assez simple en termes de compensation des drapeaux. <br><br> Le dernier opérateur que nous voulons regarder est EOR (OU Exclusif, parfois appelé XOR), cet opérateur retourne les bits définis dans les <i>deux</i> valeurs. Voici la table de vérité EOR: <br><br><p class="code">0 ^ 0 = 0<br>
0 ^ 1 = 1<br>
1 ^ 0 = 1<br>
1 ^ 1 = 0<br><span class="notranslate"></span></p><br> C&#39;est un curieux, mais incroyablement utile. Par exemple, disons que nous voulons un compteur qui compte simplement de 0 à 1 et revient à 0 (basculant entre 0 et 1), nous pourrions en ajouter un et faire un IF pour voir s&#39;il est à 2, puis le réinitialiser à 1. Ou... nous pourrions ajouter 1 et ensuite ET avec 1 (depuis 01 + 01 = 10, et 10 &amp; 01 = 0) ou nous pouvons le faire: <br><br><p class="code">a = a ^ 1;<br><span class="notranslate"></span></p><br> Ce que cela fait, c&#39;est la première fois à travers est 0 ^ 1 = 1, puis la deuxième fois 1 ^ 1 = 0, basculant ainsi les choses de 0 à 1. <br><br> Donc - OR (|), AND (&amp;), NOT (~) et EOR (^) permettent de manipuler les bits avec une relative facilité, nous permettant, au niveau le plus simple, de contrôler plusieurs bits à la fois. Nous pouvons évidemment utiliser ces opérations pour d&#39;autres choses lors du développement de nos jeux, comme masquer des sprites, effectuer des opérations MOD entières (en utilisant AND) ou faire de jolis compteurs en boucle. </div><br> <label class="collapse" for="three">Arithmétique binaire simple</label> <input id="three" type="checkbox"><div class="index_list"> Comment un ordinateur ajoute-t-il? Eh bien, regardons un exemple très simple 1 + 1. <br><br><p class="code">00000001<br>
00000001<br>
00000010<br><span class="notranslate"></span></p><br> Tout comme les additions normales, nous ajoutons des nombres ensemble et nous débordons dans la colonne suivante, mais contrairement à une addition décimale normale, nous pouvons seulement aller à 1, pas 9. Donc, ajouter 1 + 1 signifie que nous débordons dans 10. Alors regardons à un exemple plus complexe. <br><br><p class="code">01011011 = 91<br>
00101101 = 45<br>
10001000 = 136<br><span class="notranslate"></span></p><br> Il est évidemment plus difficile à voir ici, mais les débordements se succèdent jusqu&#39;à ce qu&#39;il n&#39;y en ait plus dans une colonne - ou 2 à quel point un débordement fait 3 et il reste là. Heureusement, vous n&#39;avez jamais à vous inquiéter à ce sujet à moins que vous vouliez ajouter de très grands nombres ensemble (comme les nombres de 2x128bit). Il convient également de noter que les ordinateurs peuvent seulement ajouter (ou soustraire, multiplier ou diviser) 2 nombres à la fois, même SIMD est basé sur 2 calculs à la fois, mais en effectuant plusieurs calculs en parallèle. Prenez 19 + 19 + 19. Être humain, nous pouvons ajouter tous les 9 ensemble, porter le 2 et puis nous allons! Mais les ordinateurs ne peuvent pas faire cela - ce qu&#39;ils <i>peuvent</i> faire est ceci: (19 + 19) + 19. Ils feront donc chaque calcul par blocs de 2. <br><br> Les calculs binaires qui nous intéressent et qui sont d&#39;une grande utilité sont la multiplication et la division. Les ordinateurs ne se multiplient que par 2, et pour en faire plus, les nombres sont séparés, puis tous les résultats sont additionnés. Prenons quelques exemples très simples en premier. 4 * 2 = 8. Maintenant, pour multiplier par 2 en binaire, nous décalons tous les bits vers la gauche de un. Comme ça: <br><br><p class="code">00000100 * 2 = 00001000 = 8<span class="notranslate"></span></p><br> Tous les bits dans ce cas ont été déplacés vers la gauche par un, le faisant passer du 3ème bit au 4ème, et en changeant la valeur de 4 à 8. Que diriez-vous d&#39;un plus grand nombre? <br><br><p class="code">101 = 01100101 * 2 = 11001010 = 202<span class="notranslate"></span></p><br> Encore une fois, tous les bits se déplacent sur un, et ce multiple de 2. Alors, que diriez-vous d&#39;un multiple de 4? Facile, nous décalons tout laissé par 2, plutôt qu&#39;un. Alors, qu&#39;en est-il de 16 ou 128? Cela nécessiterait un décalage vers la gauche de 4 bits ou 7 bits respectivement. Ceci est incroyablement utile. cela signifie que nous pouvons faire de simples multiplications en déplaçant simplement des bits. Pour ce faire, nous utilisons l&#39;opérateur SHIFT &lt;&lt;. Voici quelques exemples: <br><br><p class="code">00000001 &lt;&lt; 1 = 000000010 = 2<br>
00000001 &lt;&lt; 2 = 000000100 = 4<br>
00000001 &lt;&lt; 3 = 000001000 = 8<br>
00000001 &lt;&lt; 4 = 000010000 = 16<br>
00000001 &lt;&lt; 5 = 000100000 = 32<br>
00000001 &lt;&lt; 6 = 001000000 = 64<br>
00000001 &lt;&lt; 7 = 010000000 = 128<br>
00000001 &lt;&lt; 8 = 100000000 = 256<br><span class="notranslate"></span></p><br> Maintenant, en plus d&#39;être très utile pour les multiplications rapides / simples, il est également très utile pour définir des BIT spécifiques, sans avoir à comprendre la valeur du bit. Disons que nous voulions définir le bit 27, quel est ce nombre? (67108864 en passant!), Bien nous pouvons utiliser la syntaxe ci-dessus pour définir facilement des drapeaux comme ceci: <br><br><p class="code">A = A | (1&lt;&lt;27)<br><span class="notranslate"></span></p><br> Ok... en fait, ce serait le bit 26 de la façon dont j&#39;ai décrit les choses jusqu&#39;à présent (comme les bits ont commencé à un), mais en fait... les bits commencent au bit 0, et montent, pas au bit 1 Donc, bien qu&#39;il y ait 32 bits dans un INTEGER, les bits vont de 0 à 31, pas de 1 à 32. C&#39;est en fait très utile, car nous pouvons maintenant configurer CONSTANTS pour les nombres de bits. <br><br> Supposons que le bit 27 soit un drapeau actif et que le bit 0 soit un drapeau explose. Comment pouvons-nous définir les deux? <br><br><p class="code">ACTIVE= 27;<br>
BOOM = 0;<br>
A = A | (1&lt;&lt;ACTIVE) | (1&lt;&lt;BOOM);<br><span class="notranslate"></span></p><br> Cela peut ressembler à beaucoup de code, mais si ces nombres sont des constantes, le compilateur pré-compilera ces opérations dans une seule valeur afin que nous finissions avec ceci comme code réel. <br><br><p class="code">A = A | 13421772;<br><span class="notranslate"></span></p><br> Effacer ces bits (comme nous l&#39;avons vu ci-dessus) consiste simplement à utiliser le modificateur NOT, comme ceci: <br><br><p class="code">A = A &amp; ~((1&lt;&lt;ACTIVE) |
(1&lt;&lt;BOOM));<br><span class="notranslate"></span></p><br> Cela nous permet donc de définir et d&#39;effacer tous les bits souhaités et nous permet également de compresser massivement les structures de données. La compression des structures de données est une bonne chose, car si vous utilisez moins de mémoire, vous obtenez moins d&#39;erreurs de mémoire cache et votre code s&#39;exécute plus rapidement. En d&#39;autres termes, quoi de plus rapide, de copier 32 Mo ou de données, ou de 4 Mo? Eh bien, très clairement 4 est. Donc, si vous pouvez regrouper tous vos drapeaux dans un seul accès à la mémoire, c&#39;est bon! </div><br> <label class="collapse" for="four">Division binaire</label> <input id="four" type="checkbox"><div class="index_list"> Jetons un coup d&#39;oeil à la façon dont vous faites la division, et pourquoi cela va être si utile. Prenons un nombre simple - 64 - et divisons par 32: <br><br><p class="code">64 / 32 = 01000000 &gt;&gt; 5 = 00000010<br><span class="notranslate"></span></p><br> Donc, il vous passez le seul bit par 5 ( ce qui est le nombre de quarts de travail requis pour 32 - regardez ci - dessus), ce qui nous donne 2. Mais ce qui se passe si ici sont autres bits là - dedans? Eh bien, jetons un coup d&#39;oeil: <br><br><p class="code">68 / 32 = 01000100 &gt;&gt; 5 = 00000010<br><span class="notranslate"></span></p><br> Alors voilà. C&#39;est exactement pareil. Les bits que nous décalons sont simplement perdus. C&#39;est en fait très utile, car quand on a besoin du reste, il y a un moyen encore plus facile de l&#39;obtenir, ce que nous verrons dans un instant. Mais d&#39;abord, prenons un exemple pratique. J&#39;ai une position X et Y, et je veux obtenir la cellule de la grille dans laquelle elle tombe, où la grille a une taille de 32x32. Cette méthode permet de stocker des objets, des collisions, des drapeaux - toutes sortes de choses, et d&#39;y accéder très rapidement. Alors on y va: <br><br><p class="code">var X_index = x&gt;&gt;5;<br>
var Y_index = y&gt;&gt;5;<br>
cell_data = mygrid[# X_index,Y_index];<br><span class="notranslate"></span></p><br> C&#39;est rapide, très rapide. Cela évite la nécessité de faire une division en virgule flottante, puis un calcul floor () - qui s&#39;additionne. <br><br> Alors, et si nous voulions le reste? Peut-être que ce reste est utilisé comme une sorte d&#39;ordre ou quelque chose, quelle que soit la raison, obtenir un reste est aussi simple que de faire un ET: <br><br><p class="code">var r = x &amp; 31<br>
var X_Index = x&gt;&gt;5;<br><span class="notranslate"></span></p><br> Maintenant, les plus perspicaces parmi vous ont peut-être remarqué que nous avons utilisé les deux ici (comme c&#39;est souvent le cas), mais ce n&#39;est que quelques instructions. Mais pourquoi le 31? Eh bien, comme le bit 5 est 32, alors tous les bits ci-dessous seraient 31, et c&#39;est le reste maximum donc c&#39;est ce que nous ET avec (nous pourrions aussi utiliser ((1 &lt;&lt; 5) -1) ce qui ferait 32-1 = 31. Maintenant, si je devais faire ceci sans comprendre binaire, cela ressemblerait à ceci: <br><br><p class="code">var r = x mod 32;<br>
var X_Index = floor(x/32);<br><span class="notranslate"></span></p><br> Alors pourquoi est-ce bien pire? Eh bien, afin de diviser par 32, nous devons exécuter une division en virgule flottante - ce qui prend évidemment du temps, mais pour faire le mod 32, vous devez en faire un autre! Si nous faisions cela en assembleur, nous obtenons en réalité les deux valeurs dans une division, mais vous ne l&#39;obtenez pas dans les langages de haut niveau (enfin... pas très souvent), et vous devez donc faire tout le travail deux fois. Cela ajoute, surtout si vous faites une boucle serrée avec beaucoup de calculs comme celui-ci. Les divisions entières comme indiqué ci-dessus aident vraiment à optimiser votre jeu. </div></blockquote><p><br></p><h2> Exemples </h2><p><br></p><p> Puisqu&#39;il peut s&#39;agir d&#39;un concept assez complexe à saisir puis à appliquer à des situations de programmation réelles, vous trouverez ci-dessous une série de petits exemples pouvant être appliqués à n&#39;importe quel jeu créé avec <i><span class="notranslate">GameMaker Studio 2</span></i>. </p><blockquote> <label class="collapse" for="five">Alignement des tuiles</label> <input id="five" type="checkbox"><div class="index_list"> <i><span class="notranslate">GameMaker Studio 2</span></i> utilisent souvent la fonction <tt>place_free()</tt>, puis, lorsqu&#39;une collision est détectée, essayez de sortir lentement l&#39;objet soit en bouclant une position x ou y (ou quelque chose) tout en continuant à exécuter cette fonction, soit en utilisant le <tt>move_outside_all()</tt> fonction. <br><br> Alors, quel est le moyen le plus rapide de le faire? Eh bien, si nous utilisons des carreaux de power-of-2 appropriés, nous avons une méthode très simple et rapide. Si nous nous déplaçons correctement, et que nous sommes passés dans un bloc de collision, alors nous savons que tout est aligné sur 32, nous devons donc également aligner l&#39;image-objet sur une limite de 32 pixels - de préférence celle de gauche - est sorti de la collision. C&#39;est vraiment facile, connaissant les règles que nous avons utilisées plus haut pour obtenir le reste, et sachant comment obtenir l&#39;inverse des bits, nous pouvons simplement faire ceci: <br><br><p class="code">X = x&amp;~31;<br><span class="notranslate"></span></p><br> C&#39;est vrai, c&#39;est tout ce qu&#39;il faut pour aligner à une limite de 32 pixels. En changeant le 31 nous pouvons aligner à tout ce que nous aimons - tant que c&#39;est une puissance de 2. (Ceci est l&#39;équivalent de diviser par 32, puis en multipliant par 32, supprimant ainsi les bits inférieurs.) <br><br> Si nous voulions aligner à droite, alors nous ferions ce qui précède, mais ensuite ajouter 32 pour le déplacer dans la prochaine tuile. Simple. Tout cela rend l&#39;ensemble du code de collision plus rapide et vous permet de passer le temps CPU là où vous en avez vraiment besoin. </div><br> <label class="collapse" for="six">Clés et portes</label> <input id=
"six" type="checkbox"><div class="index_list"> Disons que vous avez un niveau avec quelques portes, et une clé pour chacun. Comment pouvez-vous facilement marquer une clé pour une clé? Normalement, vous devez simplement attribuer une identification à la clé et à la porte. Alors que faire si vous vouliez une clé pour ouvrir 2 ou 3 portes? Facile. Vous utilisez un MASQUE. La porte aurait un seul &quot;bit&quot; assigné comme si door_id = 1 (0001), un autre avec door_id = 2 (0010), door_id = 4 (0100), door_id = 8 (1000) et ainsi de suite. Si nous voulions que la clé ouvre la porte 1 et 3, alors la clé aurait le MASQUE de 5 (qui est 101 en binaire). Si nous effectuons un ET de cela, et il sort &quot;non nul&quot;, alors nous savons si la clé peut ouvrir la porte. Vous pouvez également avoir des clés qui n&#39;ont rien ouvert en ayant un MASQUE de 0. Voir le code ci-dessous pour la vérification réelle: <br><br><p class="code">if( (key_id &amp; door_id) !=0 ) { opendoor();
}<br><span class="notranslate"></span></p></div><br> <label class="collapse" for="seven">Compteurs en boucle</label> <input id="seven" type="checkbox"><div class="index_list"> Disons que nous voulons un simple compteur d&#39;animation, comptant de 0 à 15 (comme nous avons 16 images d&#39;animation), maintenant nous pouvons soit faire un incrément, puis faire un IF, ou nous pouvons utiliser notre connaissance de binaire et supprimer le SI complètement. Les IF sont lents, et si nous n&#39;en avons pas besoin, nous devrions les supprimer. <br><br><p class="code">counter = (counter+1)&amp;31;<br><span class="notranslate"></span></p><br> Puisque 16 frames est une puissance de 2 chiffres, et que 0 est inclus dans le compteur, nous pouvons réduire le nombre POW2 de 1 et l&#39;utiliser comme un MASK, et en utilisant cela nous pouvons l&#39;utiliser pour envelopper notre compteur. Si le compteur passe de 15 à 16, nous obtenons le modèle de bits 10000, et si nous avons ensuite 15 avec le modèle de bits 01111, nous obtenons 0. Cela signifie que le code ci-dessus est très utile pour l&#39;encapsulation des compteurs - tant que vous utilisez les numéros d&#39;images POW2. </div><br> <label class="collapse" for="eight">Puissance de 2 Chèque</label> <input id="eight" type="checkbox"><div class="index_list"> Et si vous vouliez vérifier si quelque chose était une puissance de 2? Eh bien, voici une petite astuce.. Cela retournera VRAI si argument0 est une puissance de 2. <br><br><p class="code">return (argument0&amp;(argument0-1))==0;<br><span class="notranslate"></span></p><br> Donc, si nous avions le numéro 51 (110011), qu&#39;est-ce que cela fait? Eh bien, nous obtenons ce... 110011 &amp; 110010, ce qui nous laisse évidemment avec FALSE, car il y a beaucoup de &quot;bits&quot; à gauche après l&#39;ET. Si nous avions 64 1000000, alors cela devient ce... 1000000 &amp; 0111111 qui nous laisse 0, donc c&#39;est TRUE. </div><br> <label class="collapse" for="nine">Alignement de l&#39;index</label> <input id="nine" type="checkbox"><div class="index_list"> Voici un petit morceau de code à aligner à la puissance de 2 chiffres. (1,2,4,8,16 et ainsi de suite). Cela peut être très utile pour l&#39;allocation de mémoire ou pour s&#39;assurer que vous écrivez des données aux limites appropriées.Dans cet exemple, argument0 doit être aligné sur argument1 octets, où argument1 est une puissance de 2 nombre. Ce petit script arrondit à la limite suivante du nombre désiré. <br><br><p class="code">return (argument0 + (argument1-1)) &amp;
~(argument1-1);<br><span class="notranslate"></span></p><br></div></blockquote><p><br></p></div><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> Retour: <a href="index.html">Informations supplémentaires Index</a> </div><div style="float:right"> Next: <a href="errors.html">Erreurs du compilateur</a> </div></div></div><h5> © Copyright <span class="notranslate">YoYo Games Ltd.</span> 2017 Tous droits réservés </h5>
<script type="text/javascript">
   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');   ga('create', 'UA-2711665-14', 'auto');   ga('send', 'pageview'); 
</script>
</div>

<script type="text/JavaScript">
var fe = FindFrame("toc", top);
if ((fe != null) && (chmtop.c2wtopf.jstree != null)) {
  if (chmtop.c2wtopf.FITEMS[chmtop.c2wtopf.pagenum] != chmtop.c2wtopf.pageid)
    chmtop.c2wtopf.jstree.OpenTreeNode("source/" + chmtop.c2wtopf.pageid);
}
</script>
</body>
</html>
