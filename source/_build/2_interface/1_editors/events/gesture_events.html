<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="keywords" content="online documentation, web online help, web help, chm2web" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="generator" content="chm2web Pro 2.85 (unicode)" />
<title>The Gesture Events</title>
<meta http-equiv="X-UA-Compatible" content="IE=9">

<link rel="stylesheet" href="../../../../../files/helpindex.css"
type="text/css">
<link rel="stylesheet" href="../../../../../default.css" type=
"text/css">

<script type="text/JavaScript" src="../../../../../files/supply.js"></script>
<script type="text/JavaScript">
chmtop.c2wtopf.pageid = "_build/2_interface/1_editors/events/gesture_events.html";
</script>

</head>
<body><script type="text/JavaScript"> 
if (window.name != "content") 
  document.write(" <table width=\"100%\" bgcolor=\"#e1e1e1\"cellspacing=\"2\" cellpadding=\"0\" style=\"border-collapse: collapse; font-family: sans-serif; font-size: 14px; color: #000000; text-decoration: none;  \"> <tr> <td align=\"center\" style=\"border-bottom: 2px solid gray\" > <br>&nbsp;Click <a href=\"../../../../../index.html?page=source%2F_build%2F2_interface%2F1_editors%2Fevents%2Fgesture_events.html\">here</a> to show toolbars of the Web Online Help System: <a href=\"../../../../../index.html?page=source%2F_build%2F2_interface%2F1_editors%2Fevents%2Fgesture_events.html\">show toolbars</a><br>&nbsp;</td></tr></table><br> "); 
</script>
<!-- !chm2web! --><script type="text/JavaScript">
 if( typeof(chmtop.helpStyle) != 'undefined' ) { var linkNodes = document.getElementsByTagName("link");  for( var i=0; i < linkNodes.length; ++i ) { var link = linkNodes[i];    if( link.href.endsWith("default.css")) {    var style = link.href.replace("default.css", chmtop.helpStyle); document.write('<link id="newstyleLink" rel="stylesheet" href=' + style + ' type="text/css">');    break; } } } 
</script><h2> Les événements du geste </h2><div class="body-scroll"><p><br></p><img class="center" src="images/editor_objects_gesture.png" alt="Evénements Gesture de l&#39;éditeur d&#39;objets"><p> Les événements de la catégorie <b>Gesture Event</b> sont déclenchés lorsque <i><span class="notranslate">GameMaker Studio 2</span></i> détecte un «geste» de la souris ou un événement tactile (alors que ces événements gestuels sont conçus spécifiquement pour une utilisation mobile, ils peuvent également être utilisés sur d&#39;autres cibles pour détecter la souris, bien qu&#39;ils ne détectent pas de multiples touches dans ce cas). Le but du système gestuel est d&#39;essayer de reconnaître les entrées à un niveau plus élevé que les fonctions directes de lecture tactile de la souris, et il est conçu pour simplifier la mise en œuvre des entrées couramment utilisées sur les dispositifs tactiles. </p><div class="note"> <b>REMARQUE:</b> ces événements <b>ne</b> seront <b>pas déclenchés sur la</b> plate-forme <b>HTML5</b>. Si vous recherchez des gestes sur cette cible, vous devez utiliser les <a href=
"../../../3_scripting/4_gml_reference/controls/device%20input/index.html">fonctions de</a> l&#39; <a href=
"../../../3_scripting/4_gml_reference/controls/device%20input/index.html">appareil</a>. </div><p><br> Vous pouvez choisir de détecter des gestes d&#39; <b>instance</b> ou <b>des</b> gestes <b>globaux</b>, où les événements gestuels d&#39;instance ne seront déclenchés que lorsque le premier contact / clic est sur une instance dans la pièce. Notez que l&#39;instance <i>doit</i> avoir un masque de collision valide (voir les sections <a href="../../1_editors/sprites.html">Éditeur de sprite - Masque de collision</a> et <a href="../../1_editors/objects.html">Éditeur d&#39;objet - Masque de collision</a> pour plus de détails) pour que cet événement soit déclenché. Les événements globaux, cependant, seront déclenchés en touchant / cliquant n&#39;importe où dans la salle de jeu, et pour toutes les instances qui ont l&#39;événement. </p><p> Lorsqu&#39;un événement gestuel est reconnu, il déclenche un ou plusieurs des sous-événements disponibles et le sous-événement déclenché dépend du type de geste détecté. Dans tous les cas, cependant, une <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html">carte DS</a> sera générée pour vous et stockée dans la variable intégrée <tt><b>event_data</b></tt>. Les clés disponibles dépendent du type d&#39;événement créé et sont présentés dans chacune des sous-sections ci-dessous. </p><div class="note"> <b>NOTE:</b> La variable <tt>event_data</tt> n&#39;est <b>valable que pour ces événements</b>, <tt>ds_map</tt> qu&#39;il pointe vers est automatiquement créé au début de l&#39;événement, puis détruit à nouveau à la fin, avec cette variable étant réinitialisée à une valeur de -1 à tous les autres moments. </div><p><br> Il est à noter que si vous avez plusieurs occurrences sous la position touchée et qu&#39;elles ont toutes un événement gestuel, elles se déclencheront toutes, pas seulement l&#39;instance &quot;la plus haute&quot;. Notez également que lorsque vous utilisez plusieurs vues et que vous faites glisser une occurrence, les valeurs renvoyées seront basées sur la vue dans laquelle vous étiez lorsque le premier contact / clic a été reçu. Cela est vrai pour tous les événements suivants de cette occurrence. Ainsi, en touchant et en faisant glisser une occurrence dans une vue, puis en relâchant la touche dans une autre vue, vous obtiendrez des valeurs relatives à la vue initiale où le geste a été détecté pour la première fois. </p><p><br></p><blockquote><a name="Gesture_Event_Single" id=
"Gesture_Event_Single"></a><div style="float:left"><img style=
"vertical-align:middle;padding-top:6px;padding-left:10px;" src=
"images/icon_tap.png"></div> <label class="collapse" for="one">Robinet, <img style=
"vertical-align:middle;padding-top:0px;padding-left:5px;" src=
"images/icon_drag.png"> Faites glisser et <img style=
"vertical-align:middle;padding-top:0px;padding-left:5px;" src=
"images/icon_flick.png"> Flick Events</label> <input id="one" type=
"checkbox"><div class="index_list"><p> Les événements &quot;Tap&quot;, &quot;Drag&quot; et &quot;Flick&quot; sont tous basés sur une simple pression ou un clic de souris sur l&#39;écran et le <tt>event_data</tt> DS Map contiendra les clés suivantes: </p><div class="compat"><table><tr><th> Clé </th><th> Valeur Description </th></tr><tr><td> <span class="notranslate">&quot;gesture&quot;</span> </td> <td><br> C&#39;est une valeur d&#39;ID <i>unique</i> au geste en cours. Cela vous permet de relier les différentes parties des gestes en plusieurs parties (telles que le début, le glisser et la fin). <br><br></td></tr><tr class="alt"><td> <span class="notranslate">&quot;touch&quot;</span> </td> <td><br> C&#39;est l&#39;index du toucher qui est utilisé pour le geste. En général, cela commence à 0 et augmente pour chaque doigt maintenu, puis revient à 0 lorsque tous les doigts sont retirés, mais si l&#39;utilisateur touche l&#39;écran n&#39;importe où ailleurs lorsque cet événement est déclenché par un autre toucher, alors la valeur sera supérieur à 0. <br><br></td></tr><tr><td> <span class="notranslate">&quot;posX&quot;</span> </td> <td><br> C&#39;est la position X du room-space. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">&quot;posY&quot;</span> </td> <td><br> C&#39;est la position Y de l&#39;espace de la pièce. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">&quot;rawposX&quot;</span> </td> <td><br> Ceci est la position <i>brute</i> X de l&#39;espace de la fenêtre (équivalent à l&#39;obtention de la position de la souris en utilisant <a href=
"../../../3_scripting/4_gml_reference/controls/device%20input/device_mouse_raw_x.html"><tt>device_mouse_raw_x()</tt></a> ). <br><br></td></tr><tr><td> <span class="notranslate">&quot;rawposY&quot;</span> </td> <td><br> Ceci est la position <i>brute</i> Y de l&#39;espace de la fenêtre du toucher (équivalent à l&#39;obtention de la position de la souris en utilisant <a href=
"../../../3_scripting/4_gml_reference/controls/device%20input/device_mouse_raw_y.html"><tt>device_mouse_raw_y()</tt></a> ). <br><br></td></tr><tr class="alt"><td> <span class="notranslate">&quot;guiposX&quot;</span> </td> <td><br> Ceci est la position gui-space X du toucher (équivalent à l&#39;obtention de la position de la souris en utilisant <a href=
"../../../3_scripting/4_gml_reference/controls/device%20input/device_mouse_x_to_gui.html"><tt>device_mouse_x_to_gui()</tt></a> ). <br><br></td></tr><tr><td> <span class="notranslate">&quot;guiposY&quot;</span> </td> <td><br> Ceci est la position gui-space Y du toucher (équivalent à l&#39;obtention de la position de la souris en utilisant <a href=
"../../../3_scripting/4_gml_reference/controls/device%20input/device_mouse_y_to_gui.html"><tt>device_mouse_y_to_gui()</tt></a> ). <br><br></td></tr><tr class="alt"><td> <span class="notranslate">&quot;diffX&quot;</span> </td> <td><br> C&#39;est la différence entre l&#39;espace et la pièce X entre la position du contact en cours et la position du dernier contact dans ce geste. <br><br></td></tr><tr><td> <span class="notranslate">&quot;diffY&quot;</span> </td> <td><br> C&#39;est la différence Y entre la position du toucher actuel et la position du dernier contact dans ce geste. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">&quot;rawdiffX&quot;</span> </td> <td><br> C&#39;est la différence brute entre la position du toucher actuel et la position du dernier contact dans ce geste. <br><br></td></tr><tr><td> <span class="notranslate">&quot;rawdiffY&quot;</span> </td> <td><br> C&#39;est la différence Y brut entre la position du toucher actuel et la position du dernier contact dans ce geste. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">&quot;guidiffX&quot;</span> </td> <td><br> C&#39;est la différence gui-espace X entre la position du toucher actuel et la position du dernier contact dans ce geste. <br><br></td></tr><tr><td> <span class="notranslate">&quot;guidiffY&quot;</span> </td> <td><br> C&#39;est la différence entre la position du toucher actuel et la position du dernier contact dans ce geste. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">&quot;isflick&quot;</span> </td> <td><br> <b>Uniquement disponible dans l&#39;événement Drag End</b>. Ceci est mis à 1 si la fin de la traînée est détectée comme un film, ce qui signifie que vous n&#39;avez pas besoin d&#39;un <b>événement Flick</b> séparé si vous gérez le glisser de toute façon. <br><br></td></tr></table></div><blockquote><a name="gesture_tap" id="gesture_tap"></a> <label class="collapse" for="a">Robinet</label> <input id="a" type=
"checkbox"><div class="index_list"><p> L&#39;événement <b>Tap</b> sera déclenché lorsqu&#39;une occurrence a été touchée ou cliquée ou, s&#39;il s&#39;agit d&#39;un événement global, lorsque le jeu enregistre une touche ou un clic n&#39;importe où dans la pièce. Un tap est considéré comme un toucher rapide et un relâchement, et si le toucher dure trop longtemps, il sera considéré comme un Drag (et déclenchera les événements Drag gesture au lieu de l&#39;événement Tap). Cet événement va générer un <tt>event_data</tt> DS carte que vous pouvez ensuite utiliser pour obtenir des informations sur l&#39;événement. Par exemple: </p><h3> Créer un évènement </h3><p class="code">x_goto = x;<br>
y_goto = y;<br><span class="notranslate"></span></p><h3> Appuyez sur événement </h3><p class="code">x_goto = event_data[? "posX"];<br>
y_goto = event_data[? "posY"];<br><span class="notranslate"></span></p><h3> Étape </h3><p class="code">var _pd = point_distance(x, y, x_goto, y_goto);<br>
move_towards_point(x_goto, y_goto, clamp(_pd, 0, 5);<br><span class="notranslate"></span></p><p><br> Le code ci-dessus détectera un tap sur l&#39;écran, puis obtiendra la position du tap pour déplacer l&#39;instance vers cette position. Notez que si vous voulez avoir un temps de détection de prise plus long ou plus court, vous pouvez le définir avec la fonction <a href=
"../../../3_scripting/4_gml_reference/controls/gesture%20input/gesture_drag_time.html"><tt>gesture_drag_time</tt></a>. Cela définit le temps entre la détection initiale et le robinet devenant un glissement, alors réglez-le sur une valeur plus élevée pour que la détection du robinet soit plus longue ou une valeur plus faible pour la raccourcir (la valeur est en secondes et 0,16 par défaut). </p></div><br><a name="gesture_double_tap" id="gesture_double_tap"></a> <label class="collapse" for="b">Tapez deux fois</label> <input id="b"
type="checkbox"><div class="index_list"><p> L&#39;événement <b>Double Tap</b> sera déclenché lorsqu&#39;une instance a été touchée ou cliquée deux fois de suite (ou - s&#39;il s&#39;agit d&#39;un événement global - lorsque le jeu enregistre deux touches rapides ou des clics n&#39;importe où dans la pièce). Un double appui est considéré comme deux touches et relâchements rapides, mais si l&#39;une des touches dure trop longtemps, elle sera considérée comme un Drag (et déclenchera les événements Drag gesture au lieu de l&#39;événement Double Tap). Cet événement va générer un <tt>event_data</tt> DS carte que vous pouvez ensuite utiliser pour obtenir des informations sur l&#39;événement. Par exemple: </p><h3> Créer un évènement </h3><p class="code">x_goto = x;<br>
y_goto = y;<br><span class="notranslate"></span></p><h3> Double Tap Event </h3><p class="code">instance_destroy();<br><span class="notranslate"></span></p><p><br> Le code ci-dessus détecte simplement un double appui puis détruit l&#39;instance. Notez que vous pouvez régler l&#39;intervalle entre les prises pour déclencher un double appui en utilisant la fonction <a href=
"../../../3_scripting/4_gml_reference/controls/gesture%20input/gesture_double_tap_time.html"><tt>gesture_double_tap_time</tt></a> (qui a une valeur par défaut - en secondes - de 0.16) et vous pouvez également définir la distance pour la détection entre les robinets avec la fonction <a href=
"../../../3_scripting/4_gml_reference/controls/gesture%20input/gesture_double_tap_distance.html"><tt>gesture_double_tap_distance</tt></a> (Si un second tap est détecté en dehors de cette distance, il sera considéré comme un événement de tapement régulier). </p></div><br><a name="gesture_drag_start" id="gesture_drag_start"></a> <label class="collapse" for="c">Faire glisser</label> <input id="c"
type="checkbox"><div class="index_list"><p> L&#39;événement <b>Drag Start</b> sera déclenché lorsque l&#39;utilisateur maintient un contact ou un clic sans le relâcher. Il sera déclenché une fois quand un temps défini est passé après la touche initiale, qui est de 0,16 secondes par défaut (bien que vous puissiez définir cette valeur sur n&#39;importe quelle autre valeur en secondes en utilisant la fonction <a href=
"../../../3_scripting/4_gml_reference/controls/gesture%20input/gesture_drag_time.html"><tt>gesture_drag_time</tt></a> ). Une fois que cet événement a été déclenché, et tant que l&#39;utilisateur maintient un toucher / un clic enfoncé, l&#39;événement de <b>glissement</b> sera déclenché à chaque étape jusqu&#39;à ce que le contact / clic ait été libéré. Cet événement va générer un <tt>event_data</tt> DS carte que vous pouvez ensuite utiliser pour obtenir des informations sur l&#39;événement. Par exemple: </p><h3> Créer un évènement </h3><p class="code">drag_offsetX = 0;<br>
drag_offsetY = 0;<br><span class="notranslate"></span></p><h3> Faites glisser l&#39;événement de départ </h3><p class="code">drag_offsetX = x - event_data[?"posX"];<br>
drag_offsetY = y - event_data[?"posY"];<br><span class="notranslate"></span></p><p><br> Le code ci-dessus utilise l&#39;événement Drag Start pour obtenir la position du bouton tactile et l&#39;utiliser pour définir une valeur de décalage pour les axes x et y. Cela peut ensuite être utilisé lorsque vous faites glisser l&#39;instance pour vous assurer qu&#39;elle ne &quot;saute&quot; pas à la position à laquelle le contact / clic a été détecté (voir l&#39;événement <b>Dragging</b> ci-dessous pour une continuation de cet exemple). </p></div><br><a name="gesture_dragging" id="gesture_dragging"></a> <label class=
"collapse" for="d">Faire glisser</label> <input id="d" type="checkbox"><div class="index_list"><p> L&#39;événement <b>Dragging</b> est déclenché après l&#39;événement <b>Drag Start</b> et sera déclenché pour chaque étape que l&#39;utilisateur maintient le contact / clic sur l&#39;instance (ou l&#39;écran, s&#39;il s&#39;agit d&#39;un événement global) et se déplace plus que le seuil de déplacement défini. Cette distance est de 0,1 pouce par défaut mais peut être réglée en utilisant la fonction <a href=
"../../../3_scripting/4_gml_reference/controls/gesture%20input/gesture_drag_distance.html"><tt>gesture_drag_distance</tt></a>. S&#39;il n&#39;y a pas de mouvement ou si le mouvement est sous le seuil défini, l&#39;événement ne sera pas déclenché. Cet événement va générer un <tt>event_data</tt> DS carte que vous pouvez ensuite utiliser pour obtenir des informations sur l&#39;événement. Par exemple: </p><h3> Créer un évènement </h3><p class="code">drag_offsetX = 0;<br>
drag_offsetY = 0;<br><span class="notranslate"></span></p><h3> Faites glisser l&#39;événement de départ </h3><p class="code">drag_offsetX = x - event_data[?"posX"];<br>
drag_offsetY = y - event_data[?"posY"];<br><span class="notranslate"></span></p><h3> Faire glisser l&#39;événement </h3><p class="code">x = event_data[?"posX"] + drag_offsetX;<br>
y = event_data[?"posY"] + drag_offsetY;<br><span class="notranslate"></span></p><p><br> L&#39;exemple de code ci-dessus utilise les variables de décalage définies dans l&#39;événement <b>Drag Start</b> pour déplacer l&#39;instance lorsque l&#39;événement <b>Dragging</b> est déclenché. </p></div><br><a name="gesture_drag_end" id="gesture_drag_end"></a> <label class=
"collapse" for="e">Faire glisser</label> <input id="e" type="checkbox"><div class="index_list"><p> L&#39;événement <b>Drag End</b> est déclenché lorsque l&#39;utilisateur relâche le bouton tactile / cliquer sur l&#39;instance (ou l&#39;écran si l&#39;événement est global). Cet événement va générer un <tt>event_data</tt> Carte DS que vous pouvez ensuite utiliser pour obtenir des informations sur l&#39;événement, mais dans ce cas, la carte aura une clé supplémentaire: &quot; <tt>isflick</tt> &quot;Flick est calculé comme la <i>distance par seconde sur</i> laquelle la traînée s&#39;est produite, et la valeur pour le&quot; <tt>isflick</tt> &quot;La clé sera <tt>true</tt> si elle est supérieure à la distance définie par seconde, ou <tt>false</tt> autrement. Notez que la valeur par défaut est 2 pouces par seconde, mais vous pouvez le définir à une autre valeur en utilisant la fonction <a href=
"../../../3_scripting/4_gml_reference/controls/gesture%20input/gesture_flick_speed.html"><tt>gesture_flick_speed</tt></a>. Notez également qu&#39;il existe un événement <b>Flick</b> dédié qui sera également déclenché si le &quot; <tt>isflick</tt> &quot;variable est <tt>true</tt>. Un exemple d&#39;utilisation serait: </p><h3> Créer un évènement </h3><p class="code">flickVelX = 0.0;<br>
flickVelY = 0.0;<br><span class="notranslate"></span></p><h3> Faire glisser l&#39;événement de fin </h3><p class="code">isFlick = event_data[?"isflick"];<br>
if (isFlick)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;flickVelX = event_data[?"diffX"];<br>
&nbsp;&nbsp;&nbsp;&nbsp;flickVelY = event_data[?"diffY"];<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
else<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;flickVelX = 0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;flickVelY = 0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><h3> Étape </h3><p class="code">x += flickVelX;<br>
y += flickVelY;<br>
flickVelX *= 0.7;<br>
flickVelY *= 0.7;<br><span class="notranslate"></span></p><p><br> Le code ci-dessus obtient simplement la différence entre la position x et y du dernier événement <b>Dragging</b> et l&#39;événement <b>Drag End</b> actuel, et si le mouvement a été supérieur au seuil de flick, il définit certaines variables utilisées pour déplacer l&#39;instance dans le événement d&#39;étape. </p></div><br><a name="gesture_flick" id="gesture_flick"></a> <label class=
"collapse" for="f">Feuilleter</label> <input id="f" type="checkbox"><div class="index_list"><p> L&#39;événement <b>Flick</b> est uniquement déclenché lorsqu&#39;un contact / clic a été maintenu, déplacé puis relâché et que la distance entre la dernière position de glissement et la position de libération est supérieure à 2 pouces par seconde (paramètre par défaut, bien que cela puisse être modifié en utilisant la fonction <a href=
"../../../3_scripting/4_gml_reference/controls/gesture%20input/gesture_flick_speed.html"><tt>gesture_flick_speed</tt></a> ). Cet événement va générer un <tt>event_data</tt> DS carte que vous pouvez ensuite utiliser pour obtenir des informations sur l&#39;événement. Par exemple: </p><h3> Créer un évènement </h3><p class="code">flickVelX = 0.0;<br>
flickVelY = 0.0;<br><span class="notranslate"></span></p><h3> Evénement Flick </h3><p class="code">flickVelX = event_data[?"diffX"];<br>
flickVelY = event_data[?"diffY"];<br><span class="notranslate"></span></p><h3> Étape </h3><p class="code">x += flickVelX;<br>
y += flickVelY;<br>
flickVelX *= 0.7;<br>
flickVelY *= 0.7;<br><span class="notranslate"></span></p><p><br> Le code ci-dessus obtient simplement la différence en position x et y du dernier événement <b>Dragging</b> et l&#39;événement <b>Flick en</b> cours, et si le mouvement a été supérieur au seuil de flick, il définit certaines variables utilisées pour déplacer l&#39;instance dans l&#39;étape un événement. </p></div></blockquote></div><br><a name="Gesture_Event_Pinch" id="Gesture_Event_Pinch"></a><div style="float:left"><img style=
"vertical-align:middle;padding-top:6px;padding-left:10px;" src=
"images/icon_pinch.png"></div> <label class="collapse" for="two">Evénements Pinch</label> <input id=
"two" type="checkbox"><div class="index_list"><p> Les événements &quot;Pinch&quot; sont basés sur deux touches à l&#39;écran des appareils qui sont reconnues à la fois, où l&#39;un (ou les deux) ont bougé sur plus d&#39;une certaine distance. L&#39;angle de mouvement des touches avec le mouvement de chaque touche est ce qui déterminera la détection d&#39;un événement Pincer ou Pivoter, où (dans le cas du type <b>Pincement</b> ): </p><ul><li> Si l&#39;une des touches ne bouge pas, l&#39;autre doit se déplacer <i>vers</i> elle ou <i>s&#39;éloigner</i> dans un angle de seuil (qui peut être réglé en utilisant les fonctions <a href=
"../../../3_scripting/4_gml_reference/controls/gesture%20input/gesture_pinch_angle_towards.html"><tt>gesture_pinch_angle_towards()</tt></a> et <a href=
"../../../3_scripting/4_gml_reference/controls/gesture%20input/gesture_pinch_angle_away.html"><tt>- gesture_pinch_angle_away()</tt></a> ). </li><li> Si les deux touches bougent, leurs vitesses doivent être dans des directions approximativement opposées et la même vérification du seuil angulaire est également effectuée pour s&#39;assurer que les touches bougent dans un alignement approximatif. </li></ul><p> Lorsque deux touches et un mouvement sont détectés avec les critères ci-dessus, un événement de pincement sera déclenché, et dans chacun des événements, le <tt>event_data</tt> DS Map sera rempli avec les clés suivantes: </p><div class="compat"><table><tr><th> Clé </th><th> Valeur Description </th></tr><tr><td> <span class="notranslate">&quot;gesture&quot;</span> </td> <td><br> C&#39;est une valeur d&#39;ID <i>unique</i> au geste en cours. Cela vous permet de relier les différentes parties des gestes en plusieurs parties (telles que le début, le glisser et la fin). <br><br></td></tr><tr class="alt"><td> <span class="notranslate">&quot;touch1&quot;</span> </td> <td><br> C&#39;est l&#39;index du premier contact qui est utilisé dans le cadre du geste de pincement. En général, ce sera 0, mais si l&#39;utilisateur touche l&#39;écran n&#39;importe où ailleurs lorsque cet événement est déclenché par une autre touche, alors la valeur sera supérieure à 0. <br><br></td></tr><tr><td> <span class="notranslate">&quot;touch2&quot;</span> </td> <td><br> C&#39;est l&#39;index de la deuxième touche qui est utilisée dans le cadre du geste de pincement. En général, cela sera 1 de plus que la valeur de touch1, mais peut être une autre valeur en fonction du nombre de touches détectées ailleurs. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">&quot;posX1&quot;</span> </td> <td><br> C&#39;est la position X du premier contact. <br><br></td></tr><tr><td> <span class="notranslate">&quot;posY1&quot;</span> </td> <td><br> C&#39;est la position Y dans l&#39;espace de la pièce du premier contact. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">&quot;rawposX1&quot;</span> </td> <td><br> Ceci est la position <i>brute</i> de l&#39;espace de fenêtre X du premier contact (ce qui équivaut à obtenir la position de la souris en utilisant <a href=
"../../../3_scripting/4_gml_reference/controls/device%20input/device_mouse_raw_x.html"><tt>device_mouse_raw_x()</tt></a> ). <br><br></td></tr><tr><td> <span class="notranslate">&quot;rawposY1&quot;</span> </td> <td><br> Ceci est la position <i>brute</i> de l&#39;espace de fenêtre du premier contact (équivalent à l&#39;obtention de la position de la souris en utilisant <a href=
"../../../3_scripting/4_gml_reference/controls/device%20input/device_mouse_raw_y.html"><tt>device_mouse_raw_y()</tt></a> ). <br><br></td></tr><tr class="alt"><td> <span class="notranslate">&quot;guiposX1&quot;</span> </td> <td><br> Ceci est la position gui-espace X du premier contact (équivalent à l&#39;obtention de la position de la souris en utilisant <a href=
"../../../3_scripting/4_gml_reference/controls/device%20input/device_mouse_x_to_gui.html"><tt>device_mouse_x_to_gui()</tt></a> ). <br><br></td></tr><tr><td> <span class="notranslate">&quot;guiposY1&quot;</span> </td> <td><br> Ceci est la position gui-space Y du second contact (équivalent à l&#39;obtention de la position de la souris en utilisant <a href=
"../../../3_scripting/4_gml_reference/controls/device%20input/device_mouse_y_to_gui.html"><tt>device_mouse_y_to_gui()</tt></a> ). <br><br></td></tr><tr class="alt"><td> <span class="notranslate">&quot;posX2&quot;</span> </td> <td><br> C&#39;est la position X de l&#39;espace-pièce du second contact. <br><br></td></tr><tr><td> <span class="notranslate">&quot;posY2&quot;</span> </td> <td><br> C&#39;est la position Y dans l&#39;espace de la pièce du second contact. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">&quot;rawposX2&quot;</span> </td> <td><br> Ceci est la position <i>brute</i> de l&#39;espace de fenêtre X du premier contact. <br><br></td></tr><tr><td> <span class="notranslate">&quot;rawposY2&quot;</span> </td> <td><br> C&#39;est la position <i>brute</i> Y de l&#39;espace fenêtre du second contact. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">&quot;guiposX2&quot;</span> </td> <td><br> C&#39;est la position gui-espace X du second contact. <br><br></td></tr><tr><td> <span class="notranslate">&quot;guiposY2&quot;</span> </td> <td><br> C&#39;est la position gui-espace Y du second contact. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">&quot;midpointX&quot;</span> </td> <td><br> La position X du point médian entre les deux touches dans l&#39;espace de la pièce. <br><br></td></tr><tr><td> <span class="notranslate">&quot;midpointY&quot;</span> </td> <td><br> La position Y du point médian entre les deux touches dans l&#39;espace de la pièce. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">&quot;rawmidpointX&quot;</span> </td> <td><br> Ceci est la position X de la fenêtre brute du point médian. <br><br></td></tr><tr><td> <span class="notranslate">&quot;rawmidpointY&quot;</span> </td> <td><br> C&#39;est la position brute Y de l&#39;espace de fenêtre du point médian. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">&quot;guimidpointX&quot;</span> </td> <td><br> C&#39;est la position gui-espace X du point médian. <br><br></td></tr><tr><td> <span class="notranslate">&quot;guimidpointY&quot;</span> </td> <td><br> C&#39;est la position gui-espace Y du point médian. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">&quot;relativescale&quot;</span> </td> <td><br> Il s&#39;agit d&#39;une différence d&#39;échelle par rapport au dernier événement de ce geste (donc pour les événements <b>Pinch In</b>, il sera toujours inférieur à 1.0, alors que pour les événements <b>Pinch Out</b>, il sera toujours supérieur à 1.0) <br><br></td></tr><tr><td> <span class="notranslate">&quot;absolutescale&quot;</span> </td> <td><br> C&#39;est l&#39;échelle comparée à l&#39;endroit où les doigts se trouvaient lorsque le geste a commencé (donc si la distance entre les doigts a été réduite de moitié, cela sera de 0,5 alors que si la distance a doublé, elle sera de 2,0). <br><br></td></tr></table></div><blockquote><a name="gesture_pinch_start" id=
"gesture_pinch_start"></a> <label class="collapse" for="g">Pincer le départ</label> <input id="g" type="checkbox"><div class="index_list"><p> L&#39;événement <b>Pinch Start</b> sera déclenché lorsqu&#39;une instance (ou l&#39;écran si l&#39;événement est global) a été touchée par deux «doigts» (et le toucher est maintenu), puis un ou les deux «doigts» sont déplacés. Si les touches s&#39;éloignent l&#39;une de l&#39;autre ou l&#39;une de l&#39;autre plus que la distance de vérification minimale (qui est de 0,1 pouce par défaut, mais il peut être réglé en utilisant la fonction <a href="../../../3_scripting/4_gml_reference/controls/gesture%20input/gesture_pinch_distance.html"><tt>gesture_pinch_distance</tt></a> ), et l&#39;angle entre eux est dans la valeur définie (par défaut, 45 °, mais peut être réglé en utilisant <a href=
"../../../3_scripting/4_gml_reference/controls/gesture%20input/gesture_pinch_angle_towards.html"><tt>gesture_pinch_angle_towards()</tt></a> et <a href=
"../../../3_scripting/4_gml_reference/controls/gesture%20input/gesture_pinch_angle_away.html"><tt>- gesture_pinch_angle_away()</tt></a> ), un événement <b>Pinch Start</b> sera déclenché. Dans cet événement, vous pouvez définir des variables ou stocker la date de position pour une utilisation ultérieure. Par exemple: </p><h3> Pinch Start Événement </h3><p class="code">pinching = true;<br>
pinch_x = event_data[? "midpointX"]; pinch_y = event_data[?
"midpointY"];<span class="notranslate"></span></p><p><br> Le code ci-dessus détectera un pincement et mémorisera la position du point médian pour cette pincée. </p></div><br><a name="gesture_pinch_in_out" id="gesture_pinch_in_out"></a> <label class="collapse" for="h">Pincer / pincer</label> <input id="h" type="checkbox"><div class="index_list"><p> <b>Pinch In</b> et <b>Pincer</b> événements seront déclenchés à chaque étape que la distance entre les deux touches qui composent les changements de pincement sur le seuil minimal (fixé à +/- 0,1 pouces par défaut, mais vous pouvez le modifier en utilisant la fonction <a href=
"../../../3_scripting/4_gml_reference/controls/gesture%20input/gesture_pinch_distance.html"><tt>gesture_pinch_distance</tt></a> ). S&#39;il n&#39;y a pas de mouvement de pincement, ces événements ne se déclencheront pas. Ces événements généreront un <tt>event_data</tt> DS carte que vous pouvez ensuite utiliser pour obtenir des informations sur l&#39;événement. Par exemple: </p><h3> Événement Global Pinch In / Pinch Out </h3><p class="code">var _scale = event_data[? "relativescale"];<br>
var _w = camera_get_view_width(view_camera[0]);<br>
var _h = camera_get_view_height(view_camera[0]);<br>
var _x = camera_get_view_x(view_camera[0]) + (_w / 2);<br>
var _y = camera_get_view_y(view_camera[0]) + (_h / 2);<br>
<br>
_w *= _scale;<br>
_h = _w * (room_height / room_width);<br>
_x -= _w / 2;<br>
_y -= _h / 2;<br>
<br>
camera_set_view_pos(view_camera[0], _x, _y);<br>
camera_set_view_size(view_camera[0], _w, _h);<br><span class="notranslate"></span></p><p><br> Le code ci-dessus met à l&#39;échelle la vue en fonction de l&#39;échelle relative des pincements. </p></div><br><a name="gesture_pinch_end" id="gesture_pinch_end"></a> <label class="collapse" for="i">Pinch End</label> <input id="i"
type="checkbox"><div class="index_list"><p> L&#39;événement <b>Pinch End</b> sera déclenché lorsque l&#39;utilisateur relâchera une (ou les deux) touches de l&#39;appareil. Ces événements généreront une <tt>event_data</tt> DS carte que vous pouvez ensuite utiliser pour obtenir des informations sur l&#39;événement. Par exemple: </p><h3> Pinch End Event </h3><p class="code">var _pinchx = event_data[? "midpointX"]; var
_pinchy = event_data[? "midpointY"]; var _w =
camera_get_view_width(view_camera[0]);<br>
var _h = camera_get_view_height(view_camera[0]);<br>
var _x = _pinchx - (_w / 2);<br>
var _y = _pinchy - (_h / 2);<br>
<br>
camera_set_view_pos(view_camera[0], _x, _y);<br><span class="notranslate"></span></p><p><br> Le code ci-dessus définira la position de la vue à centrer sur le milieu des deux touches qui composent le pincement lorsque les touches sont relâchées. </p></div><br></blockquote></div><br><a name="Gesture_Event_Rotate" id="Gesture_Event_Rotate"></a><div style="float:left"><img style=
"vertical-align:middle;padding-top:6px;padding-left:10px;" src=
"images/icon_rotate.png"></div> <label class="collapse" for="three">Faire pivoter les événements</label> <input id="three" type="checkbox"><div class="index_list"><p> Les événements &quot;Rotation&quot; sont basés sur deux touches à l&#39;écran des périphériques qui sont reconnues à la fois, et où il y a eu une rotation angulaire cohérente entre les deux dans un temps spécifique. L&#39;angle de mouvement des touches avec le mouvement de chaque touche est ce qui déterminera la détection d&#39;un événement Pincer ou Pivoter, où (dans le cas du type <b>Rotation d&#39;événement</b> ): </p><ul><li> Deux touches doivent être maintenues enfoncées pendant une durée minimale spécifiée (la durée par défaut est 0,16 secondes, mais vous pouvez la modifier en utilisant la fonction <a href=
"../../../3_scripting/4_gml_reference/controls/gesture%20input/gesture_rotate_time.html"><tt>gesture_rotate_time()</tt></a> ). </li><li> Au cours de cette période minimale, ils doivent tourner dans une direction cohérente (si le sens de rotation change pendant cette période, aucune rotation n&#39;est lancée). </li><li> La quantité de rotation doit dépasser l&#39;angle de seuil minimum (qui est réglé sur 5 ° par défaut, mais cela peut être changé en utilisant la fonction <a href=
"../../../3_scripting/4_gml_reference/controls/gesture%20input/gesture_rotate_angle.html"><tt>gesture_rotate_angle()</tt></a> ). </li></ul><p> Lorsque deux touches et un mouvement sont détectés avec les critères ci-dessus, un événement de rotation sera déclenché, et dans chacun des événements, le <tt>event_data</tt> DS Map sera rempli avec les clés suivantes: </p><div class="compat"><table><tr><th> Clé </th><th> Valeur Description </th></tr><tr><td> <span class="notranslate">&quot;gesture&quot;</span> </td> <td><br> C&#39;est une valeur d&#39;ID <i>unique</i> au geste en cours. Cela vous permet de relier les différentes parties des gestes en plusieurs parties (telles que le début, le glisser et la fin). <br><br></td></tr><tr class="alt"><td> <span class="notranslate">&quot;touch1&quot;</span> </td> <td><br> C&#39;est l&#39;index du premier contact qui est utilisé dans le cadre du geste de pincement. En général, ce sera 0, mais si l&#39;utilisateur touche l&#39;écran n&#39;importe où ailleurs lorsque cet événement est déclenché par une autre touche, alors la valeur sera supérieure à 0. <br><br></td></tr><tr><td> <span class="notranslate">&quot;touch2&quot;</span> </td> <td><br> C&#39;est l&#39;index de la deuxième touche qui est utilisée dans le cadre du geste de pincement. En général, cela sera 1 de plus que la valeur de touch1, mais peut être une autre valeur en fonction du nombre de touches détectées ailleurs. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">&quot;posX1&quot;</span> </td> <td><br> C&#39;est la position X du premier contact. <br><br></td></tr><tr><td> <span class="notranslate">&quot;posY1&quot;</span> </td> <td><br> C&#39;est la position Y dans l&#39;espace de la pièce du premier contact. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">&quot;rawposX1&quot;</span> </td> <td><br> Ceci est la position <i>brute</i> de l&#39;espace de fenêtre X du premier contact (ce qui équivaut à obtenir la position de la souris en utilisant <a href=
"../../../3_scripting/4_gml_reference/controls/device%20input/device_mouse_raw_x.html"><tt>device_mouse_raw_x()</tt></a> ). <br><br></td></tr><tr><td> <span class="notranslate">&quot;rawposY1&quot;</span> </td> <td><br> Ceci est la position <i>brute</i> de l&#39;espace de fenêtre du premier contact (équivalent à l&#39;obtention de la position de la souris en utilisant <a href=
"../../../3_scripting/4_gml_reference/controls/device%20input/device_mouse_raw_y.html"><tt>device_mouse_raw_y()</tt></a> ). <br><br></td></tr><tr class="alt"><td> <span class="notranslate">&quot;guiposX1&quot;</span> </td> <td><br> Ceci est la position gui-espace X du premier contact (équivalent à l&#39;obtention de la position de la souris en utilisant <a href=
"../../../3_scripting/4_gml_reference/controls/device%20input/device_mouse_x_to_gui.html"><tt>device_mouse_x_to_gui()</tt></a> ). <br><br></td></tr><tr><td> <span class="notranslate">&quot;guiposY1&quot;</span> </td> <td><br> Ceci est la position gui-space Y du second contact (équivalent à l&#39;obtention de la position de la souris en utilisant <a href=
"../../../3_scripting/4_gml_reference/controls/device%20input/device_mouse_y_to_gui.html"><tt>device_mouse_y_to_gui()</tt></a> ). <br><br></td></tr><tr class="alt"><td> <span class="notranslate">&quot;posX2&quot;</span> </td> <td><br> C&#39;est la position X dans l&#39;espace de la seconde touche. <br><br></td></tr><tr><td> <span class="notranslate">&quot;posY2&quot;</span> </td> <td><br> C&#39;est la position Y dans l&#39;espace de la pièce du second contact. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">&quot;rawposX2&quot;</span> </td> <td><br> Ceci est la position <i>brute</i> de l&#39;espace de fenêtre X du premier contact. <br><br></td></tr><tr><td> <span class="notranslate">&quot;rawposY2&quot;</span> </td> <td><br> C&#39;est la position <i>brute</i> Y de l&#39;espace fenêtre du second contact. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">&quot;guiposX2&quot;</span> </td> <td><br> C&#39;est la position gui-espace X du second contact. <br><br></td></tr><tr><td> <span class="notranslate">&quot;guiposY2&quot;</span> </td> <td><br> C&#39;est la position gui-espace Y du second contact. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">&quot;pivotX&quot;</span> </td> <td><br> La position X du point de pivotement de rotation dans l&#39;espace de la pièce. <br><br></td></tr><tr><td> <span class="notranslate">&quot;pivotY&quot;</span> </td> <td><br> La position Y du point de pivotement de rotation dans l&#39;espace de la pièce. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">&quot;rawpivotX&quot;</span> </td> <td><br> Ceci est la position brute de l&#39;espace de fenêtre X du point de rotation. <br><br></td></tr><tr><td> <span class="notranslate">&quot;rawpivotY&quot;</span> </td> <td><br> Ceci est la position brute Y de l&#39;espace fenêtre du point de rotation. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">&quot;guipivotX&quot;</span> </td> <td><br> C&#39;est la position X-espace X du point de rotation. <br><br></td></tr><tr><td> <span class="notranslate">&quot;guipivotY&quot;</span> </td> <td><br> Ceci est la position gui-espace Y du point de rotation. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">&quot;relativeangle&quot;</span> </td> <td><br> <b>C&#39;est la différence de rotation par rapport au dernier événement de ce geste, mesuré en degrés <br><br></b> </td></tr><tr><td> <span class="notranslate">&quot;absoluteangle&quot;</span> </td> <td><br> C&#39;est la différence d&#39;angle par rapport à l&#39;endroit où se trouvaient les doigts lorsque le geste a commencé, mesuré en degrés. Ainsi, par exemple, si les doigts ont tourné d&#39;un quart de cercle depuis le début du geste, cette valeur sera de 90 ° ou -90 °, selon le sens de rotation. <br><br></td></tr></table></div><blockquote><a name="gesture_rotate_start" id=
"gesture_rotate_start"></a> <label class="collapse" for="j">Faire pivoter le début</label> <input id="j" type="checkbox"><div class="index_list"><p> L&#39;événement <b>Rotate Start</b> sera déclenché lorsqu&#39;une instance (ou l&#39;écran si l&#39;événement est global) a été touchée par deux &quot;doigts&quot; (et le contact est maintenu) et que l&#39;un ou les deux &quot;doigts&quot; sont tournés depuis le début position. La rotation des touches doit avoir démarré dans un court laps de temps (0,16 secondes par défaut, mais elle peut être définie à l&#39;aide de la fonction <a href=
"../../../3_scripting/4_gml_reference/controls/gesture%20input/gesture_rotate_time.html"><tt>gesture_rotate_time()</tt></a> ) et être supérieur au seuil angulaire minimum (par défaut 5 °, mais cela peut être modifié en utilisant la fonction <a href=
"../../../3_scripting/4_gml_reference/controls/gesture%20input/gesture_rotate_angle.html"><tt>gesture_rotate_angle()</tt></a> ). Si ces vérifications sont vraies, un événement <b>Rotate Start</b> sera déclenché et vous pourrez l&#39;utiliser pour stocker des valeurs ou définir des variables à utiliser avec les autres événements de rotation. Par exemple: </p><h3> Créer un évènement </h3><p class="code">rotating = false;<br>
view_a = camera_get_view_angle(view_camera[0]);<br><span class="notranslate"></span></p><h3> Faire pivoter l&#39;événement de départ </h3><p class="code">rotating = true;<br><span class="notranslate"></span></p><p><br> Le code ci-dessus définit simplement certaines variables pour faire pivoter la caméra de vue, puis dans l&#39;événement Rotate Start, il définit l&#39;un d&#39;eux pour <tt>true</tt>. </p></div><br><a name="gesture_rotating" id="gesture_rotating"></a> <label class=
"collapse" for="k">Tournant</label> <input id="k" type="checkbox"><div class="index_list"><p> L&#39;événement de <b>rotation</b> sera déclenché à chaque pas que les touches sur l&#39;écran tournent l&#39;une autour de l&#39;autre, tant que le mouvement est supérieur au seuil angulaire minimum (par défaut 5 °, mais, cela peut être changé en utilisant la fonction <a href=
"../../../3_scripting/4_gml_reference/controls/gesture%20input/gesture_rotate_angle.html"><tt>gesture_rotate_angle()</tt></a> ). Cet événement peut être utilisé pour définir des variables et manipuler des instances, par exemple: </p><h3> Événement tournant </h3><p class="code">var _relangle = event_data[?"relativeangle"];<br>
var _a = camera_get_view_angle(view_camera[0]);<br>
_a += _relangle;<br>
camera_set_view_angle(view_camera[0], _a);<br><span class="notranslate"></span></p><p><br> Le code ci-dessus fait pivoter la vue de la caméra en fonction du mouvement de rotation des touches dans l&#39;événement. </p></div><br><a name="gesture_rotate_end" id="gesture_rotate_end"></a> <label class="collapse" for="l">Rotation Fin</label> <input id="l"
type="checkbox"><div class="index_list"><p> L&#39;événement <b>Rotate End</b> sera déclenché lorsque l&#39;un (ou les deux) touchers qui composent le geste sont libérés de l&#39;écran de l&#39;appareil. Cet événement peut être utilisé pour définir des variables et manipuler des instances, par exemple: </p><h3> Faire pivoter l&#39;événement de fin </h3><p class="code">rotating = false;<br><span class="notranslate"></span></p><h3> Étape </h3><p class="code">if !rotating<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;var _a =
camera_get_view_angle(view_camera[0]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;var _adif = angle_difference(view_a,
_a);<br>
&nbsp;&nbsp;&nbsp;&nbsp;_a += median(-5, _adif, 5);<br>
&nbsp;&nbsp;&nbsp;&nbsp;camera_set_view_angle(view_camera[0],
_a);<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><p><br> Le code ci-dessus utilise l&#39;événement Rotate End pour détecter quand l&#39;utilisateur arrête le mouvement et définit ensuite une variable. Cette variable est ensuite utilisée dans l&#39;événement d&#39;étape pour ramener la caméra de vue dans sa position d&#39;origine. </p></div><br></blockquote></div><br></blockquote><p><br></p></div><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> Retour: <a href="../objects.html">L&#39;éditeur d&#39;objets</a> </div><div style="float:right"> Suivant: <a href="async_events.html">Événements asynchrones</a> </div></div></div><h5> © Copyright <span class="notranslate">YoYo Games Ltd.</span> 2017 Tous droits réservés </h5>
<script type="text/javascript">
   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');   ga('create', 'UA-2711665-14', 'auto');   ga('send', 'pageview'); 
</script>
</div>

<script type="text/JavaScript">
var fe = FindFrame("toc", top);
if ((fe != null) && (chmtop.c2wtopf.jstree != null)) {
  if (chmtop.c2wtopf.FITEMS[chmtop.c2wtopf.pagenum] != chmtop.c2wtopf.pageid)
    chmtop.c2wtopf.jstree.OpenTreeNode("source/" + chmtop.c2wtopf.pageid);
}
</script>
</body>
</html>
