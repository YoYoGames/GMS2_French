<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="keywords" content="online documentation, web online help, web help, chm2web" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="generator" content="chm2web Pro 2.85 (unicode)" />
<title>The Asynchronous Events</title>
<meta http-equiv="X-UA-Compatible" content="IE=9">

<link rel="stylesheet" href="../../../../../files/helpindex.css"
type="text/css">
<link rel="stylesheet" href="../../../../../default.css" type=
"text/css">

<script type="text/JavaScript" src="../../../../../files/supply.js"></script>
<script type="text/JavaScript">
chmtop.c2wtopf.pageid = "_build/2_interface/1_editors/events/async_events.html";
</script>

</head>
<body><script type="text/JavaScript"> 
if (window.name != "content") 
  document.write(" <table width=\"100%\" bgcolor=\"#e1e1e1\"cellspacing=\"2\" cellpadding=\"0\" style=\"border-collapse: collapse; font-family: sans-serif; font-size: 14px; color: #000000; text-decoration: none;  \"> <tr> <td align=\"center\" style=\"border-bottom: 2px solid gray\" > <br>&nbsp;Click <a href=\"../../../../../index.html?page=source%2F_build%2F2_interface%2F1_editors%2Fevents%2Fasync_events.html\">here</a> to show toolbars of the Web Online Help System: <a href=\"../../../../../index.html?page=source%2F_build%2F2_interface%2F1_editors%2Fevents%2Fasync_events.html\">show toolbars</a><br>&nbsp;</td></tr></table><br> "); 
</script>
<!-- !chm2web! --><script type="text/JavaScript">
 if( typeof(chmtop.helpStyle) != 'undefined' ) { var linkNodes = document.getElementsByTagName("link");  for( var i=0; i < linkNodes.length; ++i ) { var link = linkNodes[i];    if( link.href.endsWith("default.css")) {    var style = link.href.replace("default.css", chmtop.helpStyle); document.write('<link id="newstyleLink" rel="stylesheet" href=' + style + ' type="text/css">');    break; } } } 
</script><h2> Les événements asynchrones </h2><div class="body-scroll"><p><img class="center" src="images/editor_objects_async.png" alt="Événements asynchrones de l&#39;éditeur d&#39;objets"> Un <b>événement asynchrone</b> est un <b>événement</b> déclenché lorsque <i><span class="notranslate">GameMaker Studio 2</span></i> reçoit un &quot;rappel&quot; provenant d&#39;une source externe, qui peut provenir du Web ou de l&#39;appareil exécutant votre jeu. Fondamentalement, vous <i><span class="notranslate">GameMaker</span></i> à <i><span class="notranslate">GameMaker</span> Studio 2</i> de faire quelque chose, comme de charger une image, et il commencera à le faire, mais continuera à faire tout ce qu&#39;il devra faire en attendant de pouvoir fonctionner. Ensuite, lorsque la demande est terminée, un rappel est envoyé à <i><span class="notranslate">GameMaker Studio 2</span></i> et tous les <b>événements asynchrones</b> définis pour ce type de rappel sont déclenchés. Veuillez noter que les événements asynchrones sont déclenchés pour <i>toutes les</i> instances qui les possèdent, un peu comme les événements clés, afin que vous puissiez effectuer un <tt>http_get</tt> appel dans une instance, mais organisez l&#39;événement HTTP asynchrone dans une autre pour traiter l&#39;appel. <br></p><div class="note"> <b>REMARQUE</b>: sachez qu&#39;en raison de la protection XSS dans les navigateurs, les demandes et les tentatives de chargement de ressources provenant de plusieurs domaines sont bloquées et peuvent renvoyer des résultats vides lors de l&#39;utilisation de l&#39;un des événements suivants. </div><p><br> Il existe différents types d&#39;événements associés à la catégorie d&#39;événements asynchrones. Ils sont tous expliqués dans les sections ci-dessous: </p><div class="note"> <b>NOTE:</b> la variable <tt>async_load</tt> qui est mentionné dans les sections suivantes n’est <b>valable que dans ces cas</b>, car <tt>ds_map</tt> c’est-à-dire que les points à sont créés au début de l’événement, puis supprimés à la fin, cette variable étant réinitialisée à la valeur -1 à tous les autres moments. </div><p><br></p><blockquote><a name="async_audio_play" id="async_audio_play"></a> <label class="collapse" for="thirteen">Lecture audio</label> <input id="thirteen" type="checkbox"><div class="index_list"> Cet événement ne peut être déclenché que par les <a href=
"../../../3_scripting/4_gml_reference/audio/audio%20buffers.html">fonctions de lecture de la file d’audio</a> et renverra un message. <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> stocké dans la variable <tt>async_load</tt>, contenant différentes paires clé / valeur relatives à la file d&#39;attente audio qui a déclenché l&#39;événement. L&#39;événement est déclenché lorsque vous avez sélectionné une file d&#39;attente audio à lire et qu&#39;un tampon de cette file d&#39;attente a été lu. <br><br> Les clés suivantes seront disponibles dans ds_map: <br><br><ul><li> &quot; <b>queue_id</b> &quot; - index de la file d&#39;attente qui a été fini, tel que retourné par la fonction <a href=
"../../../3_scripting/4_gml_reference/audio/audio_create_play_queue.html"><tt>audio_create_play_queue</tt></a>. </li><li> &quot; <b>buffer_id</b> &quot; - l&#39;identifiant de tampon pour le tampon qui n&#39;est plus lu depuis </li><li> &quot; <b>queue_shutdown</b> &quot; - défini à 0 lors de la lecture normale et à 1 lors de la réception de l&#39;événement car <a href=
"../../../3_scripting/4_gml_reference/audio/audio_free_play_queue.html"><tt>audio_free_play_queue</tt></a> a été appelé. Lorsque ce paramètre est défini sur 1, vous ne souhaitez plus mettre les données en file d&#39;attente. </li></ul> Puisqu&#39;une file d&#39;attente audio peut être créée à partir de plusieurs tampons, cet événement peut être déclenché plusieurs fois pour une file d&#39;attente lorsque la fin de chaque section de l&#39;audio en mémoire tampon est atteinte, d&#39;où la clé &quot;buffer_id&quot;. <br><br><div class="note"> <b>NOTE:</b> la variable <tt>async_load</tt> n&#39;est valide que dans les événements asynchrones, comme <tt>ds_map</tt> c’est-à-dire que les points à sont créés au début de l’événement, puis supprimés à la fin, cette variable étant réinitialisée à la valeur -1. Cependant, toutes les autres structures de données créées à partir de l&#39;événement <b>doivent être nettoyées à l&#39;aide des fonctions appropriées</b>. </div><br> Dans l&#39;exemple d&#39;utilisation donné ci-dessous, nous allons créer une file d&#39;attente audio avec 10 sons audio mis en tampon, puis lire la file d&#39;attente: <br><br><p class="code">audio_queue = audio_create_play_queue(buffer_s16,
11052, audio_mono);<br>
for (var i = 0; i &lt; 10; i++;)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;audio_queue_sound(audio_queue, audio_buffer[i],
0, buffer_get_size(audio_buffer[i]));<br>
&nbsp;&nbsp;&nbsp;}<br>
audio_play_sound(audio_queue, 0, true);<br><span class="notranslate"></span></p><br> Chaque étape du jeu maintenant que l’enregistrement est détecté déclenchera un événement d’enregistrement audio asynchrone dans lequel vous pourrez traiter l’entrée enregistrée de la manière suivante: <br><br><p class="code">var queue = async_load[? "queue_id"];<br>
var num = 0;<br>
if queue = audio_queue<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;for (var i = 0; i &lt; 10; i++;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if async_load[? "buffer_id"] ==
audio_buffer[i]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer_seek(audio_buffer[i],
buffer_seek_start, 0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num = i;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;if num == 9<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;audio_stop_sound(audio_queue);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;audio_free_play_queue(audio_queue);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Ici, nous vérifions l&#39;ID de la file d&#39;attente et si c&#39;est celui que nous voulons, nous vérifions ensuite l&#39;ID du tampon pour voir quel tampon a été lu. Nous avons également défini une variable locale sur cette valeur d’index pour une vérification ultérieure, ainsi que la mémoire tampon au début pour ce son. Une fois que notre variable locale atteint 9, indiquant que la file d&#39;attente est terminée, nous arrêtons la lecture du son et libérons la file d&#39;attente. </div><br><a name="async_audio_rec" id="async_audio_rec"></a> <label class=
"collapse" for="twelve">Enregistrement audio</label> <input id="twelve"
type="checkbox"><div class="index_list"> Cet événement ne peut être déclenché que par le <a href=
"../../../3_scripting/4_gml_reference/audio/audio_start_recording.html"><tt>audio_start_recording()</tt></a> fonction et retournera un <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> stocké dans la variable <tt>async_load</tt>, contenant différentes paires clé / valeur en fonction du rappel de la fonction qui a déclenché l&#39;événement. <br><br> Les clés suivantes seront disponibles dans ds_map: <br><br><ul><li> &quot; <b>buffer_id</b> &quot; - l&#39;ID du tampon temporaire que vous pouvez utiliser pour récupérer les données audio </li><li> &quot; <b>channel_index</b> &quot; - l&#39;index de canal d&#39;enregistrement tel que retourné par la fonction appelante d&#39;où proviennent ces données </li><li> &quot; <b>data_len</b> &quot; - la longueur des données (en octets) que vous avez reçues </li></ul><div class="note"> <b>NOTE:</b> Comme mentionné au début de cette page, la variable <tt>async_load</tt> n&#39;est valide que dans les événements asynchrones, comme <tt>ds_map</tt> c’est-à-dire que les points à sont créés au début de l’événement, puis supprimés à la fin. Toutefois, notez que le tampon temporaire dans lequel tout l&#39;audio est stocké avec la carte sera également supprimé à la fin de l&#39;événement. Vous devez donc le copier dans un tampon personnalisé si vous souhaitez le conserver pour une utilisation ultérieure. </div><br> Dans l&#39;exemple d&#39;utilisation ci-dessous, nous allons créer un tampon personnalisé pour stocker nos données audio enregistrées et configurer notre jeu pour qu&#39;il enregistre à partir de la source d&#39;entrée 0: <br><br><p class="code">channel_index = audio_start_recording(0);<br>
audio_buffer = buffer_create(len, buffer_fast, 1);<br><span class="notranslate"></span></p><br> Chaque étape du jeu maintenant que l’enregistrement est détecté déclenchera un événement d’enregistrement audio asynchrone dans lequel vous pourrez traiter l’entrée enregistrée de la manière suivante: <br><br><p class="code">var channel = async_load[? "channel_index"];<br>
if channel == channel_index<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;len = async_load[? "data_len"];<br>
&nbsp;&nbsp;&nbsp;buffer_copy(async_load[? "buffer_id"], 0, len,
audio_buffer, 0);<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Ici, nous vérifions simplement la clé &quot;channel_index&quot; pour nous assurer qu&#39;elle correspond à la valeur renvoyée lorsque nous avons commencé à enregistrer, et le cas échéant, nous copions le contenu du tampon temporaire créé pour cet événement dans notre tampon personnalisé. Après cela, vous pouvez faire ce que vous voulez avec le tampon personnalisé - vous pouvez le jouer en utilisant les fonctions audio du tampon dédié, vous pouvez le traiter et l&#39;envoyer sur le réseau, vous pouvez l&#39;enregistrer sur le disque... Une fois que vous avez votre audio enregistré dans un tampon, vous pouvez faire pratiquement tout ce que vous voulez. </div><br><a name="async_cloud" id="async_cloud"></a> <label class="collapse"
for="five">Nuage</label> <input id="five" type="checkbox"><div class="index_list"> L’événement de nuage est celui qui est déclenché par l’appel en retour de l’un des <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/index.html"><tt>cloud_</tt> fonctions</a>, comme <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/cloud_synchronise.html"><tt>cloud_synchronise</tt></a>. Il génère en réalité un <tt>ds_map</tt> qui est exclusif à cet événement et est stocké dans la variable spéciale <b>async_load</b> (veuillez consulter les fonctions individuelles pour obtenir des exemples de code qui expliquent l&#39;utilisation de cet événement plus en détail). Ce ds_map a la structure suivante: <br><br><ul><li> <b>&quot;status&quot;:</b> Ceci contient le code de statut, où une valeur négative indique une erreur, une description de celle-ci sera contenue dans «errorString». Une valeur de 0 (ou une valeur positive) indique un succès (voir ci-dessous pour les valeurs exactes), et «resultString» contiendra les données renvoyées ou un message de succès. </li><li style="list-style: none"><br></li><li> <b>&quot;id&quot;:</b> l&#39;identifiant renvoyé par la fonction appelée. Si vous déclenchez une série de <tt>cloud_</tt> demandes, vous devez savoir à quelle réponse vous recevez la réponse et vous utiliserez donc cette valeur pour la comparer à la valeur que vous avez stockée lorsque vous avez initialement envoyé la demande pour trouver la bonne. </li><li style="list-style: none"><br></li><li> <b>&quot;description&quot;:</b> La description du dernier fichier téléchargé. </li><li style="list-style: none"><br></li><li> <b>&quot;resultString&quot;:</b> Ceci contient une chaîne qui est le blob de données renvoyé du cloud. </li><li style="list-style: none"><br></li><li> <b>&quot;errorString&quot;:</b> renvoie une chaîne d&#39;erreur pour toute erreur. </li></ul> La signification exacte de l&#39;entrée de carte &quot;statut&quot; renvoyée est expliquée dans le tableau suivant: <div class="compat"><table><tr><th> Valeur de statut </th><th> errorString / resultString </th><th> La description </th></tr><tr><td> <span class="notranslate">-1</span> </td> <td> errorString = &quot;Non connecté à &lt;SERVICE&gt;&quot; </td><td> <span class="notranslate">You have not successfully logged in to the given Cloud Service</span> </td> </tr><tr class="alt"><td> <span class="notranslate">0</span> </td> <td> resultString = données récupérées </td><td> <span class="notranslate">New game data downloaded from the cloud (following a cloud_synchronise call)</span> </td> </tr><tr><td> <span class="notranslate">1</span> </td> <td> resultString = &quot;Déjà synchronisé&quot; </td><td> <span class="notranslate">No new data since you last called cloud_synchronise</span> </td> </tr><tr class="alt"><td> <span class="notranslate">2</span> </td> <td> resultString = &quot;ConflictDeferral&quot; </td><td> <span class="notranslate">A conflict was encountered, but the gamer chose to ignore it</span> </td> </tr><tr><td> <span class="notranslate">3</span> </td> <td> resultString = &quot;GameUploadSuccess&quot; </td><td> <span class="notranslate">data from <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/cloud_string_save.html"><tt>cloud_string_save</tt></a> or <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/cloud_file_save.html"><tt>cloud_file_save</tt></a> was successfully uploaded to the cloud</span> </td> </tr><tr class="alt"><td> <span class="notranslate">-n</span> </td> <td> errorString = Description de l&#39;erreur </td><td> <span class="notranslate">Any other negative number means a synchronisation failure</span> </td> </tr></table></div></div><br><a name="async_dialogue" id="async_dialogue"></a> <label class=
"collapse" for="three">Dialogue</label> <input id="three" type=
"checkbox"><div class="index_list"> Comme les événements ci-dessus, l&#39;événement <b>Dialogues</b> n&#39;est déclenché que s&#39;il reçoit un appel d&#39;une des fonctions utilisateur asynchrones spéciales, comme <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/get_login_async.html"><tt>get_login_async()</tt></a> (Veuillez consulter cette fonction pour obtenir un exemple de code étendu illustrant la manière dont cet événement est utilisé). Ces événements sont ceux qui demandent un certain type d’entrée utilisateur, qui peut être un nom, des informations de connexion, un nombre ou une couleur, etc. La plupart des appareils n’aiment pas rester assis en boucle dans l’attente d’une réponse. be asynchrone et <i><span class="notranslate">GameMaker Studio 2</span></i> continuera de s’exécuter en arrière-plan tant que ces fonctions auront un dialogue ouvert et jusqu’à ce qu’elles obtiennent l’entrée utilisateur requise pour déclencher cet événement. <br><br> Encore une fois, un <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> est retourné avec l&#39;id <b>contenu</b> dans la variable spéciale <b>async_load</b>. Les valeurs contenues dans cette carte dépendent de la fonction utilisée. Consultez les entrées individuelles pour chaque fonction de ce manuel pour plus de détails. </div><br><a name="async_http" id="async_http"></a> <label class="collapse"
for="two">HTTP</label> <input id="two" type="checkbox"><div class="index_list"> L’événement HTTP est celui qui est déclenché par le rappel depuis l’un des programmes <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/index.html"><tt>http_</tt> fonctions</a>, comme <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/http_post_string.html"><tt>http_post_string</tt></a>. Il génère en réalité un <tt>ds_map</tt> (parfois appelé &quot;dictionnaire&quot;) qui est exclusif à cet événement et qui est stocké dans la variable spéciale <tt>async_load</tt> (Veuillez consulter les fonctions individuelles pour des exemples de code expliquant plus en détail l&#39;utilisation de cet événement). Ce <tt>ds_map</tt> a la structure suivante: <br><br><ul><li> <b>&quot;id&quot;:</b> l&#39;identifiant renvoyé par la commande. Si vous déclenchez une série de <tt>http_</tt> demandes, vous devez savoir à quelle réponse vous recevez la réponse et vous utiliserez donc cette valeur pour la comparer à la valeur que vous avez stockée lorsque vous avez initialement envoyé la demande pour trouver la bonne. </li><li style="list-style: none"><br></li><li> <b>&quot;status&quot;:</b> renvoie une valeur inférieure à 0 pour une erreur, à 0 en cas de succès et à 1 si le contenu est en cours de téléchargement. </li><li style="list-style: none"><br></li><li> <b>&quot;result&quot;:</b> les données reçues (chaîne uniquement), ou le chemin du fichier téléchargé si vous avez utilisé <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/http_get_file.html"><tt>http_get_file()</tt></a>. </li><li style="list-style: none"><br></li><li> <b>&quot;url&quot;: l&#39;</b> URL complète que vous avez demandée. </li><li style="list-style: none"><br></li><li> <b>&quot;http_status&quot;:</b> Le code d&#39;état http brut (s&#39;il est disponible). Cela renvoie le code d&#39;état Web standard pour la plupart des navigateurs, par exemple: 304 pour &quot;Non modifié&quot; ou 204 pour &quot;Aucun contenu&quot;, etc. </li></ul> C&#39;est pour quand vous utilisez le <tt>http_post_string()</tt> fonction, mais chacun des <tt>http_</tt> Les fonctions peuvent renvoyer une carte légèrement différente. Veuillez donc vous reporter à la saisie manuelle de chaque fonction pour connaître les données précises renvoyées. <br><br><div class="note"> <b>NOTE:</b> Comme <tt>async_load</tt> crée un <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a>, ces fonctions sont particulièrement utiles lorsqu&#39;elles sont associées au <a href=
"../../../3_scripting/4_gml_reference/file%20handling/json_encode.html"><tt>json_encode</tt></a> et <a href=
"../../../3_scripting/4_gml_reference/file%20handling/json_decode.html"><tt>json_decode</tt></a> les fonctions. </div><br><br> Des données supplémentaires pourraient également être fournies par cette carte si vous avez demandé le téléchargement de fichiers. Dans ce cas, le &quot;statut&quot; aura une valeur de 1 et le ds_map contiendra ces clés supplémentaires: <br><br><ul><li> <b>&quot;contentLength&quot;:</b> Il s&#39;agit de la taille du fichier que le serveur Web a indiqué que vous devriez recevoir (peut être -1 si le serveur ne renvoie pas ces données). </li><li style="list-style: none"><br></li><li> <b>&quot;sizeDownloaded&quot;:</b> taille des données déjà téléchargées. </li></ul> Notez que l&#39;événement <i>ne</i> sera <i>pas</i> déclenché pour chaque paquet de données reçu, mais se mettra à jour à tout moment pendant le téléchargement dans la boucle de jeu principale. Notez également qu&#39;actuellement cette fonctionnalité n&#39;est disponible que pour les <i>plates-</i> formes cible <i>Windows</i> classiques. </div><br><a name="async_iap" id="async_iap"></a> <label class="collapse"
for="four">IAP</label> <input id="four" type="checkbox"><div class="index_list"> Cet événement ne peut être déclenché que lorsque vous avez activé les <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/index.html">achats intégrés</a> pour votre jeu. Si cette fonctionnalité est ajoutée, l&#39;événement sera déclenché dans les cas suivants: <br><br><ul><li> L&#39;état du magasin change. </li><li> Un produit (ou des produits) ont été activés. </li><li> Le produit et les achats ont été restaurés. </li><li> Un produit a été acheté. </li><li> Un produit a été consommé. </li></ul> L’événement créera toujours un événement spécial <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> avec un identifiant d&#39;index stocké dans la variable intégrée <tt><b>iap_data</b></tt>. Cette carte contiendra <i>toujours</i> la clé &quot; <b>type</b> &quot;, qui contiendra l&#39;une des valeurs constantes suivantes: <div class="compat"><table><tr><th> Constant </th><th> La description </th></tr><tr><td> <span class="notranslate">iap_ev_storeload</span> </td> <td> Cela est déclenché lorsqu&#39;un changement est détecté dans le magasin de la plateforme cible. </td></tr><tr class="alt"><td> <span class="notranslate">iap_ev_product</span> </td> <td> Cet événement est déclenché lorsqu&#39;un produit est activé et contiendra des informations supplémentaires sur le produit. </td></tr><tr><td> <span class="notranslate">iap_ev_restore</span> </td> <td> Cet événement n&#39;est déclenché que lorsque vous utilisez le <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_restore_all.html"><tt>iap_restore_all</tt></a> une fonction. </td></tr><tr class="alt"><td> <span class="notranslate">iap_ev_purchase</span> </td> <td> Lorsqu&#39;un achat est terminé, cet événement est déclenché. </td></tr><tr><td> <span class="notranslate">iap_ev_consume</span> </td> <td> Quand vous utilisez la fonction <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_consume.html"><tt>iap_consume</tt></a> cela déclenche cet événement. </td></tr></table></div><p><br><br> Chacun de ces &quot;types&quot; d’événement possibles ajoutera des clés supplémentaires au <tt>iap_data</tt> ds_map, qui peut ensuite être analysé pour obtenir les informations d&#39;achat ou de produit nécessaires. Le contenu exact de la <tt>iap_data</tt> Les cartes sont listées ci-dessous pour chaque événement &quot;type&quot;. </p><blockquote><a name="iap_ev_storeload" id="iap_ev_storeload"></a> <label class="collapse" for="fifteen">iap_ev_storeload</label> <input id="fifteen" type="checkbox"><div class="index_list"> Lorsque vous activez vos achats, votre jeu essaiera de contacter le magasin cible, déclenchant ainsi cet événement. le <tt>iap_data</tt> map aura alors une clé d&#39;addition &quot; <b>status&quot;</b>, qui aura comme valeur l&#39;une des constantes suivantes: <br><br><div class="compat"><table><tr><th> Constant </th><th> La description </th></tr><tr><td> <span class="notranslate">iap_storeload_ok</span> </td> <td> Le magasin a été contacté et la connexion est bonne. </td></tr><tr class="alt"><td> <span class="notranslate">iap_storeload_failed</span> </td> <td> Une erreur de connexion s&#39;est produite ou, pour une raison quelconque, le magasin n&#39;est pas disponible. </td></tr></table></div></div><br><a name="iap_ev_product" id="iap_ev_product"></a> <label class=
"collapse" for="sixteen">iap_ev_product</label> <input id="sixteen"
type="checkbox"><div class="index_list"> Tous les achats activés déclencheront ce &quot;type&quot; d&#39;événement, mais une seule fois par achat. Par conséquent, si vous avez activé dix produits, attendez-vous à ce que cet événement se déclenche dix fois. Si vous avez reçu cet événement, le <tt>iap_data</tt> ds_map contiendra la clé supplémentaire &quot; <b>index</b> &quot; qui contient la <b>chaîne d&#39;identifiant</b> unique du produit en cours d&#39;activation. Vous pouvez ensuite utiliser la fonction <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_product_details.html"><tt>iap_product_details</tt></a> avec cet ID de produit pour obtenir des informations supplémentaires. <br><br><div class="note"> <b>REMARQUE:</b> Google Play ( <span class="notranslate">Android</span> ) ne peut demander les détails que pour les produits 20 à la fois, ce qui peut entraîner des temps de chargement assez longs pour les applications comportant un nombre important de produits. </div></div><br><a name="iap_ev_restore" id="iap_ev_restore"></a> <label class=
"collapse" for="seventeen">iap_ev_restore</label> <input id=
"seventeen" type="checkbox"><div class="index_list"> Quand vous appelez la fonction <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_restore_all.html"><tt>iap_restore_all</tt></a> il déclenchera cet événement en ajoutant une clé &quot; <b>result</b> &quot; à la <tt>iap_data</tt> ds_map. Cette clé tiendra soit <tt>true</tt> ou <tt>false</tt> pour indiquer si les données d&#39;achat ont été restaurées avec succès à partir du magasin cible. </div><br><a name="iap_ev_purchase" id="iap_ev_purchase"></a> <label class=
"collapse" for="eighteen">iap_ev_purchase</label> <input id=
"eighteen" type="checkbox"><div class="index_list"> Pour demander un achat en utilisant la fonction <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_acquire.html"><tt>iap_acquire</tt></a> ce type d&#39;événement sera déclenché. le <tt>iap_data</tt> ds_map aura la clé supplémentaire &quot; <b>index</b> &quot; qui contient la valeur d&#39; <b>ID d&#39;achat</b> unique pour le produit acheté. Vous pouvez ensuite utiliser la fonction <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_purchase_details.html"><tt>iap_purchase_details</tt></a> avec cet ID d’achat pour obtenir de plus amples informations. <br><br><div class="note"> <b>REMARQUE:</b> Si le produit acheté est un consommable, il <b>doit être utilisé</b> avec <tt>iap_consume</tt> avant un nouvel achat peut être fait. </div></div><br><a name="iap_ev_consume" id="iap_ev_consume"></a> <label class=
"collapse" for="nineteen">iap_ev_consume</label> <input id=
"nineteen" type="checkbox"><div class="index_list"> Lorsque vous utilisez la fonction <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_consume.html"><tt>iap_consume</tt></a> ce type d&#39;événement sera déclenché. le <tt>iap_data</tt> ds_map aura la clé supplémentaire &quot; <b>product</b> &quot; qui contient la chaîne d&#39; <b>identifiant de produit</b> unique pour le produit en cours de consommation. </div></blockquote></div><br><a name="async_image_loaded" id="async_image_loaded"></a> <label class="collapse" for="one">Image chargée</label> <input id=
"one" type="checkbox"><div class="index_list"> Cet événement est déclenché lorsque vous chargez une image dans <i><span class="notranslate">GameMaker Studio 2</span></i>, à condition que vous ayez utilisé une URL ou un chemin valide avec la fonction de chargement de fichier applicable. Par exemple, supposons que vous vouliez charger une image-objet et modifiez uniquement l&#39;image-objet actuelle de l&#39;occurrence lorsqu&#39;elle sera chargée. Eh bien, vous auriez quelque chose comme ceci dans un événement create ou un événement d&#39;alarme (par exemple): <p class="code">spr =
sprite_add("http://www.angusgames.com/game/background1.png", 0,
false, false, 0, 0);<span class="notranslate"></span></p><p> Cela va maintenant commencer à charger l&#39;image dans l&#39;appareil ou le navigateur, mais cela <i>ne</i> bloquera <i>pas</i> <i><span class="notranslate">GameMaker Studio 2</span></i> tant qu&#39;il attend le chargement du fichier. Au lieu de cela, <i><span class="notranslate">GameMaker</span> Studio 2</i> continuera à fonctionner normalement jusqu&#39;à ce que l&#39;image soit chargée et que le rappel déclenche l&#39;événement <b>Image Loaded</b>, où une <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> est créé et stocké dans la variable spéciale <b>async_load</b>. La carte contient les informations suivantes: </p><ul><li> <b>&quot;nom de fichier&quot;:</b> le chemin complet du fichier que vous avez demandé. </li><li style="list-style: none"><br></li><li> <b>&quot;id&quot;:</b> l&#39;ID de la ressource que vous avez chargée. Ce sera la même chose que la variable à laquelle vous avez affecté la ressource. </li><li style="list-style: none"><br></li><li> <b>&quot;status&quot;:</b> Retourne une valeur inférieure à 0 en cas d&#39;erreur. </li></ul><p> Vous pouvez ensuite affecter l&#39;image nouvellement chargée à un arrière-plan dans cet événement. Ceci est également vrai pour les sprites et les sons, avec un ds_map en cours de création pour chacune de ces ressources, comme illustré ci-dessus, et l&#39;exemple de code suivant montre comment les informations renvoyées seraient utilisées dans cet événement: </p><p class="code">if ds_map_find_value(async_load, "id") == spr<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if ds_map_find_value(async_load, "status") &gt;=
0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprite_index = spr<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><p> Le code ci-dessus vérifie d&#39;abord l&#39;identifiant du fichier ds_map créé, puis le statut du rappel. Si la valeur est supérieure ou égale à 0 (succès de la signalisation), le résultat du rappel sera utilisé pour définir l&#39;index d&#39;arrière-plan sur la nouvelle image chargée. </p></div><br><a name="async_networking" id="async_networking"></a> <label class=
"collapse" for="six">La mise en réseau</label> <input id="six" type=
"checkbox"><div class="index_list"> L&#39;événement de mise en réseau est celui qui sera déclenché par le trafic réseau entrant et est lié aux <a href=
"../../../3_scripting/4_gml_reference/networking/index.html">fonctions de réseau</a>. Cet événement génère un <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html">ds_map</a> spécial exclusif à cet événement et stocké dans la variable spéciale <b>async_load</b>. Ce <tt>ds_map</tt> contiendra des informations différentes selon le type d&#39;événement de réseau qui l&#39;a généré. <blockquote><a name="async_network_common" id=
"async_network_common"></a> <label class="collapse" for=
"twenty">Événements de mise en réseau communs</label> <input id="twenty" type=
"checkbox"><div class="index_list"> Les touches suivantes sont communes à toutes les fonctions réseau reçues et seront toujours présentes dans la liste. <tt>async_load</tt> carte: <br><br><ul><li> <b>&quot;type&quot;:</b> Cela aura l&#39;une des constantes listées ci-dessous comme valeur de retour et désignera le type d&#39;événement de réseau. </li><li style="list-style: none"><br></li><li> <b>&quot;id&quot;: l&#39;</b> identifiant de la socket (un nombre réel, tel qu&#39;il est retourné par le <a href=
"../../../3_scripting/4_gml_reference/networking/network_create_server.html">serveur network_create_server</a> ou <a href=
"../../../3_scripting/4_gml_reference/networking/network_create_socket.html">network_create_socket</a> ) qui reçoit l&#39;événement. Dans la plupart des cas, l&#39;ID de socket renvoyé est celui du socket TCP ou UDP qui a déclenché l&#39;événement. Toutefois, si l&#39;événement est déclenché sur un <i>serveur</i> et qu&#39;il s&#39;agit d&#39;un événement de données (voir ci-dessous), l&#39;identifiant de la socket est celui du <i>client</i> qui a envoyé le message. Les données. </li><li style="list-style: none"><br></li><li> <b>&quot;ip&quot;:</b> l&#39;adresse IP du socket (sous forme de chaîne). </li><li style="list-style: none"><br></li><li> <b>&quot;port&quot;:</b> Le port associé à l&#39;adresse IP (utile lorsque vous travaillez avec UDP). </li></ul> Les valeurs de retour possibles pour la clé &quot;type&quot; peuvent être l&#39;une des trois constantes répertoriées ci-dessous: <div class="compat"><table><tr><th> Constant </th><th> La description </th></tr><tr><td> <span class="notranslate">network_type_connect</span> </td> <td> L&#39;événement a été déclenché par une connexion. </td></tr><tr class="alt"><td> <span class="notranslate">network_type_disconnect</span> </td> <td> L&#39;événement a été déclenché par une déconnexion. </td></tr><tr><td> <span class="notranslate">network_type_data</span> </td> <td> L&#39;événement a été déclenché par les données entrantes. </td></tr><tr class="alt"><td> <span class="notranslate">network_type_non_blocking_connect</span> </td> <td> L’événement a été déclenché par une connexion configurée comme non bloquante (vous pouvez utiliser la fonction <a href=
"../../../3_scripting/4_gml_reference/networking/network_set_config.html"><tt>network_set_config()</tt></a> pour ça). </td></tr></table></div></div><br><a name="async_network_connect" id="async_network_connect"></a> <label class="collapse" for="twentyone">Connexion / Déconnexion</label> <input id="twentyone" type="checkbox"><div class="index_list"> Quand vous avez un événement du type <tt>network_type_connect</tt>, <tt>network_type_non_blocking_connect</tt> ou <tt>network_type_disconnect</tt>, la <tt>async_load</tt> map aura les clés supplémentaires suivantes: <br><br><ul><li> <b>&quot;socket&quot;:</b> Cette clé maintiendra l&#39;identifiant de socket de connexion / déconnexion. </li><li style="list-style: none"><br></li><li> <b>&quot;successed&quot;:</b> cette clé sera 0 ou 1, 0 signifiant que la connexion a expiré et 1 que la connexion a abouti et que le socket est prêt à être utilisé. </li></ul> Il est à noter que l&#39;événement de mise en réseau n&#39;est pas déclenché dans les <i>clients</i> lorsque le <i>serveur se</i> déconnecte, et qu&#39;aucun des deux <tt>network_type_*</tt> les événements seront déclenchés dans les clients lorsque le serveur auquel ils sont connectés se déconnecte, même si la connexion est basée sur TCP. </div><br><a name="async_network_receive" id="async_network_receive"></a> <label class="collapse" for="twentytwo">Réception de données</label> <input id="twentytwo" type="checkbox"><div class="index_list"> Quand vous avez un <tt>network_type_data</tt> type event, ce qui signifie que votre réseau a reçu des données, la carte créée aura les clés suivantes: <br><br><ul><li> <b>&quot;buffer&quot;:</b> Il s&#39;agit de l&#39;unique &quot;buffer id&quot; généré par l&#39;événement. Un tampon de type &quot;Grow&quot;, octet aligné sur 1, est créé pour contenir l&#39;identifiant. Il doit être stocké dans une variable et utilisé pour tous les autres appels de fonction au tampon <i><b>dans cet événement</b></i>. Comme le <tt>async_load</tt> map, le tampon créé est automatiquement supprimé de la mémoire à la fin de cet événement. Pour plus d&#39;informations sur les tampons, voir <a href=
"../../../3_scripting/4_gml_reference/buffers/index.html">Référence - Tampons.</a> </li><li style="list-style: none"><br></li><li> <b>&quot;taille&quot;:</b> Il s&#39;agit de la taille (en octets) des données du tampon en cours de réception. </li></ul><div class="note"> <b>REMARQUE:</b> le tampon créé n&#39;est <b>valide que pour ces événements</b> et sera libéré à la fin de l&#39;événement. </div></div></blockquote></div><br><a name="async_push" id="async_push"></a> <label class="collapse"
for="ten">Notification push</label> <input id="ten" type=
"checkbox"><div class="index_list"> L&#39;événement de notification push est déclenché par le rappel des <b>notifications push</b> sur le système d&#39;exploitation du périphérique, soit à partir d&#39;une source locale à l&#39;aide de la fonction. <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/push_local_notification.html"><tt>push_local_notification</tt></a>, ou depuis une source distante (par exemple: votre serveur). Il génère un <tt>ds_map</tt> qui est exclusif à cet événement et est stocké dans la variable spéciale <b>async_load</b> (veuillez consulter les fonctions individuelles qui déclenchent des événements asynchrones pour des exemples de code expliquant plus en détail l&#39;utilisation de cet événement). Ce <tt>ds_map</tt> a les clés suivantes: <br><br><ul><li> <b>&quot;type&quot;: la</b> valeur peut être &quot;local&quot; pour une notification locale du périphérique, &quot;distant&quot; pour une notification distante ou &quot;register&quot; pour l&#39;enregistrement d&#39;une notification distante. </li><li> <b>&quot;status&quot;: La</b> valeur sera &quot;1&quot; en cas de succès ou &quot;0&quot; en cas d&#39;erreur. </li></ul> Il peut y avoir des entrées de clé supplémentaires en fonction du &quot;type&quot; renvoyé et de la valeur &quot;status&quot;. Pour &quot;status&quot;, si une erreur a été renvoyée (&quot;0&quot;), vous aurez également la clé suivante: <br><br><ul><li> <b>&quot;erreur&quot;:</b> contient les détails de l&#39;erreur reçue. </li></ul> Si la valeur &quot;status&quot; est 1 (c&#39;est-à-dire: pas d&#39;erreur), alors le <tt>ds_map</tt> contiendra les valeurs supplémentaires suivantes, en fonction de la valeur de la clé &quot;type&quot;: <br><br><ul><li> <b>&quot;reg_id&quot;:</b> Si le &quot;type&quot; reçu était &quot;register&quot;, cette clé contiendra l&#39;identifiant d&#39;enregistrement du périphérique pour les notifications à distance. </li><li> <b>&quot;data&quot;:</b> Si le &quot;type&quot; reçu était &quot;local&quot; ou &quot;distant&quot;, alors cette clé contiendra la charge utile de chaîne que vous avez définie lors de l&#39;appel de la fonction de notification. </li></ul> Pour mieux comprendre cela, nous avons créé un petit extrait de code ci-dessous que vous pourrez consulter. Dans cet exemple, nous allons envoyer une notification push locale en utilisant le code suivant: <br><br><p class="code">var fireTime =
date_inc_day(date_current_datetime(), 1);<br>
var data = "daily_reward";<br>
push_local_notification(fireTime, "Ahoy!", "Catch The Haggis Has A
Present", data);<br><span class="notranslate"></span></p><br> Cela configurera une minuterie pour &quot;envoyer&quot; une notification au périphérique lorsqu&#39;un jour s&#39;est écoulé. Lorsque le jour est écoulé, si votre jeu est en arrière-plan ou non en cours d&#39;exécution, une notification s&#39;affiche avec le titre et le message donnés (sur iOS, le nom du jeu est affiché et le titre est ignoré), puis un événement de notification push asynchrone sera appelé. Notez que si le jeu est au premier plan au moment de la notification, il <i>ne</i> sera <i>pas</i> affiché, mais l&#39;événement asynchrone <b>sera toujours déclenché</b>. Dans le cas où vous géreriez le rappel, procédez comme suit: <br><br><p class="code">var type = ds_map_find_value(async_load,
"type");<br>
var status = ds_map_find_value(async_load, "status");<br>
if status == 0<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;//error of some kind<br>
&nbsp;&nbsp;&nbsp;var error = ds_map_find_value(async_load,
"error");<br>
&nbsp;&nbsp;&nbsp;show_debug_message("error=" + string(error));<br>
&nbsp;&nbsp;&nbsp;}<br>
else<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if type == "register"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;global.reg_id =
ds_map_find_value(async_load, "reg_id");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var data =
ds_map_find_value(async_load, "data");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if data ==
"daily_reward"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;global.Gold
+= 1000;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p></div><br><a name="async_saveload" id="async_saveload"></a> <label class=
"collapse" for="eleven">Sauvegarder charger</label> <input id="eleven"
type="checkbox"><div class="index_list"> Cet événement sera déclenché par certaines fonctions liées au chargement et à l’enregistrement des tampons dans les fichiers, ainsi qu’au chargement ou au déchargement de l’audio de la mémoire. L&#39;événement lui-même contiendra le construit dans <tt>async_load</tt> Carte DS qui sera renseignée par les clés requises pour la fonction spécifique. Ceux-ci sont énumérés dans les sections ci-dessous. <blockquote><a name="async_saveload_buffers" id=
"async_saveload_buffers"></a> <label class="collapse" for=
"twentynine">Les tampons</label> <input id="twentynine" type=
"checkbox"><div class="index_list"> Quand vous utilisez les fonctions <a href=
"../../../3_scripting/4_gml_reference/buffers/buffer_save_async.html"><tt>buffer_save_async()</tt></a> ou <a href=
"../../../3_scripting/4_gml_reference/buffers/buffer_load_async.html"><tt>buffer_load_async()</tt></a> un événement asynchrone sera déclenché une fois le transfert de données terminé. Cet événement peuplera le <tt>async_load</tt> mapper avec les paires clé / valeur suivantes <br><br><ul><li> <b>&quot;id&quot;:</b> l&#39;identifiant de la fonction async renvoyé par la fonction utilisée. </li><li> <b>&quot;status&quot;:</b> reviendra <tt>true</tt> si les données ont été sauvegardées / chargées correctement, et <tt>false</tt> autrement. </li></ul> Cela vous permet d&#39;interroger la progression de la sauvegarde / chargement et d&#39;afficher un message ou de changer de pièce, etc., une fois le processus terminé. </div><br><a name="async_saveload_audio" id="async_saveload_audio"></a> <label class="collapse" for="thirty">Groupes audio</label> <input id="thirty" type="checkbox"><div class="index_list"> Lorsque vous travaillez avec des <a href=
"../../../3_scripting/4_gml_reference/audio/audio%20groups.html">groupes audio</a>, vous pouvez les charger et les décharger de la mémoire à l’aide des fonctions <a href=
"../../../3_scripting/4_gml_reference/audio/audio_group_load.html"><tt>
audio_group_load()</tt></a> et <a href=
"../../../3_scripting/4_gml_reference/audio/audio_group_unload.html"><tt>audio_group_unload()</tt></a>. Lorsque vous utilisez la fonction de chargement, il déclenche cet événement lorsque l&#39;ensemble des fichiers audio définis pour le groupe a été chargé en mémoire et remplit la carte avec les paires clé / valeur suivantes: <br><br><ul><li> <b>&quot;type&quot;:</b> cela nous indique le type d&#39;événement appelé et sera &quot; <tt>audiogroup_load</tt> &quot;pour charger l&#39;audio. </li><li> <b>&quot;group_id&quot;:</b> renverra l&#39;ID du groupe audio chargé (tel que défini dans l&#39; <a href=
"c:/source/yoyostudio/documentation/english/2_interface/3_settings/audio.html">éditeur de groupe audio</a> ). </li></ul> Lorsque tout l&#39;audio a été chargé pour un groupe, cet événement se déclenche et peut ensuite être utilisé pour changer de salle, ou jouer une piste de musique, etc. </div></blockquote></div><br><a name="async_social" id="async_social"></a> <label class=
"collapse" for="eight">Social</label> <input id="eight" type=
"checkbox"><div class="index_list"> Cet événement ne peut être déclenché que par les différentes <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/index.html">fonctions sociales</a> spécifiques et renverra une <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> stocké dans la variable <tt>async_load</tt>, contenant différentes paires clé / valeur en fonction du rappel de la fonction qui a déclenché l&#39;événement. <br><br> Le ds_map contiendra un certain nombre de clés, la plus importante étant la clé &quot; <i>id</i> &quot;. Cela retournera une <b>constante</b> qui peut ensuite être vérifiée dans le code pour déterminer lequel des nombreux rappels l’événement a reçu. Une fois que vous avez analysé cette clé et comparé la valeur renvoyée aux constantes disponibles, vous pouvez continuer à extraire le reste des informations de la carte. <blockquote><a name="async_social_leaderboards" id=
"async_social_leaderboards"></a> <label class="collapse" for=
"twentyseven">Classements et réalisations</label> <input id=
"twentyseven" type="checkbox"><div class="index_list"> Les pages de fonction sur <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/achievements%20and%20leaderboards/index.html">Social Gaming - Réalisations et Classement</a> dans la section Référence détaillent les fonctions et les rappels, ainsi que les constantes utilisées pour déclencher cet événement, mais il existe également certaines circonstances dans lesquelles il sera déclenché sans appel de fonction du jeu est en cours d&#39;exécution: <br><br><ul><li> lorsque votre jeu est lancé à partir du tableau de bord du système d&#39;exploitation </li><li> quand vous terminez un défi </li><li> quand un autre joueur termine un défi </li><li> lorsque le jeu est lancé à partir du tableau de bord du système d&#39;exploitation en sélectionnant un défi </li></ul><p> L’un des rappels ci-dessus déclenchera l’ <b>événement social</b> et une <tt>async_load</tt> La carte sera générée avec les détails suivants (notez qu&#39;il existe une valeur de clé &quot;id&quot; différente pour définir chacune des différentes raisons pour lesquelles l&#39;événement a été appelé, mais tous les autres contenus de la carte sont identiques): <br><br></p><ul><li> &quot; <b>id</b> &quot; - La valeur de cette clé dépend du type de rappel déclenchant l&#39;événement. ce peut être une de ces constantes: <br><br><ul><li> <b><tt>achievement_challenge_received</tt></b> - Un défi a été reçu <br></li><li> <b><tt>achievement_challenge_completed</tt></b> - Un défi a été complété. <br></li><li> <b><tt>achievement_challenge_completed_by_remote</tt></b> - Un défi a été complété par l&#39;autre joueur. <br></li><li> <b><tt>achievement_challenge_launched</tt></b> - Le jeu a été lancé à partir du tableau de bord du système d&#39;exploitation avec le défi donné. <br></li></ul></li><li> &quot; <b>playerid</b> &quot; - L&#39;identifiant du joueur pour le défi. <br><br></li><li> &quot; <b>issuerid</b> &quot; - Identifiant de la personne qui a lancé le défi. <br><br></li><li> &quot; <b>state</b> &quot; - Etat du défi, dont la valeur est 0 - 3 (sous forme de chaîne) pour <i>invalide</i>, en <i>attente</i>, <i>complété</i> ou <i>refusé</i>. <br><br></li><li> &quot; <b>message</b> &quot; - Le message texte pour contester. <br><br></li><li> &quot; <b>IssueDate</b> &quot; - La date d&#39;émission du défi <br><br></li><li> &quot; <b>completeddate</b> &quot; - La date d&#39;achèvement du défi. <br><br></li><li> &quot; <b>type</b> &quot; - Le type de défi donné. Peut être l&#39;une des deux constantes suivantes: <br><br><ul><li> <b><tt>achievement_type_score_challenge</tt></b> - Un défi basé sur la valeur du score. <br></li><li> <b><tt>achievement_type_achievement_challenge</tt></b> - Un défi basé sur une réalisation. <br></li></ul></li><li> &quot; <b>identificateur</b> &quot; - La chaîne d&#39;identification du défi. <br><br></li><li> &quot; <b>score</b> &quot; - Le score à égalité avec le défi. </li></ul> Vous trouverez ci-dessous un petit extrait de code à titre d&#39;exemple: <br><br><p class="code">var ident = ds_map_find_value(async_load, "id"
);<br>
if ident == achievement_challenge_completed;<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;player_id = ds_map_find_value(async_load,
"playerid");<br>
&nbsp;&nbsp;&nbsp;issuer_id = ds_map_find_value(async_load,
"issuerid");<br>
&nbsp;&nbsp;&nbsp;state = ds_map_find_value(async_load,
"state");<br>
&nbsp;&nbsp;&nbsp;date_completed = ds_map_find_value(async_load,
"completeddate");<br>
&nbsp;&nbsp;&nbsp;date_issued = ds_map_find_value(async_load,
"issueddate");<br>
&nbsp;&nbsp;&nbsp;ach_type = ds_map_find_value(async_load,
"type");<br>
&nbsp;&nbsp;&nbsp;ach_ident = ds_map_find_value(async_load,
"identifier");<br>
&nbsp;&nbsp;&nbsp;ach_score = ds_map_find_value(async_load,
"score");<br>
&nbsp;&nbsp;&nbsp;}<span class="notranslate"></span></p></div><br><a name="async_social_facebook" id="async_social_facebook"></a> <label class="collapse" for="twentyeight">Facebook</label> <input id="twentyeight" type="checkbox"><div class="index_list"> Certaines <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/facebook/index.html">fonctions de Facebook</a> vont déclencher un événement social asynchrone et créer un <tt>ds_map</tt> avec des informations spécifiques. Les informations renvoyées dépendent du &quot;type&quot; d’événement appelé. Vous pouvez vérifier cela en lisant la clé &quot;type&quot; dans ds_map, qui sera la chaîne suivante pour un événement Facebook: <br><br><ul><li> &quot; <b>facebook_permission_request</b> &quot; </li></ul><p> Lorsque l&#39;événement est déclenché et est de ce type, il y aura également des clés supplémentaires pouvant être vérifiées: </p><ul><li> &quot; <b>requestId</b> &quot; - La valeur de l&#39;ID de la demande renvoyée par le <tt>facebook_request_xxx_permission()</tt> fonction qui a déclenché l&#39;événement <br><br></li><li> &quot; <b>result</b> &quot; - Ce sera l&#39;une des chaînes suivantes: <br><br><ul><li> &quot; <b>accordé</b> &quot; - la ou les autorisations ont été acceptées par l&#39;utilisateur </li><li> &quot; <b>refusé</b> &quot; - une ou plusieurs autorisations n&#39;ont pas été acceptées par l&#39;utilisateur </li><li> &quot; <b>erreur</b> &quot; - une erreur est survenue </li></ul></li><li> <b>« erreur</b> » - Il contiendra une description de l&#39;erreur, mais il est présent que lorsque « <b>résultat</b> » = « <b>erreur</b> ». </li></ul></div></blockquote></div><br><a name="async_steam" id="async_steam"></a> <label class="collapse"
for="seven"><span class="notranslate">Steam</span></label> <input id="seven" type="checkbox"> <div class="index_list"> Cet événement ne peut être déclenché que par les fonctions de l’ <a href=
"../../../3_scripting/4_gml_reference/steam%20api/index.html">API <span class="notranslate">Steam</span></a> et renverra une <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> stocké dans la variable <tt>async_load</tt>, contenant différentes paires clé / valeur en fonction du rappel de la fonction qui a déclenché l&#39;événement. La carte contiendra toujours la clé &quot; <b>type_événement</b> &quot;, qui peut ensuite être analysée pour rechercher le type de fonction qui a déclenché l&#39;événement et modifier le code requis. <br><br> Lorsqu’il appelle une fonction qui déclenche cet événement, il génère une valeur unique d’identifiant asynchrone qui doit être stockée dans une variable et cochée, en tant que <tt>async_load</tt> La carte contiendra toujours une clé d&#39;identification que vous pourrez ensuite analyser et vérifier que vous répondez au bon événement. En fait, la carte contiendra <i>toujours</i> les clés suivantes, quelle que soit la fonction <span class="notranslate">Steam</span> utilisée pour générer la réponse asynchrone: <br><br><ul><li> &quot; <b>id</b> &quot; - l&#39;ID asynchrone renvoyé par la fonction qui a déclenché l&#39;événement </li><li style="list-style: none"><br></li><li> &quot; <b>result</b> &quot; - Le résultat de l&#39;opération (une valeur réelle). Ce sera soit la constante GML <tt>ugc_result_success</tt> ou un autre nombre réel. Vous devez donc vérifier cette constante pour vous assurer que l&#39;appel a abouti et si, dans le cas contraire, quelque chose n&#39;a pas fonctionné correctement. Le reste des valeurs possibles renvoyées est affiché comme résultat de la valeur <span class="notranslate">Steam</span> &quot;EResult&quot; et vous devriez voir <tt>steamclientpublic.h</tt> dans les en-têtes du SDK pour les 89 valeurs possibles. </li><li style="list-style: none"><br></li><li> &quot; <b>event_type</b> &quot; - Chaîne indiquant le type d&#39;événement (voir ci-dessous pour les détails) </li></ul><blockquote><a name="async_steam_uploading" id=
"async_steam_uploading"></a> <label class="collapse" for=
"twentythree">Téléchargement de données</label> <input id="twentythree" type=
"checkbox"><div class="index_list"> Lorsque vous utilisez les fonctions <span class="notranslate">Steam</span> pour télécharger un classement (soit <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_upload_score.html"><tt>steam_upload_score()</tt></a> ou <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_upload_score_buffer.html"><tt>steam_upload_score_buffer()</tt></a> ) le rendu <tt>ds_map</tt> aura les paires clé / valeur suivantes: <br><br><ul><li> &quot; <b>event_type</b> &quot; - Cette clé contiendra la valeur &quot; <b>leaderboard_upload</b> &quot; </li><li style="list-style: none"><br></li><li> &quot; <b>post_id</b> &quot; - Cette clé doit correspondre à la valeur d&#39;ID renvoyée par la fonction d&#39;appel de téléchargement. </li><li style="list-style: none"><br></li><li> &quot; <b>lb_name</b> &quot; - Cette clé contient le nom du classement sur lequel a été posté. </li><li style="list-style: none"><br></li><li> &quot; <b>success</b> &quot; - Sera 1 si le message a réussi, 0 a échoué </li><li style="list-style: none"><br></li><li> &quot; <b>updated</b> &quot; - Sera 1 si le score du classement a été mis à jour (c.-à-d. si le nouveau score était meilleur) ou 0 sinon </li><li style="list-style: none"><br></li><li> &quot; <b>score</b> &quot; - Cette touche contient le score qui a été posté </li></ul> Vous pouvez en voir des exemples sur les pages pour les fonctions de téléchargement de partition. </div><br><a name="async_steam_downloading" id="async_steam_downloading"></a> <label class="collapse" for="twentyfour">Téléchargement des classements</label> <input id="twentyfour" type="checkbox"><div class="index_list"> Lorsque vous utilisez les fonctions <span class="notranslate">Steam</span> pour télécharger un classement ( <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_download_scores.html"><tt>steam_download_scores()</tt></a>, <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_download_scores_around_user.html"><tt>steam_download_scores_around_user()</tt></a> ou <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_download_friends_scores.html"><tt>steam_download_friends_scores()</tt></a> ) le rendu <tt>ds_map</tt> aura les paires clé / valeur suivantes: <br><br><ul><li> &quot; <b>event_type</b> &quot; - Cette clé contiendra la valeur &quot; <b>leaderboard_download</b> &quot; </li><li style="list-style: none"><br></li><li> &quot; <b>id</b> &quot; - Cette clé doit correspondre à la valeur d&#39;ID renvoyée par la fonction d&#39;appel de téléchargement. </li><li style="list-style: none"><br></li><li> &quot; <b>status</b> &quot; - Statut du rappel, où -1 est égal à un échec ou qu&#39;aucun résultat n&#39;a été renvoyé, et 0 correspond à un succès. </li><li> &quot; <b>lb_name</b> &quot; - Cette clé contient le nom du classement sur lequel a été posté. </li><li style="list-style: none"><br></li><li> &quot; <b>numEntries</b> &quot; - Le nombre de &quot;lignes&quot; de données de classement renvoyées. </li><li style="list-style: none"><br></li><li> &quot; <b>entries</b> &quot; - Chaîne d&#39;objet JSON contenant un autre fichier ds_map contenant la clé &quot;default&quot; (indiquant qu&#39;aucun résultat n&#39;est contenu dans celui-ci) ou la clé &quot;entry&quot;, dont vous pouvez ensuite obtenir la valeur. cette valeur retournée pour &quot;entrées&quot; sera un <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20lists/index.html"><tt>ds_list</tt></a> contenant chacun des rangs du classement, où chaque entrée de la liste fera elle-même référence à un autre <tt>ds_map</tt> qui contiendra les clés &quot;name&quot;, &quot;score&quot; et &quot;rank&quot;, et il pourra également contenir une clé &quot;data&quot; en fonction de la fonction utilisée pour le téléchargement. </li></ul> Nous montrerons un exemple du fonctionnement du téléchargement des données de score en demandant le classement dans le top 10 du classement donné et en analysant ses résultats dans l’ <b>événement <span class="notranslate">Steam</span> Async</b> (pour télécharger des exemples, veuillez vous reporter aux pages de fonctions appropriées). Pour commencer, nous devons demander les partitions avec le code suivant: <br><br><p class="code">score_get = steam_download_scores("Game Scores", 1,
10);<br><span class="notranslate"></span></p><br> Cela enverra une requête au serveur <span class="notranslate">Steam</span> pour les scores du classement &quot;Scores de jeu&quot;, en stockant l&#39; <b>ID asynchrone</b> de la demande dans la variable &quot;score_get&quot;. Cela sera ensuite traité dans l&#39; <b>événement <span class="notranslate">Steam</span> Async</b> de la manière suivante: <br><br><p class="code">var async_id = ds_map_find_value(async_load,
"id");<br>
if async_id == score_get<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;var entries = ds_map_find_value(async_load,
"entries");<br>
&nbsp;&nbsp;&nbsp;var map = json_decode(entries);<br>
&nbsp;&nbsp;&nbsp;if ds_map_exists(map, "default")<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds_map_destroy(map);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var list =
ds_map_find_value(map, "entries");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var len =
ds_list_size(list);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var entry;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(var i = 0; i &lt; len;
i++;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entry =
ds_list_find_value(list, i );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;steam_name[i]
= ds_map_find_value(entry, "name");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;steam_score[i]
= ds_map_find_value(entry, "score");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;steam_rank[i]
= ds_map_find_value(entry, "rank");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(ds_map_exists(entry, "data"))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var
data = ds_map_find_value(entry, "data");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var
buffId = buffer_base64_decode(data);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var
message = buffer_read(buffId, buffer_string);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show_debug_message(
" -- attached message: " + string(message));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer_delete(buffId);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds_map_destroy(entry);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds_list_destroy(list)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;ds_map_destroy(map)<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Ce que nous faisons ici est d’abord vérifier la clé &quot;id&quot; de la spéciale <tt>async_load</tt> carte. Si cette valeur est identique à la valeur de la fonction de rappel d&#39;origine (stockée dans la variable &quot;score_get&quot;), nous continuons alors à traiter les données. La première chose à faire est d’analyser le <tt>async_load</tt> ds_map pour la clé &quot;entrées&quot; qui contiendra un objet JSON contenant les données du classement. Cet objet JSON est ensuite décodé (voir <a href=
"../../../3_scripting/4_gml_reference/file%20handling/json_decode.html"><tt>json_decode</tt></a> ) en tant qu&#39;autre ds_map, et ce nouvel identifiant de carte est stocké dans la variable &quot;map&quot;. <br><br> Cette carte est vérifiée pour la clé &quot;par défaut&quot; et si elle est trouvée, la carte est détruite et l&#39;événement est quitté. Si aucune clé &quot;par défaut&quot; n&#39;est trouvée, le code analysera la carte pour extraire les informations nécessaires sur le classement, en extrayant d&#39;abord une liste ds_list à partir de la clé &quot;entrées&quot; de la ds_map, puis en parcourant chaque entrée de la liste pour obtenez <i>un autre</i> fichier ds_map avec le nom, le score et le rang de chaque entrée. Ces valeurs sont ensuite stockées dans des tableaux, puis nous vérifions s’il existe une clé &quot;data&quot; supplémentaire. S&#39;il y en a (c&#39;est-à-dire que la partition a été chargée avec un paquet de données supplémentaire), nous analysons également cette information et l&#39;envoyons à la console du compilateur à des fins de débogage, avant de détruire le tampon et de continuer ensuite pour détruire la carte. Notez que si la clé &quot;data&quot; est incluse, elle doit être décodée à l&#39;aide de la <a href=
"../../../3_scripting/4_gml_reference/buffers/buffer_base64_decode.html"><tt>buffer_base64_decode()</tt></a> avant de pouvoir le lire correctement. <br><br> Une fois la boucle terminée, la liste des entrées est détruite, de même que la carte à partir de laquelle elle a été prise. Il n&#39;y a pas besoin de détruire le <tt>async_load</tt> ds_map, car cela est géré pour vous par <i><span class="notranslate">GameMaker Studio 2</span></i>. </div><br><a name="async_steam_downloadingugc" id=
"async_steam_downloadingugc"></a> <label class="collapse" for=
"twentyfive">Téléchargement du contenu généré par l&#39;utilisateur (contenu généré par l&#39;utilisateur)</label> <input id="twentyfive" type="checkbox"><div class="index_list"> Lorsque vous utilisez les fonctions <span class="notranslate">Steam</span> pour télécharger du <a href=
"../../../3_scripting/4_gml_reference/steam%20api/user%20generated%20content/index.html">contenu généré par l&#39;utilisateur (UGC)</a>, un certain nombre d&#39;entre elles vont déclencher cet événement. Cependant, chaque fonction générera un <tt>async_load</tt> ds_map avec des paires clé / valeur différentes (bien qu&#39;elles contiennent toujours les clés générales &quot; <b>id</b> &quot;, &quot; <b>result</b> &quot; et &quot; <b>event_type</b> &quot;), veuillez donc consulter la page spécifique à la fonction utilisée pour obtenir des détails et des exemples. </div><br><a name="async_steam_ugc_events" id="async_steam_ugc_events"></a> <label class="collapse" for="twentysix">Événements UGC uniques</label> <input id="twentysix" type="checkbox"><div class="index_list"> L&#39;événement <span class="notranslate">Steam</span> Async peut également être déclenché lorsqu&#39;un utilisateur s&#39;abonne à un élément en dehors du jeu. Par exemple, il quitte un navigateur et s&#39;abonne à un nouvel élément, puis revient au jeu. Dans ces cas, le <tt>async_load</tt> La carte <b>ne</b> contiendra <b>que</b> les détails suivants (et aucune des valeurs par défaut listées en haut de cette page): <br><br><ul><li> &quot; <b>type_événement</b> &quot; - Cette clé contiendra la valeur &quot; <b>ugc_item_installed</b> &quot; </li><li style="list-style: none"><br></li><li> &quot; <b>published_file_id</b> &quot; - l&#39;ID de l&#39;élément UGC nouvellement installé (vous pouvez utiliser la fonction <a href=
"../../../3_scripting/4_gml_reference/steam%20api/user%20generated%20content/steam_ugc_get_item_install_info.html"><tt>steam_ugc_get_item_install_info()</tt></a> pour obtenir le chemin d&#39;accès à l&#39;élément installé) </li><li style="list-style: none"><br></li></ul> L’événement <span class="notranslate">Steam</span> Async peut également être déclenché lorsqu’un élément de l’atelier est souscrit - soit depuis l’application, soit de manière externe à partir du navigateur de l’atelier - et dans ce cas le <tt>async_load</tt> map contiendra les paires clé / valeur suivantes: <br><br><ul><li> &quot; <b>type_événement</b> &quot; - Cette clé contiendra la valeur &quot; <b>ugc_item_subscribed&quot;</b> &quot; </li><li style="list-style: none"><br></li><li> &quot; <b>published_file_id</b> &quot;: Cette clé a l&#39;identifiant de fichier publié du nouvel élément souscrit </li><li style="list-style: none"><br></li></ul> L&#39;événement sera déclenché si un élément n&#39;est pas abonné également, la carte DS contenant les informations suivantes: <br><br><ul><li> &quot; <b>type_événement</b> &quot; - Cette clé contiendra la valeur &quot; <b>ugc_item_unsubscribe&quot;</b> &quot; </li><li style="list-style: none"><br></li><li> &quot; <b>published_file_id</b> &quot;: Cette clé a l&#39;identifiant de fichier publié de l&#39;élément non souscrit </li><li style="list-style: none"><br></li></ul></div></blockquote></div><br><a name="async_system" id="async_system"></a> <label class=
"collapse" for="fourteen">Système</label> <input id="fourteen" type=
"checkbox"><div class="index_list"><p> Cet événement ne peut être déclenché que par un événement de niveau système (tel que la détection d&#39;un gamepad ou la connexion automatique à XBox Live) et il renverra un message. <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> stocké dans la variable <tt>async_load</tt>, contenant différentes paires clé / valeur en fonction de l&#39;événement de niveau système qui a déclenché le rappel. </p><blockquote><a name="async_system_gamepads" id=
"async_system_gamepads"></a> <label class="collapse" for=
"thirtyone">Manettes de jeu</label> <input id="thirtyone" type=
"checkbox"><div class="index_list"><p> Lorsque cet événement est déclenché pour un manette en cours de connexion ou de déconnexion, une des paires clé / valeur suivantes sera renvoyée dans la liste. <tt>async_load</tt> carte: <br><br></p><ul><li> &quot; <b>event_type</b> &quot; - le type d&#39;événement système reçu, qui sera l&#39;une des chaînes suivantes: <br><br><ul><li> &quot; <b>gamepad découvert</b> &quot; - se produit lorsque le système signale qu&#39;un nouveau gamepad a été connecté </li><li> &quot; <b>manette perdue</b> &quot; - se produit lorsque le système a perdu la connexion à une manette de jeu </li></ul></li><li> &quot; <b>pad_index</b> &quot; - l&#39;index du pad ajouté ou supprimé </li></ul><p> Cet événement vous permet maintenant de déplacer toute la logique de vérification de votre manette de jeu de l&#39;événement Step ou d&#39;un événement d&#39;alarme dans l&#39;événement système et de l&#39;exécuter uniquement lorsqu&#39;elle est réellement requise. </p></div><br><a name="async_system_gamepads" id="async_system_gamepads"></a> <label class="collapse" for="thirtythree">Claviers Virtuels</label> <input id="thirtythree" type="checkbox"><div class="index_list"><p> Lorsque cet événement est déclenché pour un clavier virtuel en cours d’ouverture ou de fermeture, les paires clé / valeur suivantes sont renvoyées dans la liste. <tt>async_load</tt> carte: <br><br></p><ul><li> &quot; <b>event_type</b> &quot; - le type d&#39;événement système reçu, qui sera &quot;l&#39; <b>état du clavier virtuel</b> &quot; pour les claviers virtuels. </li><li style="list-style: none"><br></li><li> &quot; <b>screen_height</b> &quot; - la hauteur du clavier virtuel (en pixels). Ce sera 0 si le clavier est invisible. </li><li style="list-style: none"><br></li><li> &quot; <b>keyboard_status</b> &quot; - l&#39;état actuel du clavier, renvoyé sous l&#39;une des chaînes suivantes: <br><br><ul><li> &quot;cache&quot; </li><li> &quot;caché&quot; </li><li> &quot;montrer&quot; </li><li> &quot;visible&quot; </li></ul></li></ul><p> Voir <a href=
"../../../3_scripting/4_gml_reference/controls/virtual%20keys/index.html">ici</a> pour plus d&#39;informations sur le clavier virtuel. </p></div><br><a name="async_system_xboxlive" id="async_system_xboxlive"></a> <label class="collapse" for="thirtytwo">Xbox Live</label> <input id="thirtytwo" type="checkbox"><div class="index_list"><p> L&#39;événement système asynchrone peut être déclenché lorsque vous ciblez la <b><span class="notranslate">XBox One</span></b> à l&#39;aide de l&#39;exportation <b>UWP</b> et en cochant l&#39;option <b>Activer XBox Live</b> dans les <a href=
"../../../2_interface/3_settings/game_options/options_windowsuwp.html">options de jeu UWP</a>. Lorsque vous démarrez <i><span class="notranslate">GameMaker Studio 2</span></i> projet UWP de <i><span class="notranslate">GameMaker Studio 2</span></i> sur lequel Xbox Live est activé, le projet tente automatiquement de se connecter en mode silencieux à Xbox Live. Les résultats de cette tentative de connexion seront renvoyés sous la forme d’une des paires clé / valeur suivantes dans <tt>async_load</tt> carte: </p><ul><li> &quot; <b>event_type</b> &quot; - le type d&#39;événement système reçu, qui sera l&#39;une des chaînes suivantes: <br><br><ul><li> &quot; <b>utilisateur connecté</b> &quot; - la connexion de l&#39;utilisateur silencieux s&#39;est terminée avec succès </li><li> &quot; <b>connexion utilisateur échouée</b> &quot; - la connexion de l&#39;utilisateur silencieux a échoué (dans ce cas, vous pouvez utiliser la fonction <a href=
"../../../3_scripting/4_gml_reference/xbox_live/xboxlive_show_account_picker.html"><tt>xboxlive_show_account_picker()</tt></a> pour que l&#39;utilisateur choisisse un compte avec lequel se connecter) </li><li> &quot; <b>utilisateur déconnecté</b> &quot; - l&#39;utilisateur s&#39;est déconnecté </li></ul></li></ul><p> Pour plus d&#39;informations sur les fonctions spécifiques disponibles pour XBox Live, veuillez cliquer <a href=
"../../../3_scripting/4_gml_reference/xbox_live/index.html">ici</a>. </p></div></blockquote></div></blockquote><p><br></p></div><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> Retour: <a href="../objects.html">L&#39;éditeur d&#39;objets</a> </div><div style="float:right"> Suivant: <a href="draw_events.html">Événements dessinés</a> </div></div></div><h5>© Copyright YoYo Games Ltd. 2018 All Rights Reserved</h5>
<script type="text/javascript">
   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');   ga('create', 'UA-2711665-14', 'auto');   ga('send', 'pageview'); 
</script>
</div>

<script type="text/JavaScript">
var fe = FindFrame("toc", top);
if ((fe != null) && (chmtop.c2wtopf.jstree != null)) {
  if (chmtop.c2wtopf.FITEMS[chmtop.c2wtopf.pagenum] != chmtop.c2wtopf.pageid)
    chmtop.c2wtopf.jstree.OpenTreeNode("source/" + chmtop.c2wtopf.pageid);
}
</script>
</body>
</html>
