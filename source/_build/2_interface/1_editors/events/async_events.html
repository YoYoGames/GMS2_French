<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="keywords" content="online documentation, web online help, web help, chm2web" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="generator" content="chm2web Pro 2.85 (unicode)" />
<title>The Asynchronous Events</title>
<meta http-equiv="X-UA-Compatible" content="IE=9">

<link rel="stylesheet" href="../../../../../files/helpindex.css"
type="text/css">
<link rel="stylesheet" href="../../../../../default.css" type=
"text/css">

<script type="text/JavaScript" src="../../../../../files/supply.js"></script>
<script type="text/JavaScript">
chmtop.c2wtopf.pageid = "_build/2_interface/1_editors/events/async_events.html";
</script>

</head>
<body><script type="text/JavaScript"> 
if (window.name != "content") 
  document.write(" <table width=\"100%\" bgcolor=\"#e1e1e1\"cellspacing=\"2\" cellpadding=\"0\" style=\"border-collapse: collapse; font-family: sans-serif; font-size: 14px; color: #000000; text-decoration: none;  \"> <tr> <td align=\"center\" style=\"border-bottom: 2px solid gray\" > <br>&nbsp;Click <a href=\"../../../../../index.html?page=source%2F_build%2F2_interface%2F1_editors%2Fevents%2Fasync_events.html\">here</a> to show toolbars of the Web Online Help System: <a href=\"../../../../../index.html?page=source%2F_build%2F2_interface%2F1_editors%2Fevents%2Fasync_events.html\">show toolbars</a><br>&nbsp;</td></tr></table><br> "); 
</script>
<!-- !chm2web! --><script type="text/JavaScript">
 if( typeof(chmtop.helpStyle) != 'undefined' ) { var linkNodes = document.getElementsByTagName("link");  for( var i=0; i < linkNodes.length; ++i ) { var link = linkNodes[i];    if( link.href.endsWith("default.css")) {    var style = link.href.replace("default.css", chmtop.helpStyle); document.write('<link id="newstyleLink" rel="stylesheet" href=' + style + ' type="text/css">');    break; } } } 
</script><h2> Les événements asynchrones </h2><div class="body-scroll"><p><img class="center" src="images/editor_objects_async.png" alt="Événements d&#39;éditeur d&#39;objets asynchrones"> Un <b>événement asynchrone</b> est déclenché lorsque <i><span class="notranslate">GameMaker Studio 2</span></i> reçoit un &quot;rappel&quot; d&#39;une source externe, qui peut provenir du Web ou de l&#39;appareil qui exécute votre partie. Fondamentalement, vous dites à <i><span class="notranslate">GameMaker</span> Studio 2</i> de faire quelque chose, comme charger une image, et il va commencer à le faire, mais continuer à faire tout ce qu&#39;il a à faire en attendant son fonctionnement. Ensuite, une fois la requête terminée, un rappel sera envoyé à <i><span class="notranslate">GameMaker Studio 2</span></i> et tous les <b>événements asynchrones</b> définis pour ce type de rappel seront déclenchés. S&#39;il vous plaît noter que les événements asynchrones sont déclenchés pour <i>toutes les</i> instances qui les ont, tout comme les événements clés, de sorte que vous pouvez faire un <tt>http_get</tt> appeler dans une instance, mais avoir l&#39;événement HTTP asynchrone dans un autre pour traiter le rappel. <br></p><div class="note"> <b>REMARQUE</b>: vous devez savoir qu&#39;en raison de la protection XSS dans les navigateurs, les demandes et les tentatives de chargement de ressources à partir de plusieurs domaines sont bloquées et peuvent renvoyer des résultats vides lors de l&#39;utilisation de l&#39;un des événements suivants </div><p><br> Il existe différents types d&#39;événements associés à la catégorie d&#39;événement asynchrone, et ils sont tous expliqués dans les sections suivantes: </p><div class="note"> <b>NOTE:</b> La variable <tt>async_load</tt> qui est mentionné dans les sections suivantes n&#39;est <b>valable que pour ces événements</b>, <tt>ds_map</tt> c&#39;est-à-dire que les points sont créés au début de l&#39;événement, puis de nouveau supprimés à la fin, cette variable étant réinitialisée à la valeur -1 à tous les autres moments. </div><p><br></p><blockquote><a name="async_audio_play" id="async_audio_play"></a> <label class="collapse" for="thirteen">Lecture audio</label> <input id="thirteen" type="checkbox"><div class="index_list"> Cet événement ne peut être déclenché que par les <a href=
"../../../3_scripting/4_gml_reference/audio/audio%20buffers.html">fonctions de lecture de la file d&#39;attente audio.</a> <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> stocké dans la variable <tt>async_load</tt>, contenant différentes paires clé / valeur relatives à la file d&#39;attente audio ayant déclenché l&#39;événement. L&#39;événement est déclenché lorsque vous avez sélectionné une file d&#39;attente audio à lire et qu&#39;un tampon dans cette file d&#39;attente audio a fini de jouer. <br><br> Les clés suivantes seront disponibles dans le fichier ds_map: <br><br><ul><li> &quot; <b>queue_id</b> &quot; - l&#39;index de file d&#39;attente de la file d&#39;attente qui a fini de jouer, tel que renvoyé par la fonction <a href=
"../../../3_scripting/4_gml_reference/audio/audio_create_play_queue.html"><tt>audio_create_play_queue</tt></a>. </li><li> &quot; <b>buffer_id</b> &quot; - l&#39;identifiant du tampon qui n&#39;est plus en cours de lecture </li><li> &quot; <b>queue_shutdown</b> &quot; - ceci est mis à 0 pendant la lecture normale et à 1 quand l&#39;événement est reçu parce que <a href=
"../../../3_scripting/4_gml_reference/audio/audio_free_play_queue.html"><tt>audio_free_play_queue</tt></a> a été appelé. Lorsque ce paramètre est défini sur 1, vous ne souhaitez pas mettre en attente d&#39;autres données. </li></ul> Comme une file d&#39;attente audio peut être créée à partir de plusieurs tampons, cet événement peut être déclenché plusieurs fois pour une file d&#39;attente lorsque la fin de chaque section d&#39;audio bufférisée est atteinte, d&#39;où la clé &quot;buffer_id&quot;. <br><br><div class="note"> <b>NOTE:</b> La variable <tt>async_load</tt> n&#39;est valide que dans les événements asynchrones, <tt>ds_map</tt> c&#39;est-à-dire que les points sont créés au début de l&#39;événement, puis supprimés à la fin, cette variable étant réinitialisée à la valeur -1. Cependant, toutes les autres structures de données créées à partir de l&#39;événement <b>doivent être nettoyées à l&#39;aide des fonctions appropriées</b>. </div><br> Dans l&#39;exemple d&#39;utilisation donné ci-dessous, nous allons créer une file d&#39;attente audio avec 10 sons audio tamponnés, puis lire la file d&#39;attente: <br><br><p class="code">audio_queue = audio_create_play_queue(buffer_s16,
11052, audio_mono);<br>
for (var i = 0; i &lt; 10; i++;)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;audio_queue_sound(audio_queue, audio_buffer[i],
0, buffer_get_size(audio_buffer[i]));<br>
&nbsp;&nbsp;&nbsp;}<br>
audio_play_sound(audio_queue, 0, true);<br><span class="notranslate"></span></p><br> Chaque étape du jeu maintenant que l&#39;enregistrement est détecté déclenchera un événement d&#39;enregistrement audio asynchrone où vous pourrez gérer quelque chose comme ceci: <br><br><p class="code">var queue = async_load[? "queue_id"];<br>
var num = 0;<br>
if queue = audio_queue<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;for (var i = 0; i &lt; 10; i++;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if async_load[? "buffer_id"] ==
audio_buffer[i]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer_seek(audio_buffer[i],
buffer_seek_start, 0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num = i;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;if num == 9<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;audio_stop_sound(audio_queue);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;audio_free_play_queue(audio_queue);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Ici, nous vérifions l&#39;ID de la file d&#39;attente et, si c&#39;est celui que nous voulons, nous vérifions ensuite l&#39;ID de la mémoire tampon pour voir quel tampon a été lu. Nous définissons ensuite un var local à cette valeur d&#39;index pour le vérifier plus tard et remettons le tampon au début pour ce son. Une fois que notre variable locale atteint 9, indiquant que la file d&#39;attente est terminée, nous arrêtons la lecture du son et libérons la file d&#39;attente. </div><br><a name="async_audio_rec" id="async_audio_rec"></a> <label class=
"collapse" for="twelve">Enregistrement audio</label> <input id="twelve"
type="checkbox"><div class="index_list"> Cet événement ne peut être déclenché que par <a href=
"../../../3_scripting/4_gml_reference/audio/audio_start_recording.html"><tt>audio_start_recording()</tt></a> fonction et retournera un <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> stocké dans la variable <tt>async_load</tt>, contenant différentes paires clé / valeur en fonction du rappel de la fonction qui a déclenché l&#39;événement. <br><br> Les clés suivantes seront disponibles dans le fichier ds_map: <br><br><ul><li> &quot; <b>buffer_id</b> &quot; - l&#39;identifiant du tampon temporaire que vous pouvez utiliser pour récupérer les données audio </li><li> &quot; <b>channel_index</b> &quot; - l&#39;index du canal d&#39;enregistrement renvoyé par la fonction d&#39;appel à laquelle proviennent ces données </li><li> &quot; <b>data_len</b> &quot; - la longueur des données (en octets) que vous avez reçues </li></ul><div class="note"> <b>NOTE:</b> Comme mentionné au début de cette page, la variable <tt>async_load</tt> n&#39;est valide que dans les événements asynchrones, <tt>ds_map</tt> c&#39;est-à-dire que les points sont créés au début de l&#39;événement, puis supprimés à la fin. Cependant, notez que le tampon temporaire dans lequel tous les fichiers audio sont stockés avec la carte sera également supprimé à la fin de l&#39;événement. Vous devez donc le copier dans un tampon personnalisé si vous souhaitez le conserver pour une utilisation ultérieure. </div><br> Dans l&#39;exemple d&#39;utilisation ci-dessous, nous allons créer un tampon personnalisé pour stocker notre audio enregistré, et également définir notre jeu pour enregistrer à partir de la source d&#39;entrée 0: <br><br><p class="code">channel_index = audio_start_recording(0);<br>
audio_buffer = buffer_create(len, buffer_fast, 1);<br><span class="notranslate"></span></p><br> Chaque étape du jeu maintenant que l&#39;enregistrement est détecté déclenchera un événement d&#39;enregistrement audio asynchrone où vous pourrez gérer quelque chose comme ceci: <br><br><p class="code">var channel = async_load[? "channel_index"];<br>
if channel == channel_index<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;len = async_load[? "data_len"];<br>
&nbsp;&nbsp;&nbsp;buffer_copy(async_load[? "buffer_id"], 0, len,
audio_buffer, 0);<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Ici, nous vérifions simplement la clé &quot;channel_index&quot; pour nous assurer qu&#39;elle correspond à la valeur retournée lorsque nous avons commencé l&#39;enregistrement, et si c&#39;est le cas, nous copions le contenu du tampon temporaire créé pour cet événement dans notre tampon personnalisé. Après cela, vous pouvez faire ce que vous voulez avec le tampon personnalisé - vous pouvez le lire en utilisant les fonctions audio du tampon dédié, vous pouvez le traiter et l&#39;envoyer sur le réseau, vous pouvez l&#39;enregistrer sur le disque... Une fois votre audio enregistré dans un tampon, vous pouvez faire pratiquement tout ce que vous voulez. </div><br><a name="async_cloud" id="async_cloud"></a> <label class="collapse"
for="five">Nuage</label> <input id="five" type="checkbox"><div class="index_list"> L&#39;événement Cloud est celui qui est déclenché par le rappel de l&#39;un des <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/index.html"><tt>cloud_</tt> fonctions</a>, comme <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/cloud_synchronise.html"><tt>cloud_synchronise</tt></a>. Il génère en fait un <tt>ds_map</tt> Ceci est exclusif à cet événement et est stocké dans la variable spéciale <b>async_load</b> (veuillez voir les fonctions individuelles pour les exemples de code qui expliquent l&#39;utilisation de cet événement plus en détail). Cette structure ds_map a la structure suivante: <br><br><ul><li> <b>&quot;status&quot;:</b> Ceci contient le code d&#39;état, où une valeur négative indique une erreur, dont une description sera contenue dans &quot;errorString&quot;. Une valeur de 0 (ou une valeur positive) indique un succès (voir ci-dessous pour les valeurs exactes), et la chaîne &quot;resultString&quot; contiendra les données renvoyées ou un message de réussite. </li><li style="list-style: none"><br></li><li> <b>&quot;id&quot;:</b> L&#39;identifiant qui a été renvoyé par la fonction appelée. Si vous déclenchez une série de <tt>cloud_</tt> demandes, vous devez alors savoir à laquelle vous obtenez la réponse, et ainsi vous utiliseriez cette valeur pour comparer à la valeur que vous avez stockée lorsque vous avez envoyé la demande pour trouver la bonne. </li><li style="list-style: none"><br></li><li> <b>&quot;description&quot;:</b> La description du dernier fichier téléchargé. </li><li style="list-style: none"><br></li><li> <b>&quot;resultString&quot;:</b> Ceci contient une chaîne qui est le blob de données renvoyé du nuage. </li><li style="list-style: none"><br></li><li> <b>&quot;errorString&quot;:</b> renvoie une chaîne d&#39;erreur pour toute erreur. </li></ul> La signification exacte de l&#39;entrée de la carte &quot;status&quot; retournée est expliquée dans le tableau suivant: <div class="compat"><table><tr><th> Valeur du statut </th><th> errorString / resultString </th><th> La description </th></tr><tr><td> <span class="notranslate">-1</span> </td> <td> errorString = &quot;Non connecté à &lt;SERVICE&gt;&quot; </td><td> <span class="notranslate">You have not successfully logged in to the given Cloud Service</span> </td> </tr><tr class="alt"><td> <span class="notranslate">0</span> </td> <td> resultString = données récupérées </td><td> <span class="notranslate">New game data downloaded from the cloud (following a cloud_synchronise call)</span> </td> </tr><tr><td> <span class="notranslate">1</span> </td> <td> resultString = &quot;AlreadySynchronized&quot; </td><td> <span class="notranslate">No new data since you last called cloud_synchronise</span> </td> </tr><tr class="alt"><td> <span class="notranslate">2</span> </td> <td> resultString = &quot;ConflictDeferral&quot; </td><td> <span class="notranslate">A conflict was encountered, but the gamer chose to ignore it</span> </td> </tr><tr><td> <span class="notranslate">3</span> </td> <td> resultString = &quot;GameUploadSuccess&quot; </td><td> <span class="notranslate">data from <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/cloud_string_save.html"><tt>cloud_string_save</tt></a> or <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/cloud_file_save.html"><tt>cloud_file_save</tt></a> was successfully uploaded to the cloud</span> </td> </tr><tr class="alt"><td> <span class="notranslate">-n</span> </td> <td> errorString = Description de l&#39;erreur </td><td> <span class="notranslate">Any other negative number means a synchronisation failure</span> </td> </tr></table></div></div><br><a name="async_dialogue" id="async_dialogue"></a> <label class=
"collapse" for="three">Dialogue</label> <input id="three" type=
"checkbox"><div class="index_list"> Comme les événements ci-dessus, l&#39;événement <b>Dialogues</b> est uniquement déclenché lorsqu&#39;il reçoit un rappel de l&#39;une des fonctions utilisateur asynchrones spéciales, comme <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/get_login_async.html"><tt>get_login_async()</tt></a> (Veuillez voir cette fonction pour un exemple de code étendu de la façon dont cet événement est utilisé). Ces événements sont ceux qui demandent un type d&#39;entrée de l&#39;utilisateur, qui peut être un nom, des informations de connexion, un numéro ou une couleur etc... Comme la plupart des appareils n&#39;aiment pas être assis dans une boucle en attente d&#39;une réponse, ils doivent être asynchrone et <i><span class="notranslate">GameMaker Studio 2</span></i> continuera à fonctionner en arrière-plan pendant que ces fonctions ont un dialogue ouvert et jusqu&#39;à ce qu&#39;ils obtiennent l&#39;entrée utilisateur requise qui déclenche cet événement. <br><br> Encore une fois, un <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> est renvoyé avec l&#39;ID <b>contenu</b> dans la variable spéciale <b>async_load</b>. Les valeurs contenues dans cette carte dépendent de la fonction utilisée, et vous devriez consulter les entrées individuelles pour chaque fonction dans ce manuel pour plus de détails. </div><br><a name="async_http" id="async_http"></a> <label class="collapse"
for="two">HTTP</label> <input id="two" type="checkbox"><div class="index_list"> L&#39;événement HTTP est celui qui est déclenché par le rappel de l&#39;un des <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/index.html"><tt>http_</tt> fonctions</a>, comme <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/http_post_string.html"><tt>http_post_string</tt></a>. Il génère en fait un <tt>ds_map</tt> (parfois appelé &quot;dictionnaire&quot;) exclusif à cet événement et stocké dans la variable spéciale <tt>async_load</tt> (Veuillez voir les fonctions individuelles pour les exemples de code qui expliquent l&#39;utilisation de cet événement plus en détail). Ce <tt>ds_map</tt> a la structure suivante: <br><br><ul><li> <b>&quot;id&quot;:</b> L&#39;identifiant qui a été renvoyé par la commande. Si vous déclenchez une série de <tt>http_</tt> demandes, vous devez alors savoir à laquelle vous obtenez la réponse, et ainsi vous utiliseriez cette valeur pour comparer à la valeur que vous avez stockée lorsque vous avez envoyé la demande pour trouver la bonne. </li><li style="list-style: none"><br></li><li> <b>&quot;status&quot;:</b> Renvoie une valeur inférieure à 0 pour une erreur, 0 pour la réussite et 1 si le contenu est en cours de téléchargement. </li><li style="list-style: none"><br></li><li> <b>&quot;result&quot;:</b> Les données reçues (chaîne seulement), ou le chemin vers le fichier téléchargé si vous avez utilisé <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/http_get_file.html"><tt>http_get_file()</tt></a>. </li><li style="list-style: none"><br></li><li> <b>&quot;url&quot;:</b> L&#39;URL complète que vous avez demandée. </li><li style="list-style: none"><br></li><li> <b>&quot;http_status&quot;:</b> le code d&#39;état brut http (si disponible). Cela renvoie le code d&#39;état Web standard pour la plupart des navigateurs, par exemple: 304 pour &quot;Non modifié&quot; ou 204 pour &quot;Aucun contenu&quot;, etc... </li></ul> C&#39;est pour quand vous utilisez le <tt>http_post_string()</tt> fonction, mais chacun des <tt>http_</tt> Les fonctions peuvent renvoyer une carte légèrement différente, veuillez donc vous référer à l&#39;entrée manuelle de chaque fonction pour connaître les données précises qui lui sont retournées. <br><br><div class="note"> <b>NOTE:</b> Comme <tt>async_load</tt> crée un <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a>, ces fonctions sont particulièrement utiles lorsqu&#39;elles sont associées à <a href=
"../../../3_scripting/4_gml_reference/file%20handling/json_encode.html"><tt>json_encode</tt></a> et <a href=
"../../../3_scripting/4_gml_reference/file%20handling/json_decode.html"><tt>json_decode</tt></a> les fonctions. </div><br><br> Il pourrait également y avoir des données supplémentaires fournies par cette carte si vous avez demandé des fichiers à télécharger. Dans ce cas, le &quot;status&quot; aura une valeur de 1 et le ds_map contiendra ces clés supplémentaires: <br><br><ul><li> <b>&quot;contentLength&quot;:</b> C&#39;est la taille du fichier que le serveur web a dit que vous devriez recevoir (peut-être -1 si le serveur ne retourne pas ces données). </li><li style="list-style: none"><br></li><li> <b>&quot;sizeDownloaded&quot;:</b> La taille des données qui ont déjà été téléchargées. </li></ul> Notez que l&#39;événement <i>ne</i> sera <i>pas</i> déclenché pour chaque paquet de données reçu, mais qu&#39;il sera mis à jour à tout moment pendant le téléchargement dans la boucle de jeu principale. Notez également que cette fonctionnalité est actuellement disponible uniquement pour les <i>plates-</i> formes cibles <i>Windows</i> normales. </div><br><a name="async_iap" id="async_iap"></a> <label class="collapse"
for="four">IAP</label> <input id="four" type="checkbox"><div class="index_list"> Cet événement peut uniquement être déclenché lorsque vous avez activé les <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/index.html">achats In App</a> pour votre jeu. Si vous avez ajouté cette fonctionnalité, l&#39;événement sera déclenché dans les circonstances suivantes: <br><br><ul><li> L&#39;état du magasin change. </li><li> Un produit (ou des produits) ont été activés. </li><li> Le produit et les achats ont été restaurés. </li><li> Un produit a été acheté. </li><li> Un produit a été consommé. </li></ul> L&#39;événement créera toujours un spécial <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> avec un ID d&#39;index stocké dans la variable intégrée <tt><b>iap_data</b></tt>. Cette carte contiendra <i>toujours</i> la clé &quot; <b>type</b> &quot;, qui contiendra l&#39;une des valeurs constantes suivantes: <div class="compat"><table><tr><th> Constant </th><th> La description </th></tr><tr><td> <span class="notranslate">iap_ev_storeload</span> </td> <td> Ceci est déclenché lorsqu&#39;une modification est détectée dans le magasin de la plateforme cible. </td></tr><tr class="alt"><td> <span class="notranslate">iap_ev_product</span> </td> <td> Cet événement est déclenché lorsqu&#39;un produit est activé et contiendra des informations supplémentaires sur le produit. </td></tr><tr><td> <span class="notranslate">iap_ev_restore</span> </td> <td> Cet événement est uniquement déclenché lorsque vous utilisez le <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_restore_all.html"><tt>iap_restore_all</tt></a> fonction. </td></tr><tr class="alt"><td> <span class="notranslate">iap_ev_purchase</span> </td> <td> Lorsqu&#39;un achat a été effectué, cet événement est déclenché. </td></tr><tr><td> <span class="notranslate">iap_ev_consume</span> </td> <td> Lorsque vous utilisez la fonction <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_consume.html"><tt>iap_consume</tt></a> cela déclenche cet événement. </td></tr></table></div><p><br><br> Chacun de ces &quot;types&quot; d&#39;événements possibles ajoutera des clés supplémentaires à <tt>iap_data</tt> ds_map, qui peut ensuite être analysé pour obtenir les informations d&#39;achat ou de produit nécessaires. Le contenu exact de <tt>iap_data</tt> Les cartes sont listées ci-dessous pour chaque événement &quot;type&quot;. </p><blockquote><a name="iap_ev_storeload" id="iap_ev_storeload"></a> <label class="collapse" for="fifteen">iap_ev_storeload</label> <input id="fifteen" type="checkbox"><div class="index_list"> Lorsque vous activez vos achats, votre jeu tente de contacter le magasin cible, ce qui déclenche cet événement dans le processus. le <tt>iap_data</tt> map aura alors une clé additionnelle &quot; <b>status&quot;</b>, qui aura l&#39;une des constantes suivantes comme valeur: <br><br><div class="compat"><table><tr><th> Constant </th><th> La description </th></tr><tr><td> <span class="notranslate">iap_storeload_ok</span> </td> <td> Le magasin a été contacté et la connexion est bonne. </td></tr><tr class="alt"><td> <span class="notranslate">iap_storeload_failed</span> </td> <td> Il y a eu une erreur de connexion ou, pour une raison quelconque, le magasin n&#39;est pas disponible. </td></tr></table></div></div><br><a name="iap_ev_product" id="iap_ev_product"></a> <label class=
"collapse" for="sixteen">iap_ev_product</label> <input id="sixteen"
type="checkbox"><div class="index_list"> Tous les achats activés déclencheront cet événement &quot;type&quot;, mais seulement une fois par achat, donc si vous avez activé dix produits vous devriez vous attendre à ce que cet événement se déclenche dix fois. Si vous avez reçu cet événement, le <tt>iap_data</tt> ds_map contiendra la clé supplémentaire &quot; <b>index</b> &quot; qui contient la <b>chaîne</b> unique d&#39; <b>ID de produit</b> pour le produit en cours d&#39;activation. Vous pouvez ensuite utiliser la fonction <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_product_details.html"><tt>iap_product_details</tt></a> avec ce produit ID pour obtenir plus d&#39;informations. <br><br><div class="note"> <b>REMARQUE:</b> Google Play ( <span class="notranslate">Android</span> ) ne peut demander des détails que pour les produits 20 à la fois, ce qui peut entraîner des temps de chargement assez longs pour les applications comportant un nombre important de produits. </div></div><br><a name="iap_ev_restore" id="iap_ev_restore"></a> <label class=
"collapse" for="seventeen">iap_ev_restore</label> <input id=
"seventeen" type="checkbox"><div class="index_list"> Lorsque vous appelez la fonction <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_restore_all.html"><tt>iap_restore_all</tt></a> il déclenchera cet événement, en ajoutant une clé &quot; <b>result</b> &quot; au <tt>iap_data</tt> ds_map. Cette clé tiendra soit <tt>true</tt> ou <tt>false</tt> pour indiquer si les données d&#39;achat ont été correctement restaurées à partir du magasin cible. </div><br><a name="iap_ev_purchase" id="iap_ev_purchase"></a> <label class=
"collapse" for="eighteen">iap_ev_purchase</label> <input id=
"eighteen" type="checkbox"><div class="index_list"> En demandant un achat en utilisant la fonction <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_acquire.html"><tt>iap_acquire</tt></a> ce type d&#39;événement sera déclenché. le <tt>iap_data</tt> ds_map aura la clé supplémentaire &quot; <b>index</b> &quot; qui contient la valeur unique d&#39; <b>identifiant d&#39;achat</b> pour le produit acheté. Vous pouvez ensuite utiliser la fonction <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_purchase_details.html"><tt>iap_purchase_details</tt></a> avec cet ID d&#39;achat pour obtenir plus d&#39;informations. <br><br><div class="note"> <b>REMARQUE:</b> Si le produit acheté est consommable, il <b>doit être utilisé en</b> utilisant <tt>iap_consume</tt> avant qu&#39;un nouvel achat puisse être effectué. </div></div><br><a name="iap_ev_consume" id="iap_ev_consume"></a> <label class=
"collapse" for="nineteen">iap_ev_consume</label> <input id=
"nineteen" type="checkbox"><div class="index_list"> Lors de l&#39;utilisation de la fonction <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_consume.html"><tt>iap_consume</tt></a> ce type d&#39;événement sera déclenché. le <tt>iap_data</tt> ds_map aura la clé additionnelle &quot; <b>product</b> &quot; qui contient la chaîne unique d&#39; <b>identifiant de produit</b> pour le produit consommé. </div></blockquote></div><br><a name="async_image_loaded" id="async_image_loaded"></a> <label class="collapse" for="one">Image chargée</label> <input id=
"one" type="checkbox"><div class="index_list"> Cet événement est déclenché lorsque vous chargez une image dans <i><span class="notranslate">GameMaker Studio 2</span></i>, à condition que vous ayez utilisé une URL ou un chemin d&#39;accès valide avec la fonction de fichier de chargement applicable. Supposons par exemple que vous souhaitiez charger une image d&#39;image-objet et que vous ne modifiiez l&#39;image-objet en cours pour l&#39;instance que lorsqu&#39;elle est chargée. Eh bien, vous auriez quelque chose comme ça dans un événement de création ou un événement d&#39;alarme (par exemple): <p class="code">spr =
sprite_add("http://www.angusgames.com/game/background1.png", 0,
false, false, 0, 0);<span class="notranslate"></span></p><p> Cela va maintenant commencer à charger l&#39;image dans l&#39;appareil ou dans le navigateur, mais cela <i>ne</i> bloquera <i>pas</i> <i><span class="notranslate">GameMaker Studio 2</span></i> pendant qu&#39;il attend le chargement du fichier. Au lieu de cela, <i><span class="notranslate">GameMaker</span> Studio 2</i> continuera à fonctionner normalement jusqu&#39;à ce que l&#39;image soit chargée et le rappel déclenche l&#39;événement <b>Image Loaded</b>, où un <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> est créé et stocké dans la variable spéciale <b>async_load</b>. La carte contient les informations suivantes: </p><ul><li> <b>&quot;filename&quot;:</b> Le chemin complet du fichier que vous avez demandé. </li><li style="list-style: none"><br></li><li> <b>&quot;id&quot;:</b> L&#39;ID de la ressource que vous avez chargée. Ce sera la même chose que la variable à laquelle vous avez affecté la ressource. </li><li style="list-style: none"><br></li><li> <b>&quot;status&quot;:</b> Renvoie une valeur inférieure à 0 pour une erreur. </li></ul><p> Vous devez ensuite affecter l&#39;image nouvellement chargée à un arrière-plan dans cet événement. Ce qui précède est également vrai pour les sprites et les sons, avec un ds_map étant généré pour chacune de ces ressources comme indiqué ci-dessus, et l&#39;exemple de code suivant montre comment les informations retournées seraient utilisées dans cet événement: </p><p class="code">if ds_map_find_value(async_load, "id") == spr<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if ds_map_find_value(async_load, "status") &gt;=
0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprite_index = spr<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><p> Le code ci-dessus va d&#39;abord vérifier l&#39;identifiant de la carte ds_map qui a été créée, puis vérifier l&#39;état du rappel. Si la valeur est supérieure ou égale à 0 (succès de la signalisation), le résultat du rappel sera utilisé pour définir l&#39;index d&#39;arrière-plan de l&#39;image nouvellement chargée. </p></div><br><a name="async_networking" id="async_networking"></a> <label class=
"collapse" for="six">La mise en réseau</label> <input id="six" type=
"checkbox"><div class="index_list"> L&#39;événement de mise en réseau est celui qui sera déclenché par tout trafic réseau entrant et est lié aux <a href=
"../../../3_scripting/4_gml_reference/networking/index.html">fonctions de réseau</a>. Cet événement génère un <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html">fichier ds_map</a> spécial exclusif à cet événement et stocké dans la variable spéciale <b>async_load</b>. Ce <tt>ds_map</tt> contiendra des informations différentes en fonction du type d&#39;événement réseau qui l&#39;a généré. <blockquote><a name="async_network_common" id=
"async_network_common"></a> <label class="collapse" for=
"twenty">Événements de mise en réseau courants</label> <input id="twenty" type=
"checkbox"><div class="index_list"> Les clés suivantes sont communes à toutes les fonctions réseau reçues et seront toujours présentes dans le <tt>async_load</tt> carte: <br><br><ul><li> <b>&quot;type&quot;:</b> L&#39;une des constantes répertoriées ci-dessous sera sa valeur de retour et désignera le type d&#39;événement réseau. </li><li style="list-style: none"><br></li><li> <b>&quot;id&quot;: l&#39;</b> identifiant du socket (un nombre réel, renvoyé par la fonction <a href=
"../../../3_scripting/4_gml_reference/networking/network_create_server.html">network_create_server</a> ou <a href=
"../../../3_scripting/4_gml_reference/networking/network_create_socket.html">network_create_socket</a> ) qui reçoit l&#39;événement. Dans la plupart des cas, l&#39;ID de socket retournée est l&#39;ID de TCP ou socket UDP qui a déclenché l&#39;événement, si l&#39;événement est déclenché dans un <i>serveur</i> et il est un événement de données (voir ci - dessous) puis l&#39;ID de socket est celle du <i>client</i> qui a envoyé le Les données. </li><li style="list-style: none"><br></li><li> <b>&quot;ip&quot;:</b> L&#39;adresse IP du socket (sous forme de chaîne). </li><li style="list-style: none"><br></li><li> <b>&quot;port&quot;:</b> Le port associé à l&#39;adresse IP (utile pour travailler avec UDP). </li></ul> Les valeurs de retour possibles pour la clé &quot;type&quot; peuvent être l&#39;une des trois constantes listées ci-dessous: <div class="compat"><table><tr><th> Constant </th><th> La description </th></tr><tr><td> <span class="notranslate">network_type_connect</span> </td> <td> L&#39;événement a été déclenché par une connexion. </td></tr><tr class="alt"><td> <span class="notranslate">network_type_disconnect</span> </td> <td> L&#39;événement a été déclenché par une déconnexion. </td></tr><tr><td> <span class="notranslate">network_type_data</span> </td> <td> L&#39;événement a été déclenché par des données entrantes. </td></tr><tr class="alt"><td> <span class="notranslate">network_type_non_blocking_connect</span> </td> <td> L&#39;événement a été déclenché par une connexion configurée comme non bloquante (vous pouvez utiliser la fonction <a href=
"../../../3_scripting/4_gml_reference/networking/network_set_config.html"><tt>network_set_config()</tt></a> pour ça). </td></tr></table></div></div><br><a name="async_network_connect" id="async_network_connect"></a> <label class="collapse" for="twentyone">Connexion / déconnexion</label> <input id="twentyone" type="checkbox"><div class="index_list"> Lorsque vous avez un événement du type <tt>network_type_connect</tt>, <tt>network_type_non_blocking_connect</tt> ou <tt>network_type_disconnect</tt>, la <tt>async_load</tt> La carte aura les clés supplémentaires suivantes: <br><br><ul><li> <b>&quot;socket&quot;:</b> Cette touche contiendra l&#39;identifiant du socket de connexion / déconnexion. </li><li style="list-style: none"><br></li><li> <b>&quot;réussi&quot;:</b> Cette clé sera soit 0 ou 1, où 0 signifie que la connexion a expiré et 1 signifie qu&#39;elle a réussi et que le socket est prêt à être utilisé. </li></ul> Il est à noter que l&#39;événement de mise en réseau ne se déclenche pas dans les <i>clients</i> lorsque le <i>serveur se</i> déconnecte, et qu&#39;aucun des <tt>network_type_*</tt> les événements seront déclenchés dans les clients lorsque le serveur auquel ils sont connectés se déconnecte, même si la connexion est basée sur TCP. </div><br><a name="async_network_receive" id="async_network_receive"></a> <label class="collapse" for="twentytwo">Réception de données</label> <input id="twentytwo" type="checkbox"><div class="index_list"> Lorsque vous avez un <tt>network_type_data</tt> type événement, ce qui signifie que votre réseau a reçu des données, la carte créée aura les clés suivantes: <br><br><ul><li> <b>&quot;buffer&quot;:</b> C&#39;est l&#39;unique &quot;buffer id&quot; qui est généré par l&#39;événement. Un tampon de type &quot;grow&quot;, octet aligné sur 1, est créé pour contenir l&#39;identifiant qui doit être stocké dans une variable et utilisé pour tous les appels de fonction supplémentaires au tampon <i><b>dans cet événement</b></i>. Tout comme le <tt>async_load</tt> map, le tampon créé est automatiquement supprimé de la mémoire à la fin de cet événement. Pour plus d&#39;informations sur les tampons, reportez-vous à la section <a href=
"../../../3_scripting/4_gml_reference/buffers/index.html">Référence - Tampons</a> </li><li style="list-style: none"><br></li><li> <b>&quot;size&quot;:</b> Il s&#39;agit de la taille (en octets) des données du tampon en cours de réception. </li></ul><div class="note"> <b>Remarque:</b> le tampon créé est <b>uniquement valide dans ces événements</b> et sera libéré lorsque l&#39;événement est terminé. </div></div></blockquote></div><br><a name="async_push" id="async_push"></a> <label class="collapse"
for="ten">Notification push</label> <input id="ten" type=
"checkbox"><div class="index_list"> L&#39;événement de notification push est celui qui est déclenché par le rappel à partir <b>des notifications push</b> sur le système d&#39;exploitation de l&#39;appareil, soit à partir d&#39;une source locale en utilisant la fonction <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/push_local_notification.html"><tt>push_local_notification</tt></a>, ou à partir d&#39;une source distante (c&#39;est-à-dire: votre serveur). Il génère un <tt>ds_map</tt> Ceci est exclusif à cet événement et est stocké dans la variable spéciale <b>async_load</b> (voir les fonctions individuelles qui déclenchent des événements asynchrones pour des exemples de code expliquant plus en détail l&#39;utilisation de cet événement). Ce <tt>ds_map</tt> a les clés suivantes: <br><br><ul><li> <b>&quot;type&quot;: La</b> valeur peut être &quot;locale&quot; pour une notification locale de périphérique, &quot;distante&quot; pour une notification à distance, ou &quot;enregistrer&quot; pour l&#39;enregistrement de notification à distance. </li><li> <b>&quot;status&quot;: La</b> valeur sera &quot;1&quot; pour le succès ou &quot;0&quot; pour une erreur. </li></ul> Il peut y avoir des entrées de clé supplémentaires basées sur le &quot;type&quot; renvoyé et la valeur &quot;status&quot;. Pour &quot;status&quot;, si une erreur a été retournée (&quot;0&quot;), alors vous aurez aussi la clé suivante: <br><br><ul><li> <b>&quot;error&quot;:</b> Contient les détails de l&#39;erreur reçue. </li></ul> Si la valeur &quot;status&quot; est 1 (ie: pas d&#39;erreur) alors le <tt>ds_map</tt> contiendra les valeurs supplémentaires suivantes, en fonction de la valeur de la clé &quot;type&quot;: <br><br><ul><li> <b>&quot;reg_id&quot;:</b> Si le &quot;type&quot; reçu était &quot;register&quot;, alors cette touche contiendra l&#39;identifiant d&#39;enregistrement de l&#39;appareil pour les notifications à distance. </li><li> <b>&quot;data&quot;:</b> Si le &quot;type&quot; reçu était &quot;local&quot; ou &quot;distant&quot;, alors cette clé contiendra la charge utile de la chaîne que vous avez définie lorsque vous avez appelé la fonction de notification. </li></ul> Pour mieux comprendre cela, nous avons créé un petit extrait d&#39;exemple ci-dessous que vous pouvez consulter. Dans cet exemple, nous enverrons une notification push locale en utilisant le code suivant: <br><br><p class="code">var fireTime =
date_inc_day(date_current_datetime(), 1);<br>
var data = "daily_reward";<br>
push_local_notification(fireTime, "Ahoy!", "Catch The Haggis Has A
Present", data);<br><span class="notranslate"></span></p><br> Ceci mettra un temporisateur pour &quot;pousser&quot; une notification à l&#39;appareil quand un jour s&#39;est écoulé. Quand le jour est terminé, si votre jeu est en arrière-plan ou non, une notification sera montrée à l&#39;utilisateur avec le titre et le message donnés (sur iOS, le nom du jeu est affiché et le titre est ignoré), puis un événement de notification push asynchrone sera appelé. Notez que si le jeu est au premier plan lorsque l&#39;heure de la notification arrive, il <i>ne</i> sera <i>pas</i> affiché, mais l&#39;événement asynchrone <b>sera toujours déclenché</b>. Dans l&#39;événement lui-même, vous gérer le rappel quelque chose comme ceci: <br><br><p class="code">var type = ds_map_find_value(async_load,
"type");<br>
var status = ds_map_find_value(async_load, "status");<br>
if status == 0<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;//error of some kind<br>
&nbsp;&nbsp;&nbsp;var error = ds_map_find_value(async_load,
"error");<br>
&nbsp;&nbsp;&nbsp;show_debug_message("error=" + string(error));<br>
&nbsp;&nbsp;&nbsp;}<br>
else<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if type == "register"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;global.reg_id =
ds_map_find_value(async_load, "reg_id");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var data =
ds_map_find_value(async_load, "data");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if data ==
"daily_reward"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;global.Gold
+= 1000;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p></div><br><a name="async_saveload" id="async_saveload"></a> <label class=
"collapse" for="eleven">Sauvegarder charger</label> <input id="eleven"
type="checkbox"><div class="index_list"> Cet événement sera déclenché par certaines fonctions liées au chargement et à l&#39;enregistrement des tampons dans les fichiers, ainsi que lors du chargement ou du déchargement de l&#39;audio de la mémoire. L&#39;événement lui-même contiendra le construit dans <tt>async_load</tt> Carte DS qui sera remplie par les touches nécessaires à la fonction spécifique. Ceux-ci sont énumérés dans les sections ci-dessous. <blockquote><a name="async_saveload_buffers" id=
"async_saveload_buffers"></a> <label class="collapse" for=
"twentynine">Tampons</label> <input id="twentynine" type=
"checkbox"><div class="index_list"> Lorsque vous utilisez les fonctions <a href=
"../../../3_scripting/4_gml_reference/buffers/buffer_save_async.html"><tt>buffer_save_async()</tt></a> ou <a href=
"../../../3_scripting/4_gml_reference/buffers/buffer_load_async.html"><tt>buffer_load_async()</tt></a> un événement asynchrone sera déclenché une fois le transfert de données terminé. Cet événement va peupler le <tt>async_load</tt> carte avec les paires clé / valeur suivantes <br><br><ul><li> <b>&quot;id&quot;:</b> l&#39;identifiant de la fonction asynchrone renvoyée par la fonction utilisée. </li><li> <b>&quot;status&quot;:</b> retournera <tt>true</tt> si les données ont été sauvegardées / chargées correctement, et <tt>false</tt> autrement. </li></ul> Cela vous permet d&#39;interroger la progression de sauvegarde / chargement et d&#39;afficher un message ou de changer de salle etc... lorsque le processus est terminé. </div><br><a name="async_saveload_audio" id="async_saveload_audio"></a> <label class="collapse" for="thirty">Groupes audio</label> <input id="thirty" type="checkbox"><div class="index_list"> Lorsque vous travaillez avec des <a href=
"../../../3_scripting/4_gml_reference/audio/audio%20groups.html">groupes audio</a>, vous pouvez les charger et les décharger de la mémoire en utilisant les fonctions <a href=
"../../../3_scripting/4_gml_reference/audio/audio_group_load.html"><tt>
audio_group_load()</tt></a> et <a href=
"../../../3_scripting/4_gml_reference/audio/audio_group_unload.html"><tt>audio_group_unload()</tt></a>. Lors de l&#39;utilisation de la fonction de chargement, elle déclenchera cet événement lorsque l&#39;ensemble des fichiers audio définis pour le groupe aura été chargé en mémoire et remplira la carte avec les paires clé / valeur suivantes: <br><br><ul><li> <b>&quot;type&quot;:</b> cela nous indique le type d&#39;événement appelé et sera &quot; <tt>audiogroup_load</tt> &quot;pour le chargement audio. </li><li> <b>&quot;group_id&quot;:</b> renvoie l&#39;ID du groupe audio qui a été chargé (comme défini dans l&#39; <a href=
"c:/source/yoyostudio/documentation/english/2_interface/3_settings/audio.html">éditeur de groupe audio</a> ). </li></ul> Lorsque tout l&#39;audio a été chargé pour un groupe, cet événement se déclenchera et il pourra alors être utilisé pour changer de pièce, ou jouer une piste musicale etc... </div></blockquote></div><br><a name="async_social" id="async_social"></a> <label class=
"collapse" for="eight">Social</label> <input id="eight" type=
"checkbox"><div class="index_list"> Cet événement ne peut être déclenché que par les différentes <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/index.html">fonctions sociales</a> spécifiques et renvoie un <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> stocké dans la variable <tt>async_load</tt>, contenant différentes paires clé / valeur en fonction du rappel de la fonction qui a déclenché l&#39;événement. <br><br> Le fichier ds_map contiendra un certain nombre de clés, la plus importante étant la clé &quot; <i>id</i> &quot;. Cela retournera une <b>constante</b> qui peut ensuite être vérifiée dans le code pour déterminer lequel des nombreux rappels l&#39;événement a reçu. Une fois que vous avez analysé cette clé et comparé la valeur renvoyée avec les constantes disponibles, vous pouvez continuer à extraire le reste des informations de la carte. <blockquote><a name="async_social_leaderboards" id=
"async_social_leaderboards"></a> <label class="collapse" for=
"twentyseven">Classements et réalisations</label> <input id=
"twentyseven" type="checkbox"><div class="index_list"> Les pages de fonctions sur <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/achievements%20and%20leaderboards/index.html">le jeu social - Réalisations et classements</a> dans la section Référence détaillent les fonctions et les rappels ainsi que les constantes utilisées pour déclencher cet événement, mais il existe également certaines circonstances dans lesquelles il sera déclenché sans un appel de fonction du jeu est en cours d&#39;exécution: <br><br><ul><li> lorsque votre jeu est lancé à partir du tableau de bord du système d&#39;exploitation </li><li> lorsque vous remplissez un défi </li><li> quand un autre joueur termine un défi </li><li> lorsque le jeu est démarré à partir du tableau de bord du système d&#39;exploitation en sélectionnant un défi </li></ul><p> L&#39;un des rappels ci-dessus déclenchera l&#39; <b>événement social</b> et un <tt>async_load</tt> map sera généré avec les détails suivants (notez qu&#39;il existe une valeur de clé &quot;id&quot; différente pour définir chacune des différentes raisons pour lesquelles l&#39;événement a été appelé, mais tous les autres contenus de la carte sont les mêmes): <br><br></p><ul><li> &quot; <b>id</b> &quot; - La valeur de cette clé dépend du type de rappel qui déclenche l&#39;événement. cela peut être l&#39;une de ces constantes: <br><br><ul><li> <b><tt>achievement_challenge_received</tt></b> - Un défi a été reçu <br></li><li> <b><tt>achievement_challenge_completed</tt></b> - Un défi a été complété. <br></li><li> <b><tt>achievement_challenge_completed_by_remote</tt></b> - Un défi a été complété par l&#39;autre joueur. <br></li><li> <b><tt>achievement_challenge_launched</tt></b> - Le jeu a été lancé à partir du tableau de bord du système d&#39;exploitation avec le défi donné. <br></li></ul></li><li> &quot; <b>playerid</b> &quot; - L&#39;identifiant du joueur pour le challenge. <br><br></li><li> &quot; <b>issuerid</b> &quot; - L&#39;identifiant de la personne qui a lancé le défi. <br><br></li><li> &quot; <b>state</b> &quot; - L&#39;état du challenge, qui aura une valeur de 0 - 3 (comme une chaîne de caractères) pour <i>invalide</i>, en <i>attente</i>, <i>complété</i> ou <i>refusé</i>. <br><br></li><li> &quot; <b>message</b> &quot; - Le message texte pour le défi. <br><br></li><li> &quot; <b>date d&#39;émission</b> &quot; - Date d&#39;émission du challenge <br><br></li><li> &quot; <b>completeddate</b> &quot; - La date d&#39;achèvement du challenge. <br><br></li><li> &quot; <b>type</b> &quot; - Le type de défi donné. Peut être l&#39;une des deux constantes: <br><br><ul><li> <b><tt>achievement_type_score_challenge</tt></b> - Un défi basé sur la valeur du score. <br></li><li> <b><tt>achievement_type_achievement_challenge</tt></b> - Un défi basé sur un exploit. <br></li></ul></li><li> &quot; <b>identificateur</b> &quot; - La chaîne d&#39;identification pour le défi. <br><br></li><li> &quot; <b>score</b> &quot; - Le score lié au défi. </li></ul> Vous trouverez ci-dessous un petit extrait de code comme exemple d&#39;utilisation: <br><br><p class="code">var ident = ds_map_find_value(async_load, "id"
);<br>
if ident == achievement_challenge_completed;<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;player_id = ds_map_find_value(async_load,
"playerid");<br>
&nbsp;&nbsp;&nbsp;issuer_id = ds_map_find_value(async_load,
"issuerid");<br>
&nbsp;&nbsp;&nbsp;state = ds_map_find_value(async_load,
"state");<br>
&nbsp;&nbsp;&nbsp;date_completed = ds_map_find_value(async_load,
"completeddate");<br>
&nbsp;&nbsp;&nbsp;date_issued = ds_map_find_value(async_load,
"issueddate");<br>
&nbsp;&nbsp;&nbsp;ach_type = ds_map_find_value(async_load,
"type");<br>
&nbsp;&nbsp;&nbsp;ach_ident = ds_map_find_value(async_load,
"identifier");<br>
&nbsp;&nbsp;&nbsp;ach_score = ds_map_find_value(async_load,
"score");<br>
&nbsp;&nbsp;&nbsp;}<span class="notranslate"></span></p></div><br><a name="async_social_facebook" id="async_social_facebook"></a> <label class="collapse" for="twentyeight">Facebook</label> <input id="twentyeight" type="checkbox"><div class="index_list"> Certaines <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/facebook/index.html">fonctions Facebook</a> vont déclencher un événement social asynchrone et créer un <tt>ds_map</tt> avec quelques informations spécifiques. Les informations renvoyées dépendront du &quot;type&quot; d&#39;événement qui a été appelé. Vous pouvez vérifier cela en lisant la clé &quot;type&quot; de la carte ds_map, qui sera la chaîne suivante pour un événement Facebook: <br><br><ul><li> &quot; <b>facebook_permission_request</b> &quot; </li></ul><p> Lorsque l&#39;événement est déclenché et est de ce type, il y aura également des clés supplémentaires qui peuvent être vérifiées: </p><ul><li> &quot; <b>requestId</b> &quot; - La valeur d&#39;ID de la requête renvoyée par le <tt>facebook_request_xxx_permission()</tt> fonction qui a déclenché l&#39;événement <br><br></li><li> &quot; <b>result</b> &quot; - Ce sera l&#39;une des chaînes suivantes: <br><br><ul><li> &quot; <b>accordé</b> &quot; - les autorisations ont été acceptées par l&#39;utilisateur </li><li> &quot; <b>denied</b> &quot; - une ou plusieurs autorisations n&#39;ont pas été acceptées par l&#39;utilisateur </li><li> &quot; <b>erreur</b> &quot; - une erreur est survenue </li></ul></li><li> <b>« erreur</b> » - Il contiendra une description de l&#39;erreur, mais il est présent que lorsque « <b>résultat</b> » = « <b>erreur</b> ». </li></ul></div></blockquote></div><br><a name="async_steam" id="async_steam"></a> <label class="collapse"
for="seven"><span class="notranslate">Steam</span></label> <input id="seven" type="checkbox"> <div class="index_list"> Cet événement ne peut être déclenché que par les fonctions de l&#39; <a href=
"../../../3_scripting/4_gml_reference/steam%20api/index.html">API <span class="notranslate">Steam</span></a> et renvoie un <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> stocké dans la variable <tt>async_load</tt>, contenant différentes paires clé / valeur en fonction du rappel de la fonction qui a déclenché l&#39;événement. La carte contiendra toujours la clé &quot; <b>event_type</b> &quot; qui peut ensuite être analysée pour trouver le type de fonction qui a déclenché l&#39;événement et changer le code requis. <br><br> Lorsque vous appelez une fonction qui déclenche cet événement, elle génère une valeur d&#39;identifiant asynchrone unique qui doit être stockée dans une variable et vérifiée, comme <tt>async_load</tt> map contiendra toujours une clé d&#39;identification que vous pourrez ensuite analyser et vérifier que vous répondez à l&#39;événement correct. En fait, la carte contiendra <i>toujours</i> les clés suivantes, quelle que soit la fonction <span class="notranslate">Steam</span> utilisée pour générer la réponse asynchrone: <br><br><ul><li> &quot; <b>id</b> &quot; - L&#39;identifiant asynchrone renvoyé par la fonction qui a déclenché l&#39;événement </li><li style="list-style: none"><br></li><li> &quot; <b>résultat</b> &quot; - Le résultat de l&#39;opération (une valeur réelle). Ce sera soit la constante GML <tt>ugc_result_success</tt> ou un autre nombre réel. Vous devriez donc vérifier cette constante pour vous assurer que l&#39;appel a réussi et, dans le cas contraire, que quelque chose ne fonctionne pas correctement. Le reste des valeurs possibles renvoyées sont affichées comme le résultat de la valeur <span class="notranslate">Steam</span> &quot;EResult&quot; et vous devriez voir <tt>steamclientpublic.h</tt> dans les en-têtes SDK pour toutes les 89 valeurs possibles. </li><li style="list-style: none"><br></li><li> &quot; <b>event_type</b> &quot; - Une chaîne indiquant le type d&#39;événement (voir ci-dessous pour les détails) </li></ul><blockquote><a name="async_steam_uploading" id=
"async_steam_uploading"></a> <label class="collapse" for=
"twentythree">Téléchargement de données</label> <input id="twentythree" type=
"checkbox"><div class="index_list"> Lorsque vous utilisez les fonctions <span class="notranslate">Steam</span> pour télécharger un leaderboard (soit <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_upload_score.html"><tt>steam_upload_score()</tt></a> ou <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_upload_score_buffer.html"><tt>steam_upload_score_buffer()</tt></a> ) le retour <tt>ds_map</tt> aura les paires clé / valeur suivantes: <br><br><ul><li> &quot; <b>event_type</b> &quot; - Cette clé contiendra la valeur &quot; <b>leaderboard_upload</b> &quot; </li><li style="list-style: none"><br></li><li> &quot; <b>post_id</b> &quot; - Cette clé doit correspondre à la valeur d&#39;ID renvoyée par la fonction d&#39;appel de téléchargement </li><li style="list-style: none"><br></li><li> &quot; <b>lb_name</b> &quot; - Cette clé contient le nom du leaderboard qui a été posté sur </li><li style="list-style: none"><br></li><li> &quot; <b>succès</b> &quot; - Sera 1 si le poste a réussi, 0 a échoué </li><li style="list-style: none"><br></li><li> &quot; <b>updated</b> &quot; - Sera 1 si le score du classement a été réellement mis à jour (ie: le nouveau score était meilleur) ou 0 sinon </li><li style="list-style: none"><br></li><li> &quot; <b>score</b> &quot; - Cette clé contient le score qui a été posté </li></ul> Vous pouvez voir des exemples de cela sur les pages pour les fonctions de téléchargement de score. </div><br><a name="async_steam_downloading" id="async_steam_downloading"></a> <label class="collapse" for="twentyfour">Téléchargement de classements</label> <input id="twentyfour" type="checkbox"><div class="index_list"> Lorsque vous utilisez les fonctions <span class="notranslate">Steam</span> pour télécharger un classement ( <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_download_scores.html"><tt>steam_download_scores()</tt></a>, <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_download_scores_around_user.html"><tt>steam_download_scores_around_user()</tt></a> ou <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_download_friends_scores.html"><tt>steam_download_friends_scores()</tt></a> ) le retour <tt>ds_map</tt> aura les paires clé / valeur suivantes: <br><br><ul><li> &quot; <b>event_type</b> &quot; - Cette clé contiendra la valeur &quot; <b>leaderboard_download</b> &quot; </li><li style="list-style: none"><br></li><li> &quot; <b>id</b> &quot; - Cette clé doit correspondre à la valeur d&#39;ID renvoyée par la fonction d&#39;appel de téléchargement </li><li style="list-style: none"><br></li><li> &quot; <b>status</b> &quot; - L&#39;état du callback, où -1 correspond à un échec ou qu&#39;aucun résultat n&#39;a été retourné, et 0 est un succès. </li><li> &quot; <b>lb_name</b> &quot; - Cette clé contient le nom du leaderboard qui a été posté sur </li><li style="list-style: none"><br></li><li> &quot; <b>numEntries</b> &quot; - Nombre de &quot;rangées&quot; de données de classement en cours de renvoi. </li><li style="list-style: none"><br></li><li> &quot; <b>entries</b> &quot; - Une chaîne d&#39;objet JSON qui contient un autre ds_map, qui contiendra la clé &quot;default&quot; (signifiant qu&#39;aucun résultat n&#39;est contenu dedans) ou la clé &quot;entries&quot;, dont vous pouvez alors obtenir la valeur. cette valeur retournée pour &quot;entrées&quot; sera un <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20lists/index.html"><tt>ds_list</tt></a> contenant chacun des rangs du classement, où chaque entrée de la liste fera elle-même référence à une autre <tt>ds_map</tt> qui contiendra les clés &quot;name&quot;, &quot;score&quot; et &quot;rank&quot;, et il peut également contenir une clé &quot;data&quot; en fonction de la fonction utilisée pour le téléchargement. </li></ul> Nous montrerons un exemple du fonctionnement du téléchargement des données de score en demandant le classement des dix premiers pour le classement donné et en analysant ses résultats dans l&#39; <b>événement <span class="notranslate">Steam</span> Async</b> (pour télécharger des exemples, veuillez consulter les pages de fonctions appropriées). Pour commencer, nous devons demander les scores avec le code suivant: <br><br><p class="code">score_get = steam_download_scores("Game Scores", 1,
10);<br><span class="notranslate"></span></p><br> Cela enverra une requête au serveur <span class="notranslate">Steam</span> pour les scores du classement &quot;Game Scores&quot;, en stockant l&#39; <b>identifiant asynchrone</b> de la requête dans la variable &quot;score_get&quot;. Cela sera ensuite traité dans l&#39; <b>événement <span class="notranslate">Steam</span> Async</b> de la façon suivante: <br><br><p class="code">var async_id = ds_map_find_value(async_load,
"id");<br>
if async_id == score_get<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;var entries = ds_map_find_value(async_load,
"entries");<br>
&nbsp;&nbsp;&nbsp;var map = json_decode(entries);<br>
&nbsp;&nbsp;&nbsp;if ds_map_exists(map, "default")<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds_map_destroy(map);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var list =
ds_map_find_value(map, "entries");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var len =
ds_list_size(list);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var entry;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(var i = 0; i &lt; len;
i++;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entry =
ds_list_find_value(list, i );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;steam_name[i]
= ds_map_find_value(entry, "name");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;steam_score[i]
= ds_map_find_value(entry, "score");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;steam_rank[i]
= ds_map_find_value(entry, "rank");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(ds_map_exists(entry, "data"))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var
data = ds_map_find_value(entry, "data");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var
buffId = buffer_base64_decode(data);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var
message = buffer_read(buffId, buffer_string);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show_debug_message(
" -- attached message: " + string(message));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer_delete(buffId);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds_map_destroy(entry);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds_list_destroy(list)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;ds_map_destroy(map)<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Ce que nous faisons ici est d&#39;abord vérifier la clé &quot;id&quot; de la spéciale <tt>async_load</tt> carte. Si cette valeur est la même que la valeur de la fonction de rappel d&#39;origine (stockée dans la variable &quot;score_get&quot;), nous continuons à traiter les données. La première chose que nous faisons est d&#39;analyser <tt>async_load</tt> ds_map pour la clé &quot;entrées&quot; qui contiendra un objet JSON contenant les données du leaderboard. Cet objet JSON est ensuite décodé (voir <a href=
"../../../3_scripting/4_gml_reference/file%20handling/json_decode.html"><tt>json_decode</tt></a> ) comme un autre ds_map, et ce nouvel identifiant de carte est stocké dans la variable &quot;map&quot;. <br><br> Cette carte est vérifiée pour la clé &quot;par défaut&quot; et si cela est trouvé alors la carte est détruite et l&#39;événement est quitté. Si aucune clé &quot;default&quot; n&#39;est trouvée, le code analysera la carte pour extraire les informations nécessaires sur le leaderboard, en extrayant d&#39;abord une liste ds_list de la clé &quot;entries&quot; de la carte ds_map, puis en passant en boucle chaque entrée de la liste obtenir <i>un autre</i> ds_map avec le nom, le score et le rang de chaque entrée. Ces valeurs sont ensuite stockées dans des tableaux, puis nous vérifions s&#39;il existe une clé &quot;data&quot; supplémentaire. S&#39;il y a (c&#39;est-à-dire: le score a été téléchargé avec un paquet de données supplémentaire), nous l&#39;analysons et l&#39;envoyons à la console du compilateur pour le déboguer, avant de détruire le tampon, puis de détruire la carte. Notez que si la clé &quot;data&quot; est incluse, elle doit être décodée en utilisant <a href=
"../../../3_scripting/4_gml_reference/buffers/buffer_base64_decode.html"><tt>buffer_base64_decode()</tt></a> avant qu&#39;il puisse être lu correctement. <br><br> Une fois la boucle terminée, la liste des entrées est détruite, de même que la carte dont elle provient. Il n&#39;y a pas besoin de détruire le <tt>async_load</tt> ds_map car ceci est géré pour vous par <i><span class="notranslate">GameMaker Studio 2</span></i>. </div><br><a name="async_steam_downloadingugc" id=
"async_steam_downloadingugc"></a> <label class="collapse" for=
"twentyfive">Téléchargement de contenu généré par l&#39;utilisateur (contenu généré par l&#39;utilisateur)</label> <input id="twentyfive" type="checkbox"><div class="index_list"> Lorsque vous utilisez les fonctions <span class="notranslate">Steam</span> pour télécharger du <a href=
"../../../3_scripting/4_gml_reference/steam%20api/user%20generated%20content/index.html">contenu généré par l&#39;utilisateur (UGC)</a>, un certain nombre d&#39;entre eux déclencheront cet événement. Cependant, chaque fonction génère un <tt>async_load</tt> ds_map avec des paires clé / valeur différentes (bien qu&#39;elles contiennent toujours les clés générales &quot; <b>id</b> &quot;, &quot; <b>result</b> &quot; et &quot; <b>event_type</b> &quot;), veuillez donc voir la page spécifique à la fonction utilisée pour les détails et les exemples. </div><br><a name="async_steam_ugc_events" id="async_steam_ugc_events"></a> <label class="collapse" for="twentysix">Événements uniques de l&#39;UGC</label> <input id="twentysix" type="checkbox"><div class="index_list"> L&#39;événement <span class="notranslate">Steam</span> Async peut également être déclenché lorsqu&#39;un utilisateur s&#39;abonne à un élément en dehors du jeu. Par exemple, il tabule vers un navigateur et s&#39;abonne à un nouvel élément, puis revient au jeu. Dans ces cas, le <tt>async_load</tt> map <b>ne</b> contiendra <b>que</b> les informations suivantes (et aucune des valeurs par défaut répertoriées en haut de cette page): <br><br><ul><li> &quot; <b>event_type</b> &quot; - Cette clé contiendra la valeur &quot; <b>ugc_item_installed</b> &quot; </li><li style="list-style: none"><br></li><li> &quot; <b>published_file_id</b> &quot; - l&#39;ID de l&#39;élément UGC nouvellement installé (vous pouvez utiliser la fonction <a href=
"../../../3_scripting/4_gml_reference/steam%20api/user%20generated%20content/steam_ugc_get_item_install_info.html"><tt>steam_ugc_get_item_install_info()</tt></a> pour obtenir le chemin vers l&#39;élément installé) </li><li style="list-style: none"><br></li></ul> L&#39;événement <span class="notranslate">Steam</span> Async peut également être déclenché lorsqu&#39;un abonnement à un atelier est souscrit, soit depuis l&#39;application, soit en externe depuis un navigateur d&#39;atelier. <tt>async_load</tt> map contiendra les paires clé / valeur suivantes: <br><br><ul><li> &quot; <b>event_type</b> &quot; - Cette clé contiendra la valeur &quot; <b>ugc_item_subscribed&quot;</b> &quot; </li><li style="list-style: none"><br></li><li> &quot; <b>published_file_id</b> &quot;: cette clé a l&#39;ID de fichier publié de l&#39;élément nouvellement abonné </li><li style="list-style: none"><br></li></ul> L&#39;événement sera déclenché si un élément est également désabonné, la carte DS contenant ce qui suit: <br><br><ul><li> &quot; <b>event_type</b> &quot; - Cette clé contiendra la valeur &quot; <b>ugc_item_unsubscribed&quot;</b> &quot; </li><li style="list-style: none"><br></li><li> &quot; <b>published_file_id</b> &quot;: Cette clé a l&#39;ID de fichier publié de l&#39;élément non abonné </li><li style="list-style: none"><br></li></ul></div></blockquote></div><br><a name="async_system" id="async_system"></a> <label class=
"collapse" for="fourteen">Système</label> <input id="fourteen" type=
"checkbox"><div class="index_list"><p> Cet événement peut uniquement être déclenché par un événement de niveau système (tel que la détection d&#39;une manette de jeu ou la connexion automatique à XBox Live). <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> stocké dans la variable <tt>async_load</tt>, contenant différentes paires clé / valeur en fonction de l&#39;événement de niveau système ayant déclenché le rappel. </p><blockquote><a name="async_system_gamepads" id=
"async_system_gamepads"></a> <label class="collapse" for=
"thirtyone">Game Pads</label> <input id="thirtyone" type=
"checkbox"><div class="index_list"><p> Lorsque cet événement est déclenché pour une manette connectée ou déconnectée, l&#39;une des paires clé / valeur suivantes est renvoyée <tt>async_load</tt> carte: <br><br></p><ul><li> &quot; <b>event_type</b> &quot; - le type d&#39;événement système reçu, qui sera l&#39;une des chaînes suivantes: <br><br><ul><li> &quot; <b>gamepad discover</b> &quot; - se produit lorsque le système signale qu&#39;une nouvelle manette a été connectée </li><li> &quot; <b>gamepad lost</b> &quot; - se produit lorsque le système a perdu la connexion à une manette </li></ul></li><li> &quot; <b>pad_index</b> &quot; - l&#39;index du pad qui a été ajouté ou supprimé </li></ul><p> Cet événement vous permet désormais de déplacer toute la logique de vérification de la manette de jeu depuis l&#39;événement d&#39;étape ou un événement d&#39;alarme dans l&#39;événement système et de l&#39;exécuter uniquement lorsqu&#39;elle est réellement requise. </p></div><br><a name="async_system_xboxlive" id="async_system_xboxlive"></a> <label class="collapse" for="thirtytwo">Xbox Live</label> <input id="thirtytwo" type="checkbox"><div class="index_list"><p> L&#39;événement système asynchrone peut être déclenché lors du ciblage de la <b><span class="notranslate">XBox One</span></b> à l&#39;aide de l&#39;exportation <b>UWP</b> et en cochant l&#39;option <b>Activer XBox Live</b> dans les <a href=
"../../../2_interface/3_settings/game_options/options_windowsuwp.html">options de jeu UWP</a>. Lorsque vous démarrez le projet UWP de <i><span class="notranslate">GameMaker Studio 2</span></i> sur lequel Xbox Live est activé, le projet tente automatiquement de se connecter en mode silencieux à Xbox Live. Les résultats de cette tentative de connexion seront renvoyés comme l&#39;une des paires clé / valeur suivantes <tt>async_load</tt> carte: </p><ul><li> &quot; <b>event_type</b> &quot; - le type d&#39;événement système reçu, qui sera l&#39;une des chaînes suivantes: <br><br><ul><li> &quot; <b>utilisateur connecté</b> &quot; - la connexion de l&#39;utilisateur silencieux a été effectuée avec succès </li><li> &quot;La <b>connexion de l&#39;utilisateur a échoué</b> &quot; - la connexion de l&#39;utilisateur en mode silencieux a échoué (lorsque cela se produit, vous pouvez utiliser la fonction <a href=
"../../../3_scripting/4_gml_reference/xbox_live/xboxlive_show_account_picker.html"><tt>xboxlive_show_account_picker()</tt></a> pour que l&#39;utilisateur choisisse un compte avec lequel se connecter) </li><li> &quot; <b>utilisateur déconnecté</b> &quot; - l&#39;utilisateur s&#39;est déconnecté </li></ul></li></ul><p> Pour plus d&#39;informations sur les fonctions spécifiques disponibles pour XBox Live, veuillez voir <a href=
"../../../3_scripting/4_gml_reference/xbox_live/index.html">ici</a>. </p></div></blockquote></div></blockquote><p><br></p></div><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> Retour: <a href="../objects.html">L&#39;éditeur d&#39;objets</a> </div><div style="float:right"> Suivant: <a href="draw_events.html">Dessiner des événements</a> </div></div></div><h5> © Copyright <span class="notranslate">YoYo Games Ltd.</span> 2017 Tous droits réservés </h5>
<script type="text/javascript">
   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');   ga('create', 'UA-2711665-14', 'auto');   ga('send', 'pageview'); 
</script>
</div>

<script type="text/JavaScript">
var fe = FindFrame("toc", top);
if ((fe != null) && (chmtop.c2wtopf.jstree != null)) {
  if (chmtop.c2wtopf.FITEMS[chmtop.c2wtopf.pagenum] != chmtop.c2wtopf.pageid)
    chmtop.c2wtopf.jstree.OpenTreeNode("source/" + chmtop.c2wtopf.pageid);
}
</script>
</body>
</html>
