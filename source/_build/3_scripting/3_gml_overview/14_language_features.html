<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="keywords" content="online documentation, web online help, web help, chm2web" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="generator" content="chm2web Pro 2.85 (unicode)" />
<title>Language Features</title>
<meta http-equiv="X-UA-Compatible" content="IE=9">

<link rel="stylesheet" href="../../../../files/helpindex.css" type=
"text/css">
<link rel="stylesheet" href="../../../../default.css" type=
"text/css">

<script type="text/JavaScript" src="../../../../files/supply.js"></script>
<script type="text/JavaScript">
chmtop.c2wtopf.pageid = "_build/3_scripting/3_gml_overview/14_language_features.html";
</script>

</head>
<body><script type="text/JavaScript"> 
if (window.name != "content") 
  document.write(" <table width=\"100%\" bgcolor=\"#e1e1e1\"cellspacing=\"2\" cellpadding=\"0\" style=\"border-collapse: collapse; font-family: sans-serif; font-size: 14px; color: #000000; text-decoration: none;  \"> <tr> <td align=\"center\" style=\"border-bottom: 2px solid gray\" > <br>&nbsp;Click <a href=\"../../../../index.html?page=source%2F_build%2F3_scripting%2F3_gml_overview%2F14_language_features.html\">here</a> to show toolbars of the Web Online Help System: <a href=\"../../../../index.html?page=source%2F_build%2F3_scripting%2F3_gml_overview%2F14_language_features.html\">show toolbars</a><br>&nbsp;</td></tr></table><br> "); 
</script>
<!-- !chm2web! --><script type="text/JavaScript">
 if( typeof(chmtop.helpStyle) != 'undefined' ) { var linkNodes = document.getElementsByTagName("link");  for( var i=0; i < linkNodes.length; ++i ) { var link = linkNodes[i];    if( link.href.endsWith("default.css")) {    var style = link.href.replace("default.css", chmtop.helpStyle); document.write('<link id="newstyleLink" rel="stylesheet" href=' + style + ' type="text/css">');    break; } } } 
</script><h2> Caractéristiques linguistiques </h2><div class="body-scroll"><p><br></p><p> Le langage <span class="notranslate">GameMaker</span> (GML) a un certain nombre de caractéristiques qui font partie de la structure essentielle de tout le code écrit avec la langue. Chacun d&#39;entre eux sera utilisé dans n&#39;importe quel code que vous écrivez plusieurs fois, vous devez donc savoir ce qu&#39;ils sont et comment ils fonctionnent avant de commencer à programmer un projet. </p><blockquote> <label class="collapse" for="one">si / Opérateur conditionnel</label> <input id="one" type="checkbox"><div class="index_list"> Une simple déclaration &quot;if&quot; prend cette forme: <br><br><p class="code">if (&lt;expression&gt;) &lt;statement&gt;<span class="notranslate"></span></p><br> ou il peut avoir le formulaire &quot;if... else...&quot; légèrement plus complexe: <br><br><p class="code">if (&lt;expression&gt;) &lt;statement&gt; else
&lt;statement&gt;<span class="notranslate"></span></p><br> Dans ce cas, l&#39;expression sera évaluée, et si la valeur (arrondie) est &lt;= 0 ( <tt>false</tt> ) la déclaration après l&#39;autre est exécutée, sinon ( <tt>true</tt> ) l&#39;autre instruction est exécutée. C&#39;est une bonne habitude de toujours mettre des accolades autour des instructions dans le if, et de prendre une nouvelle ligne dans le bloc pour chaque instruction, de sorte que le code de fin aura cette forme: <br><br><p class="code">if (&lt;expression&gt;)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&lt;statement&gt;<br>
&nbsp;&nbsp;&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&lt;statement&gt;<br>
&nbsp;&nbsp;&nbsp;}<br>
else<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&lt;statement&gt;<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Comme un petit exemple, considérons le code suivant qui va déplacer l&#39;instance vers la position x = 200 dans la pièce: <br><br><p class="code">if (x &lt; 200)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;x += 4;<br>
&nbsp;&nbsp;&nbsp;}<br>
else<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;x -= 4;<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Notez que vous pouvez également effectuer <i>des</i> contrôles <i>composés</i> dans un if, c&#39;est-à-dire: vérifier différentes valeurs ou expressions dans la même instruction. Lorsque vous effectuez cette opération, <i><span class="notranslate">GameMaker Studio 2</span></i> évalue chacun d&#39;entre eux un par un, et si l&#39;un d&#39;entre eux évalue à false, le reste sera ignoré. Par exemple: <br><br><p class="code">if (keyboard_check_pressed(vk_enter) &amp;&amp;
!instance_exists(obj_Player))<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;go = false<br>
&nbsp;&nbsp;&nbsp;alarm[0] = room_speed<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Vous pouvez également effectuer des <b>opérations conditionnelles</b> (aussi <b>appelées</b> opérations <b>ternaires</b> ), ce qui est essentiellement une manière &quot;raccourcie&quot; d&#39;effectuer un &quot;si&quot; basique. Il a la syntaxe suivante: <br><br><p class="code">variable = condition ? &lt;expression1 (if
<i>true</i>)&gt; : &lt;expression2 (if <i>false</i>)&gt;<span class="notranslate"></span></p><br> L&#39;opérateur conditionnel renvoie l&#39;une des deux valeurs données selon que la condition évalue <tt>true</tt> ou <tt>false</tt>, par exemple: <br><br><p class="code">var temp_x = x &lt; (room_width / 2) ? 32:
room_width - 32;<span class="notranslate"></span></p><br> Le code ci-dessus vérifiera la valeur de &quot;x&quot; par rapport à la moitié de la largeur de la pièce et, si elle est inférieure, mettra &quot;temp_x&quot; à 32 sinon &quot;temp_x&quot; sera room_width - 32. Voici quelques exemples de utilisation: <br><br><p class="code">draw_text(x, y, "The fee is " + (global.Member ?
"$2.00" : "$10.00"));<br>
path_start((global.level &gt; 10 ? path_hard : path_easy;), 2,
path_action_reverse, true);<br>
--hp &lt;= 0 ? instance_destroy() : score += 10;<span class="notranslate"></span></p><br> Il est à noter que vous pouvez imbriquer des opérations conditionnelles mais que si vous le faites, chaque opération devra être placée entre parenthèses, par exemple: <br><br><p class="code">var c = a ? "foo" : (b ? "bar" : "wii"); //
Correct<br>
var c = a ? "foo" : b ? "bar" : "wii";&nbsp;&nbsp; // Will cause an
error<span class="notranslate"></span></p></div><br> <label class="collapse" for="two">répéter</label> <input id="two"
type="checkbox"><div class="index_list"> Une instruction &quot;repeat&quot; a la forme <br><br><p class="code">repeat (&lt;expression&gt;) &lt;statement&gt;<span class="notranslate"></span></p><br> L&#39;instruction est répétée le nombre de fois indiqué par la valeur arrondie de l&#39;expression. Par exemple, le programme suivant crée cinq balles à des positions aléatoires. <br><br><p class="code">{<br>
repeat (5) instance_create_layer(random(400), random(400),
"Instances", obj_ball);<br>
}<br><span class="notranslate"></span></p><p><br> Cela peut être très utile pour éviter de taper plusieurs fois le même code, ou pour utiliser des tableaux, ou pour compter un certain nombre d&#39;opérations etc... Par exemple: <br><br></p><p class="code">{<br>
var i, total;<br>
i = 0;<br>
total = 0;<br>
repeat (10)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;total += array[i];<br>
&nbsp;&nbsp;&nbsp;i += 1<br>
&nbsp;&nbsp;&nbsp;}<br>
draw_text(32, 32, total);<br>
}<br><span class="notranslate"></span></p></div><br> <label class="collapse" for="three">tandis que</label> <input id="three"
type="checkbox"><div class="index_list"> Une instruction &quot;while&quot; a la forme <br><br><p class="code">while (&lt;expression&gt;) &lt;statement&gt;<span class="notranslate"></span></p><br> Tant que l&#39;expression est vraie, l&#39;instruction (qui peut aussi être un bloc de code) est exécutée. <b>Soyez prudent avec vos boucles while!</b> Vous pouvez facilement créer des boucles infinies, auquel cas votre jeu se bloquera et ne réagira plus à aucune entrée utilisateur. Vous trouverez ci-dessous un exemple de façon typique d&#39;utiliser &quot;while&quot;: <br><br><p class="code">{<br>
while (!place_free(x, y))<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;x = random(room_width);<br>
&nbsp;&nbsp;&nbsp;y = random(room_height);<br>
&nbsp;&nbsp;&nbsp;}<br>
}<br><span class="notranslate"></span></p><br> Le programme ci-dessus tente de placer l&#39;objet courant à une position libre (c&#39;est à peu près le même que l&#39;action pour déplacer un objet à une position aléatoire). </div><br> <label class="collapse" for="four">faire jusqu&#39;à ce que</label> <input id=
"four" type="checkbox"><div class="index_list"> Un &quot;do&quot; est vraiment l&#39;instruction &quot;do... until&quot; car vous ne pouvez pas en avoir un sans l&#39;autre. Il a cette forme: <br><br><p class="code">do &lt;statement&gt; until (&lt;expression&gt;)<span class="notranslate"></span></p><br> L&#39;instruction (qui peut également être un bloc de code) est exécutée jusqu&#39;à ce que l&#39;expression soit trouvée vraie, et l&#39;instruction initiale est toujours exécutée au moins une fois. Soyez prudent avec vos boucles, car vous pouvez facilement les faire boucler pour toujours, auquel cas votre jeu se bloquera et ne réagira plus à aucune entrée utilisateur. Ci-dessous vous pouvez trouver un exemple d&#39;une façon typique d&#39;utiliser &quot;faire... jusqu&#39;à&quot;: <br><br><p class="code">{<br>
do<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;x = random(room_width);<br>
&nbsp;&nbsp;&nbsp;y = random(room_height);<br>
&nbsp;&nbsp;&nbsp;}<br>
until (place_free(x, y)); }<br><span class="notranslate"></span></p><br> Le programme ci-dessus tente de placer l&#39;objet courant à une position libre (c&#39;est à peu près le même que l&#39;action pour déplacer un objet à une position aléatoire). </div><br> <label class="collapse" for="five">pour</label> <input id="five"
type="checkbox"><div class="index_list"> Une instruction &quot;for&quot; a cette forme: <br><br><p class="code">for (&lt;statement1&gt; ; &lt;expression&gt;
;&lt;statement2&gt;) &lt;statement3&gt;<span class="notranslate"></span></p><br> Cela fonctionne comme suit - First statement1 est exécuté, puis l&#39;expression est évaluée et, si elle est vraie, l&#39;instruction 3 est exécutée. Ensuite, l&#39;instruction 2, puis l&#39;expression est évaluée à nouveau. Cette boucle continuera jusqu&#39;à ce que l&#39;expression soit fausse. <br><br> Maintenant, cela peut sembler compliqué lorsqu&#39;il est écrit comme ça, mais vous devriez l&#39;interpréter comme: <br><br><ul><li> La première instruction initialise la boucle for. </li><li> L&#39;expression teste si la boucle doit être terminée. </li><li> Statement2 est l&#39;instruction &quot;step&quot; qui va à l&#39;évaluation de la boucle suivante. </li></ul> C&#39;est extrêmement utile pour effectuer des tâches répétitives qui impliqueraient plusieurs lignes de code d&#39;une autre manière, et est couramment utilisé comme un compteur pour évaluer des tableaux, ou dessiner des choses. l&#39;exemple de code suivant illustre une utilisation typique pour ce type d&#39;instruction: <br><br><p class="code">{<br>
for (var i = 0; i &lt; 10; i += 1)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;draw_text(32, 32 + (i * 32), string(i) + ". "+
string(scr[i]));<br>
&nbsp;&nbsp;&nbsp;}<br>
}<br><span class="notranslate"></span></p><br> Le code ci-dessus initialise une boucle for, commençant à 0 et comptant jusqu&#39;à 9, puis utilise la valeur de boucle de &quot;i&quot; pour dessiner les valeurs stockées dans un tableau en bas de l&#39;écran. Notez comment la variable de boucle &quot;for&quot; &quot;i&quot; est utilisée non seulement pour parcourir le tableau, mais aussi pour dessiner un nombre et indiquer à <i><span class="notranslate">GameMaker Studio 2</span></i> où dessiner les valeurs dans la pièce. Cette flexibilité est l&#39;une des principales raisons pour lesquelles les boucles &quot;for&quot; sont si importantes dans la programmation. </div><br> <label class="collapse" for="six">commutateur</label> <input id="six"
type="checkbox"><div class="index_list"> Dans un certain nombre de situations, vous souhaitez laisser vos instances effectuer une action en fonction d&#39;une valeur particulière. Vous pouvez le faire en utilisant un certain nombre de &quot; <tt>if</tt> &quot;instructions mais quand les choix possibles sont au-dessus de deux ou trois, il est généralement plus facile d&#39;utiliser l&#39;instruction&quot; switch &quot;. <br><br><p class="code">switch (&lt;expression&gt;)<br>
{<br>
case &lt;expression1&gt;: &lt;statement1&gt;; ... ; break;<br>
case &lt;expression2&gt;: &lt;statement2&gt;; ... ; break;<br>
...<br>
default: &lt;statement&gt;;<br>
}<br><span class="notranslate"></span></p><br> Cela fonctionne comme suit: <br><br><ul><li> D&#39;abord l&#39;expression est exécutée. </li><li> Ensuite, il est comparé avec les résultats des différentes expressions après chacune des déclarations de cas. </li><li> L&#39;exécution continue après la première instruction case avec la valeur correcte, <i>jusqu&#39;à ce qu&#39;une instruction break soit rencontrée</i>. </li><li> Si aucune instruction case n&#39;a la bonne valeur, l&#39;exécution est poursuivie après l&#39;instruction default (il n&#39;est pas obligatoire d&#39;avoir une déclaration par défaut, auquel cas aucune action ne sera prise). </li></ul> Notez que plusieurs instructions de requête peuvent être placées pour la même instruction. En outre, la rupture n&#39;est pas requise et s&#39;il n&#39;y a pas d&#39;instruction break, l&#39;exécution continue simplement avec le code de l&#39;instruction case suivante. Cela signifie que vous pouvez créer un &quot;commutateur&quot; de hiérarchie dans lequel différentes sections de code sont exécutées en fonction de la valeur d&#39;entrée. voici un exemple de &quot;switch&quot; typique d&#39;un jeu: <br><br><p class="code">{<br>
switch (keyboard_key)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;case vk_left:<br>
&nbsp;&nbsp;&nbsp;case ord("A"):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x -= 4;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;&nbsp;case vk_right:<br>
&nbsp;&nbsp;&nbsp;case ord("D"):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x += 4;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;&nbsp;case vk_up:<br>
&nbsp;&nbsp;&nbsp;case ord("W"):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y -= 4;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;&nbsp;case vk_down:<br>
&nbsp;&nbsp;&nbsp;case ord("S"):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y += 4;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;&nbsp;}<br>
}<br><span class="notranslate"></span></p><br> Le code ci-dessus utilise &quot;switch&quot; pour vérifier un événement de clavier, puis compare cela aux cas répertoriés. S&#39;il répond à l&#39;une des valeurs requises, le code correspondant est exécuté. Notez comment dans le code nous avons utilisé la façon dont &quot;switch&quot; peut vérifier plusieurs cas et continuer si aucune rupture n&#39;est rencontrée pour permettre à différentes clés d&#39;être utilisées pour obtenir le même résultat. Ceci est juste l&#39;un des moyens que vous pouvez autoriser plusieurs configurations pour le mouvement dans vos jeux. </div><br> <label class="collapse" for="seven">Pause</label> <input id="seven"
type="checkbox"><div class="index_list"> L&#39;instruction &quot;break&quot; est utilisée pour terminer prématurément un <tt>for</tt>, <tt>repeat</tt>, <tt>while</tt>, <tt>do... until</tt> boucle d&#39;une sorte, ou de dire un <tt>switch</tt> déclaration à mettre fin à ce moment-là, ou de mettre fin prématurément à un <tt>with</tt> appel. Ci-dessous vous pouvez voir quelques exemples de comment cela peut être utilisé, et sa syntaxe est simple: <br><br><p class="code">break;<span class="notranslate"></span></p><br><p> &quot;break&quot; dans un <tt>for</tt> boucle: <br><br></p><p class="code">{<br>
var i;<br>
for (i = 0; i &lt; 10; i += 1)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if array[i] = 234 break;<br>
&nbsp;&nbsp;&nbsp;}<br>
num = i;<br>
}<br><span class="notranslate"></span></p><br> &quot;break&quot; dans un <tt>repeat</tt> boucle: <br><br><p class="code">{<br>
var i, temp;<br>
i = 0;<br>
temp = 0;<br>
repeat (10)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;temp += array[i];<br>
&nbsp;&nbsp;&nbsp;if temp &gt; max_total break else i += 1;<br>
&nbsp;&nbsp;&nbsp;}<br>
}<br><span class="notranslate"></span></p><br> &quot;break&quot; dans un <tt>while</tt> boucle: <br><br><p class="code">{<br>
var i;<br>
i = 0;<br>
while (!place_free(x, y))<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;x = random(room_width);<br>
&nbsp;&nbsp;&nbsp;y = random(room_height);<br>
&nbsp;&nbsp;&nbsp;if i &gt; 50 break else i+=1;<br>
&nbsp;&nbsp;&nbsp;}<br>
}<br><span class="notranslate"></span></p><br> &quot;pause&quot; lors de l&#39;utilisation <tt>with</tt>: <br><br><p class="code">{<br>
var count = 0;<br>
with (obj_Enemy)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;count++;<br>
&nbsp;&nbsp;&nbsp;if count &gt; 10 break;<br>
&nbsp;&nbsp;&nbsp;hp = 100;<br>
&nbsp;&nbsp;&nbsp;}<br>
}<br><span class="notranslate"></span></p></div><br> <label class="collapse" for="eight">continuer</label> <input id=
"eight" type="checkbox"><div class="index_list"> L&#39;instruction continue a la forme: <br><br><p class="code">continue<span class="notranslate"></span></p><br> Si utilisé à l&#39;intérieur d&#39;une instruction formant une boucle ( <tt>repeat</tt>, <tt>while</tt>, <tt>do... until</tt> ou <tt>for</tt> ), il retournera immédiatement au début de la boucle comme si la boucle avait traversé et rebouclé (s&#39;il est utilisé en dehors d&#39;une boucle, il agit comme un <tt>exit</tt> déclaration, sortie de l&#39;événement). Il fera également la même chose en utilisant le <tt>with</tt> fonction, où le code passe à l&#39;instance suivante et s&#39;exécute à nouveau. <br><br> Voici un exemple de son utilisation dans une boucle &quot;for&quot;: <br><br><p class="code">{<br>
var i;<br>
for (i = 0; i &lt; 10; i += 1)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if array[i] = "" continue;<br>
&nbsp;&nbsp;&nbsp;array[i] = "";<br>
&nbsp;&nbsp;&nbsp;}<br>
}<br><span class="notranslate"></span></p><br> Le code ci-dessus reviendra au début de la boucle si la valeur du tableau [i] est déjà une chaîne vide. </div><br> <label class="collapse" for="eleven">Sortie</label> <input id=
"eleven" type="checkbox"><div class="index_list"> L&#39;instruction de sortie a la forme suivante: <br><br><p class="code">exit;<span class="notranslate"></span></p><br> &quot;Exit&quot; termine simplement l&#39;exécution du script ou de l&#39;événement en cours. Notez qu&#39;il existe une légère différence d&#39;utilisation ici en fonction de la portée: si vous utilisez <tt>exit</tt> dans un script est simplement quitter le script et retourner au code qui a appelé le script, cependant si vous utilisez cet événement dans un bloc de code depuis un objet, il quittera <i>l&#39;événement entier</i> même s&#39;il y a plusieurs blocs de code séparés après le la fonction a été appelée. Généralement, il est utilisé pour éviter une instance exécutant un bloc de code spécifique, par exemple un événement de collision. Le code ci-dessous en donne un exemple simple: <br><br><p class="code">{<br>
if !visible exit;<br>
while (place_meeting(x, y))<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;x -= lengthdir_x(1, direction - 180);<br>
&nbsp;&nbsp;&nbsp;y -= lengthdir_y(1, direction - 180);<br>
&nbsp;&nbsp;&nbsp;}<br>
}<br><span class="notranslate"></span></p><br> Le code ci-dessus vérifie une variable et si elle se résout à vrai, alors il existe le bloc de code, sinon il va de l&#39;avant et exécute le reste du code. <div class="note"> <b>Note:</b> Cela ne met pas fin à l&#39;exécution du jeu. Pour cela, vous devez utiliser la fonction <a href=
"../4_gml_reference/game/game_end.html"><tt>game_end</tt></a>. </div></div><br> <label class="collapse" for="nine">avec</label> <input id="nine"
type="checkbox"><div class="index_list"> Comme indiqué dans la section <a hreff=
"7_Addressing_Variables.html">Adressage des variables dans d&#39;autres instances</a>, il est possible de lire et de modifier la valeur des variables dans d&#39;autres instances. Mais dans un certain nombre de cas, vous voulez faire beaucoup plus que juste changer une seule variable avec ces autres instances. Par exemple, imaginez que vous voulez déplacer tous les objets de la balle dans votre jeu de 8 pixels. Vous pouvez penser que cela est réalisé simplement par le morceau de code suivant: <br><br><p class="code">obj_ball.y = obj_ball.y + 8;<span class="notranslate"></span></p><br> Mais ce n&#39;est pas correct, car le côté droit de l&#39;assignation obtient la valeur de la coordonnée y de la première boule et lui ajoute 8. Ensuite, cette nouvelle valeur est définie en tant que coordonnée y de toutes les billes, de sorte que toutes les billes ont la même coordonnée y, et même si vous utilisez ce qui suit: <br><br><p class="code">obj_ball.y += 8;<span class="notranslate"></span></p><br> cela aura exactement le même effet parce que c&#39;est simplement une abréviation de la première déclaration. Alors, comment pouvons <i>-</i> nous y parvenir? Pour cela, il existe l&#39;instruction <b>with</b> dans GML. Sa forme globale est: <br><br><p class="code">with (&lt;expression&gt;) &lt;statement&gt;<span class="notranslate"></span></p><br> &lt;Expression&gt; indique une ou plusieurs instances, et pour cela vous pouvez utiliser un identifiant d&#39;instance, le nom d&#39;un objet (qui indique que <i>toutes les instances</i> de cet objet doivent exécuter le bloc de code) ou l&#39;un des <i>mots-clés</i> spéciaux ( <b>all</b>, <b>self</b>, <b>autre</b> ). &lt;Instruction&gt; est maintenant exécuté pour chacune des instances indiquées, comme si cette instance était l&#39;instance (auto) actuelle. Ainsi, pour déplacer toutes les instances de l&#39;objet boule de 8 pixels vers le bas, vous pouvez taper: <br><br><p class="code">with (obj_ball) y += 8;<span class="notranslate"></span></p><br> Si vous voulez exécuter plusieurs instructions, placez des accolades autour d&#39;elles, comme vous le feriez pour n&#39;importe quel autre programme. Ainsi, par exemple, pour déplacer toutes les balles dans une position aléatoire, vous pouvez utiliser: <br><br><p class="code">with (obj_ball)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;x = random(room_width);<br>
&nbsp;&nbsp;&nbsp;y = random(room_height);<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Notez que, dans les instructions, l&#39;instance indiquée est devenue l&#39;instance (auto) cible qui exécute le bloc de code, ce qui signifie que les instructions de l&#39;instance d&#39;origine (qui contient le &quot;avec&quot; et le bloc de code) sont devenues <b>autre</b> instance. Par exemple, pour déplacer toutes les balles à la position de l&#39;instance en cours, vous pouvez taper ceci: <br><br><p class="code">with (obj_ball) { x = other.x; y = other.y; }<span class="notranslate"></span></p><br> L&#39;instruction with est un outil extrêmement puissant et utile dans de nombreuses circonstances, il est donc important que vous compreniez parfaitement comment il peut être utilisé. Pour aider, voici quelques autres exemples d&#39;utilisation: <br><br><p class="code">with (instance_create_layer(x, y, "Instances",
obj_Ball))<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;speed = other.speed;<br>
&nbsp;&nbsp;&nbsp;direction = other.direction;<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Le code ci-dessus crée une instance de obj_Ball et lui assigne la vitesse et la direction de l&#39;instance qui exécute le bloc de code entier. <br><br><p class="code">with (instance_nearest(x, y, obj_Ball))<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;instance_destroy();<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Le code ci-dessus détruira l&#39;instance d&#39;obj_Ball la plus proche de l&#39;instance exécutant le code. <br><br><p class="code">var inst;<br>
inst = noone;<br>
with (obj_ball)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if str &gt; other.str inst = id;<br>
&nbsp;&nbsp;&nbsp;}<br>
if inst != noone target = inst;<br><span class="notranslate"></span></p><br> Le code ci-dessus est légèrement plus complexe que les précédents en raison de l&#39;utilisation d&#39;une variable locale. Cette variable est locale au <i>script</i> et non à l&#39;instance et peut donc être utilisée et accédée par toutes les instances référencées dans le bloc de code. Donc, dans le code, nous l&#39;avons défini sur le <i>mot-clé</i> spécial <b>noone</b>, puis utilisez la construction &quot;with&quot; pour que chaque instance de obj_Ball vérifie leur variable &quot;str&quot; ​​par rapport à celle de l&#39;instance exécutant le bloc de code. Si la valeur de la variable est plus grande, ils stockent leur identifiant unique dans la variable locale &quot;inst&quot;, ce qui signifie qu&#39;à la fin du code, seule l&#39;instance avec une valeur supérieure à l&#39;instance appelante (ou le <i>mot</i> - <i>clé</i> <b>noone</b> si aucun sont plus grands) seront stockés dans la variable locale inst. Pour plus d&#39;informations sur les variables locales, voir la section <a href="6_scope.html">Variables Et variable Portée</a>. </div><br> <label class="collapse" for="ten">revenir</label> <input id="ten"
type="checkbox"><div class="index_list"> L&#39;instruction de retour a la forme: <br><br><p class="code">return (&lt;expression&gt;)<br><span class="notranslate"></span></p><br> Vous utilisez uniquement le <tt>return</tt> déclaration dans les <a href=
"../../2_interface/1_editors/scripts.html">scripts</a>, et il est utilisé pour renvoyer une valeur du script à utiliser dans d&#39;autres appels de code ou de script. Il convient de noter que l&#39; <i>exécution du script se termine à l&#39;instruction return</i>, ce qui signifie que tout code qui vient après que le retour a été appelé ne sera pas exécuté. Voici un court exemple de script appelé &quot; <tt>scr_sqr</tt> &quot;qui calcule le carré de la valeur qui lui est transmise, et il inclut l&#39;erreur catching au cas où l&#39;argument qu&#39;il est passé n&#39;est pas un nombre réel: <br><br><p class="code">{<br>
if !is_real(argument0)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;return 0;<br>
&nbsp;&nbsp;&nbsp;}<br>
else<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;return (argument0 * argument0);<br>
&nbsp;&nbsp;&nbsp;}<br>
}<br><span class="notranslate"></span></p><br> Pour appeler un script à l&#39;intérieur d&#39;un code, agissez de la même manière que lorsque vous appelez des fonctions, c&#39;est-à-dire, écrivez le nom du script avec les valeurs d&#39;argument entre parenthèses. Donc, le script ci-dessus serait appelé comme ceci: <br><br><p class="code">if keyboard_check_pressed(vk_enter)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;val = scr_sqr(amount);<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p></div><br></blockquote><p><br></p></div><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> Retour: <a href="index.html">Présentation du GML</a> </div><div style="float:right"> Next: <a href="1_code.html">Structure de code de base</a> </div></div></div><h5> © Copyright <span class="notranslate">YoYo Games Ltd.</span> 2017 Tous droits réservés </h5>
<script type="text/javascript">
   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');   ga('create', 'UA-2711665-14', 'auto');   ga('send', 'pageview'); 
</script>
</div>

<script type="text/JavaScript">
var fe = FindFrame("toc", top);
if ((fe != null) && (chmtop.c2wtopf.jstree != null)) {
  if (chmtop.c2wtopf.FITEMS[chmtop.c2wtopf.pagenum] != chmtop.c2wtopf.pageid)
    chmtop.c2wtopf.jstree.OpenTreeNode("source/" + chmtop.c2wtopf.pageid);
}
</script>
</body>
</html>
